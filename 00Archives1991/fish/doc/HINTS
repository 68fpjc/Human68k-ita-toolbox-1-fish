■ make -n | itash

■ 組み込みコマンドと同名の外部コマンドは
	ディレクトリを付ける
	拡張子を付ける
	alias notbuiltin '`which -O \!:1` \!:2*'
	大文字でタイプする

■ home はドライブ名を含むルートディレクトリからの絶対パスとすること。さもないと、

	% set home=/home
	% cd
	% dirs
	A:/home
	% set home=A:/home
	% dirs
	~
	%

■ #! make -f とすれば、いちいち make -f mf1 ; make -f mf2 としなくても mf1 ; mf2 でいい

■ 式

	~ == A:/usr2/ita

   はエラーである。~ が単項演算子になるためである。

	~/ == A:/usr2/ita/

   と書けばＯＫ

■  コマンド置換で ` を含むコマンドを実行するには
	set accent=\`
	emacs `grep -l ${accent}echo *.c`
    のようにすれば良い。

■  $path の中に絶対パスでないものがあるならば、それは確実にハッシュ効率を低下させ、
    コマンド検索に時間がかかることになる。

■  カレント・ディレクトリ /usr2/ita に ~~ というディレクトリがあって、その中にある
    コマンドを実行したいとき、~~/command とすると組み込みコマンドが検索されてしまう
    ので、./~~/command とするか、/usr2/ita/~~/commanad とする。カレント・ディレクト
    リが / ならば、Human68k の場合 ./~~/command とすることができないので、
    /~~/command とする。
    以上のことはファイル名完成機能においても同様。

■  / で始まる引数をフラグ引数と見なすコマンドが多く存在することは大変困ったことで
    ある。そういうコマンドに対して / で始まるパス名を与えるには、パス名にドライブ名
    を加えれば回避できる。ただしドライブ名を解釈しないコマンドではお手上げ。

■  $var:gs/foo/&bar/ では、変数置換が行われるよりも前に、& コマンド行の文法上の
    区切文字として認識されてしまう。かと言って & をエスケープすると、& の特別な意味を
    失ってしまう。この場合には ${var:gs/foo/&bar/} とする。

■  ${var:gs/)/}/} は正しい。最初の } は :s/l/r/ 修飾における r として認識される。

■  バイナリー・データもパイプを通したりリダイレクトできる。
    COMMAND.X でそれができないのは、1A(16) をファイルの終わりとして処理しているため。
    なぜいまさら CP/M との互換性が必要なのか？
    CP/M のテキスト・ファイルを扱うのなら、予めファイルを 1A(16) の位置で trunc
    しておけば済むことである。

■  組み込みコマンド set と @ では、他のコマンドと違い、実行前にシェル変数
    status を 0 にセットし、実行後には、エラーでなければ status は再設定しない。
    そうでないと set や @ で status をセットできない。

