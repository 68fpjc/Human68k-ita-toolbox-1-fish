csh にあって fish に無い

	!#		履歴
	&		バックグラウンドでのコマンドの実行
	%		ジョブ番号
	alloc		組み込みコマンド
	bg		組み込みコマンド
	chsh		組み込みコマンド
	exec		組み込みコマンド
	fg		組み込みコマンド
	jobs		組み込みコマンド
	kill		組み込みコマンド
	limit		組み込みコマンド
	login		組み込みコマンド
	logout		組み込みコマンド
	nice		組み込みコマンド
	nohup		組み込みコマンド
	notify		組み込みコマンド
	stop		組み込みコマンド
	suspend		組み込みコマンド
	umask		組み込みコマンド
	unlimit		組み込みコマンド
	wait		組み込みコマンド
	-r		式の演算子
	-x		式の演算子
	-o		式の演算子

csh になくて fish にある

	lock		組み込みコマンド
	pwd		組み込みコマンド
	which		組み込みコマンド
	stdgets		シェル変数
	temp		シェル変数
	SHELL		環境変数
	temp		環境変数
	<<=		組み込みコマンド @ の代入演算子
	>>=		組み込みコマンド @ の代入演算子
	&=		組み込みコマンド @ の代入演算子
	|=		組み込みコマンド @ の代入演算子
	-a		式の演算子
	-h		式の演算子
	-s		式の演算子
	-v		式の演算子
	-E		式の演算子
	sizeof		式の演算子
	timeof		式の演算子
	freeof		式の演算子
	0ddd 0xddd	式の一次子
	:d		置換修飾子
	:f		置換修飾子
	:		別名置換抑止機構
	~~		組み込みコマンドの仮想ディレクトリ

csh と違っている

	path		環境変数		cshでは PATH
	shell		シェル変数		初期値を環境変数 SHELL から得ている
	<= >= <<= >>= &= |=			１つの単語として扱う
	history		シェル変数		単に組み込みコマンドhistoryのデフォルトとして働く

	組み込みコマンド time がサブシェルにも効く

	組み込みコマンド repeat や time の引数にサブシェルコマンドを書くことができる

	time報告は疑似的である

	!{
		csh では ! になる
		fish ではエラーになる

	!}
		csh では !} になる
		fish では直前の行に } を加える

	!{}
		csh では !} になる
		fish では直前の行になる

	!%

	\!

	!\

	fishではラベルの後に文やコマンドがあっても良い

	パターンマッチングが、細かいところで違っている

	csh では演算子の係る項が無い場合、係る項を 0 とみなすが、fish ではエラーとなる

	csh では左右に項の無い式 * も二項演算式 0 * 0 であると見なすが、fish では
	* は一次子であると見なす。

	csh では % もファイル名完成機能の区切り文字とするが、
	fish では % もファイル名の一部と見なす

	csh では $var[0-x] は Subscript out of range だが、fish では Subscript syntax.

	ファイル名展開において、csh では、~ で始まり、そのあとに英大小文字／数字／
	'_'／'-' で構成される文字列が続き、そのあとに文字が無いか、または / が続く
	場合に、文字列をユーザのログイン名とみなす。fish では、~ のあとに英小文字／
	数字で構成される文字列が続き、そのあとに文字が無いか、または / あるいは \\
	\/ が続く場合に、文字列をユーザのログイン名とみなす。

	fish ではファイル名の \\ と \/ を、/ と同等に扱う。ただしファイル名完成機能
	では \ を含むファイル名は完成させない。

	シェル変数名にシフトＪＩＳ２バイトコードを使用できる。

	csh では、${ と } の間に | & ; < > ( ) があると、おかしな認識をする。
	fish では ${ と } の間の文字はどれも特別な意味を持たない。
	${ が入れ子になっていてもうまくいく。（完全ではないかもしれない）

	set foo=(1 2 3) ; echo ${foo}x は、csh では 1 2 3 x だが、fish では 1 2 3x

        csh では変数置換のうちのいくつかは修飾することができないが、fish ではそのような
	制限は無い。

	csh では1つの変数置換に修飾子は１つしか認められないが、fish ではいくつでも
	並べることができる。

	fish では変数置換に :s を使用できる

	fish では :s 修飾の仕様を修正拡張した

		fish では :s の区切り文字にシフトJISを使えるようにしたが、
		反面、残念ながら } は使用できないようにした

		csh では :gs/l/r/ で、1つの単語の中に l が 2回以上現われていても、1つの単語の
		中では最初の部分しか置換しない。fish ではすべて置換するようにした。

		csh では :s^l^r^ や ^l^r^ の l や r に含まれる \ は、^ または \ をエスケープ
		しているもの（r ではさらに & をエスケープしているもの）以外のものは、削除され
		ない。fish ではそのような混乱は排除した。

		csh では :s/l/r/ の l や r の長さの上限は \ を除いた長さであるが、fish では
		\ も含めた長さを意味する。

		& に加えて % ^ $ をメタ記号とした

	csh では履歴置換において g 付きのパス名修飾子は無視される
	fish ではパス名修飾子は全単語に適用し、global というオプションは無い

	csh では !% は Bad ! arg selecter. だが、itash では % で始まるイベントを探す

	fish では histchars にシフトＪＩＳ文字が使える

	シェル変数 histchars が定義されているとき、csh では $histchars[1] の値が 2文字未満
	でだと不思議な動作をする。fish では、次のように明確に定義している。
	シェル変数 histchars の単語数が 0個である場合や、$histchars[1] の文字数が 0文字で
	ある場合には、! の代わりも ^ の代わりも無しとする。さもなくば $histchars[1] の最初
	の文字が ! の代わりとなる。さらに文字が続いているならば、2文字目が ^ の代わりとなる
	が、$histchars[1] が 1文字だけであるならば、^ の代わりは無し。

	set status=(1 2) ; echo $status は、csh では 1 2 だが fish では 1 となる

	csh では、set や @ の構文にエラーがあった場合、続くコマンド・リストは実行されない
	が、fish ではそのようなことはない

	csh では !?str? の str の有効最大長は30文字だが、fish は31文字

	単一のコマンドを実行するとき、csh では、まず最初の単語が組み込みコマンド名で
	あるかどうかを調べ、組み込みコマンドでないならば、最初の単語に対してコマンド
	置換とファイル名展開を行い、その後エスケープとクオートを外す。したがって、最
	初の単語が \ " ' でクオートされている場合には組み込みコマンドとは認識しない。
	また、コマンド置換で得られるコマンド名で組み込みコマンドを起動することはでき
	ない。fish では、まず最初の単語に対してコマンド置換とファイル名展開を行い、
	その後エスケープとクオートを外す。そうして得られたコマンド名に対して、それが
	組み込みコマンドであるかどうかを調べるので、組み込みコマンド名をエスケープし
	てもかまわないし、コマンド置換で得られるコマンド名で組み込みコマンドを起動す
	ることもできる。

	csh は /bin\/* をうまく展開してくれない。fish は展開するようにした。

	-l name で、name が * のとき、csh は * を演算子であると解釈してしまい、
	Missing file name. というエラーとなる。fish では、-l * で 1つの一次子であると
	解釈する。

	fish では $$ は疑似的である

	csh では () は Invalid null command. fish では許す

	csh では () の中のコマンドの別名置換は現在のシェルが行うが、fish では
	サブシェルが行う

	csh ではパイプラインの最後のコマンド以外は fork される。すなわち組み込み
	コマンドはサブ・シェルで実行される。fish では、たとえ組み込みコマンドで
	あっても現在のシェルで実行する。time|more の動作の違いは興味深い。

	‘'’や‘"’で囲まれた中で、改行文字の前に‘\’を付けると、csh では CR
	となるが fish では CR LF となる

	Human68k ではファイル・モードに実行可能ビットが無いので、fish では
	#! で始まっているファイルをシェル・スクリプトとして実行可能なものとする

	Human68k ではファイル・モードに実行可能ビットが無いので、fish では
	ファイル名完成機能のリスト表示に * は表示しない

	csh では -n では変数展開の単語選択子（[] の中）は検査しないようだが、
	fish では検査するようにした。

	foo`echo " bar "`baz は、csh では foobar baz の 2語になるが、
	fish では foobarbaz になる

