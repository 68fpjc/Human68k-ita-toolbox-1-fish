
                                                                 6-JUNE-1988

	ＢＩＮＤ．Ｘを用いてＣＯＭＭＡＮＤ．Ｘに以下の構造のＸファイルを
	ジョイントすることによって拡張コマンドとして登録することが出来ます
	但し、このＣＯＭＭＡＮＤ．Ｘが実行できるＯＳはHuman68k version 2.00
	以後のＯＳに限られます

	拡張コマンドの内部構造（Ｘファイル形式）

		.text

************************************************************************

	コマンドヘッダブッロク５８バイト

prog_top:
		dc.l	data_top_ptr
	保持しておきたいデータ領域の先頭のポインタ
	コプロセスとしてのCOMMAND.Xを実行するとこの中のinit_progが
	呼ばれるので親に戻った時に元に戻すデータ領域の先頭のポインタ
	データ領域が無い場合は０にしておく
	最初このデータ領域には何が入っているのかは分からないので
	init_progの中で初期化すること

		dc.l	prog_end-prog_top
	常駐すべきプログラム、データ領域を合わせた長さ

		dc.l	init_prog
	COMMAND.X起動後呼び出される初期設定プログラムのアドレス
	コプロセスとしてのCOMMAND.Xを実行する時にも呼び出される
	０にしておくと呼び出されない

		dc.l	prog_end-data_top_ptr
	保持しておきたいデータ領域の長さ
	データ領域が無い場合は０にしておく

		dc.b	'Command2.0???',0
	COMMAND.Xバージョン識別文字列
	???３文字は何でも良いが、マイナーバージョン番号にする

		dc.l	ctrl_c_prog
	COMMAND.X実行中CTRL+Cされた時に呼び出されるプログラム
	自分を実行中かどうかを判断して処理をすべきかどうかを判定すること
	０にしておくと呼び出されない

		dc.l	abort_prog
	COMMAND.X実行中ＯＳコール内でアボートされた時に呼び出されるプログラム
	自分を実行中かどうかを判断して処理をすべきかどうかを判定すること
	０にしておくと呼び出されない

		dc.l	cmd_name_ptr
	コマンド名テーブルへのポインタ

		dc.l	cmd_entry_ptr
	エントリーポイントテーブルへのポインタ

		dc.l	exit_prog
	COMMAND.X終了時呼び出される終了処理プログラムのアドレス
	コプロセスとしてのCOMMAND.Xを終了する時にも呼び出される
	０にしておくと呼び出されない




                              - 1 -

		dc.l	keep_prog
	COMMAND.Xが常駐部を組み込んだ後に１度だけ呼び出されるプログラムの
	アドレス
	コプロセスとしてのCOMMAND.Xを実行する時には呼び出されない
	タイトルメッセージの表示やベクターのセットなどはここで実行する
	０にしておくと呼び出されない

		dc.l	kill_prog
	常駐部を組み込んだCOMMAND.Xが終了する時に常駐部を破棄する前に
	１度だけ呼び出されるプログラムのアドレス
	コプロセスとしてのCOMMAND.Xを終了する時には呼び出されない
	ベクターのリセットなどはここで実行する
	０にしておくと呼び出されない

************************************************************************

entry1:
	entry1のコマンドエントリー
	コールされた時点でレジスタは以下のようにセットされている
		a0.l	コマンドラインへのポインタ
			      v
			'case /up /d *.* a:',0
		d0.w	コマンドラインの長さ
			'case /up /d *.* a:',0
			      <----13----->
		a1.l	パラメータへのポインタ
			 v
			'*.*',0,'a:',0,0
		d1.w	パラメータの個数
			'*.*',0,'a:',0,0
			 ^       ^     <- 2
		a2.l	スイッチへのポインタ
			 v
			'u',0,'p',0,'d',0,0
		d2.w	スイッチの個数
			'u',0,'p',0,'d',0,0
			 ^     ^     ^ <- 3
		a3.l	コマンドサブシステムへのポインタ
			moveq.l	#FUNC,d7	*機能番号
			jsr	(a3)		*コマンドサブシステム呼び出し
	リターンする前には以下のレジスタをセットしてリターンすること
		d0.l	終了コード
			もし０ならば
				正常終了
			もしプラスならば
				ｄ０．ｌはｅｒｒｏｒｌｅｖｅｌ
				ａ０．ｌはエラーメッセージへのポインタ
				ａ０．ｌが０ならエラーメッセージ無し
			もしマイナスならば
				ｄ０．ｌはＯＳのエラーコード
				エラーメッセージは自動的に表示される

		move.b	#-1,job1_in_flag
	ctrl_c_prog,abort_progで自分を実行中か判断するためのフラグを
	セットしておく ……＞ctrl_c_prog,abort_progの項を参照
	注意事項
	この処理プログラムの中では以下のような制限事項があります
	プロセス管理を行うプログラム（コプロセスの実行、プロセスの終了など）は
	やってはいけません（その後の動作は保証しません）
	ＣＴＲＬ＋Ｃ，アボートの処理ベクターを変更してはいけません
	この中でメモリの確保をしてはいけません（init_progかkeep_progの中で
	メモリの確保をして下さい。またinit_progで確保したものはexit_progで
	keep_progで確保したものはkill_progで必ず開放して下さい）

                              - 2 -

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

	entry1の処理プログラムをここに入れる

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

		clr.b	job1_in_flag
	ctrl_c_prog,abort_progで自分を実行中か判断するためのフラグを
	クリアしておく ……＞ctrl_c_prog,abort_progの項を参照

		rts
	メインに戻る

************************************************************************

entry2:
	entry2のコマンドエントリー
	entry1と同じ様に作る

************************************************************************

entry3:
	entry3のコマンドエントリー
	entry1と同じ様に作る

************************************************************************

entry4:
	entry4のコマンドエントリー
	entry1と同じ様に作る

************************************************************************

init_prog:
	COMMAND.X起動後呼び出される初期設定プログラム

		clr.b	job1_in_flag
		clr.b	job2_in_flag
		clr.b	job3_in_flag
		clr.b	job4_in_flag
	ctrl_c_prog,abort_progで自分を実行中か判断するためのフラグをクリアして
	おく

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

	自分で使用するワークエリアの初期化をするプログラムをここに入れる

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

		rts
	メインに戻る

************************************************************************

ctrl_c_prog:
		tst.b	job1_in_flag
		beq	ctrl_c_2
	entry1を実行中かどうか調べる
		clr.b	job1_in_flag
	メインに戻るのでフラグをクリアしておく




                              - 3 -

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

	entry1実行中にCTRL+Cされた時に実行するプログラムをここに入れる

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

		rts
	メインに戻る

ctrl_c_2:	tst.b	job2_in_flag
		beq	ctrl_c_3
	entry2を実行中かどうか調べる
		clr.b	job2_in_flag
	メインに戻るのでフラグをクリアしておく

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

	entry2実行中にCTRL+Cされた時に実行するプログラムをここに入れる

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

		rts
	メインに戻る

ctrl_c_3:	tst.b	job3_in_flag
		beq	ctrl_c_4
	entry3を実行中かどうか調べる
		clr.b	job3_in_flag
	メインに戻るのでフラグをクリアしておく

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

	entry3実行中にCTRL+Cされた時に実行するプログラムをここに入れる

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

		rts
	メインに戻る

ctrl_c_4:	tst.b	job4_in_flag
		beq	ctrl_c_end
	entry4を実行中かどうか調べる
		clr.b	job4_in_flag
	メインに戻るのでフラグをクリアしておく

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

	entry4実行中にCTRL+Cされた時に実行するプログラムをここに入れる

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ctrl_c_end:
		rts
	メインに戻る

************************************************************************

abort_prog:
	ctrl_c_progと同じ様に作る

************************************************************************



                              - 4 -

exit_prog:
	COMMAND.X終了時呼び出される終了処理プログラム

		rts
	メインに戻る

************************************************************************

keep_prog:
	COMMAND.Xが常駐部を組み込んだ後に１度だけ呼び出されるプログラム

		rts
	メインに戻る

************************************************************************

kill_prog:
	常駐部を組み込んだCOMMAND.Xが終了する時に常駐部を破棄する前に
	１度だけ呼び出されるプログラム

		rts
	メインに戻る

************************************************************************

		.data

************************************************************************

cmd_name_ptr:	dc.l	name1
		dc.l	name2
		dc.l	name3
		dc.l	name4
		dc.l	0
	コマンド名テーブル
	０でテーブルの終わり

************************************************************************

cmd_entry_ptr:	dc.l	entry1
		dc.l	entry2
		dc.l	entry3
		dc.l	entry4
		dc.l	0
	エントリーポイントテーブル
	０でテーブルの終わり

************************************************************************

name1:		dc.b	'case',0
name2:		dc.b	'process',0
name3:		dc.b	'find',0
name4:		dc.b	'where',0
	コマンド名
	英文字は小文字にすること
	必ず７文字以下にすること
	ＣＯＭＭＡＮＤ．Ｘで使用される制御用文字は使わないこと
	必ず０で終わること

************************************************************************




                              - 5 -

data_top_ptr:
job1_in_flag:	ds.b	1
job2_in_flag:	ds.b	1
job3_in_flag:	ds.b	1
job4_in_flag:	ds.b	1

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

	常駐部で使用するワークエリアをここに入れる

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

prog_end:
	ここまでが常駐部としてのプログラム

************************************************************************

		even

	ここからは通常のＸファイルとして動作した時のプログラム
	なにも処理しない場合でも必ずＯＳコールのプロセス終了を行うこと
	これを入れておかないと通常のＸファイルとして動作した時に暴走の
	危険がある

exec_entry:
	通常のＸファイルとして実行をした時のエントリーポイント
	常駐すべきプログラムの外にする（prog_end:より後に書く）こと
	endの後にここのエントリを書いておく

		dc.w	$ff00
	処理後はrtsせずにＯＳコールのプロセス終了を行う

		end	exec_entry
	endの後には通常のＸファイルとして実行をした時のエントリーポイント
	を書いておく

************************************************************************

	常駐部が使用するワークはdata_top_ptrからprog_endの間に書き
	.dataセクションにしておくこと

	通常のＸファイルとして実行をした時のみに使用するワークメモリ（
	スタックも含む）はexec_entryのプログラムの後へ書き
	.bssセクションにしておくこと

************************************************************************


















                              - 6 -

	コマンドサブシステムでサポートされるサービスルーチンは以下のものが
	あります

__itoa		equ	$00
機能番号 $00

	数値を１０進文字列に変換する
	文字列は１０桁になるが、先頭からの０は空白になる

入力	Ｄ０．Ｌ	変換する数値
	Ａ０．Ｌ	文字列を格納するポインタ
			１２バイト必要

	lea	buf_ptr,a0
	move.l	#123456,d0
	moveq.l	#__itoa,d7
	jsr	(a3)

buf_ptr:
	ds.b	12

戻り値	なし
	buf_ptrの内容
	dc.b	'    123456',0

*****************************************************************

__itoa0		equ	$01
機能番号 $01

	数値を１０進文字列に変換する
	文字列は１０桁になる

入力	Ｄ０．Ｌ	変換する数値
	Ａ０．Ｌ	文字列を格納するポインタ
			１２バイト必要

	lea	buf_ptr,a0
	move.l	#123456,d0
	moveq.l	#__itoa0,d7
	jsr	(a3)

buf_ptr:
	ds.b	12

戻り値	なし
	buf_ptrの内容
	dc.b	'0000123456',0
















                              - 7 -

__htoa		equ	$02
機能番号 $02

	数値を１６進文字列に変換する
	文字列は８桁になる

入力	Ｄ０．Ｌ	変換する数値
	Ａ０．Ｌ	文字列を格納するポインタ
			１０バイト必要

	lea	buf_ptr,a0
	move.l	#$abc01,d0
	moveq.l	#__htoa,d7
	jsr	(a3)

buf_ptr:
	ds.b	10

戻り値	なし
	buf_ptrの内容
	dc.b	'000ABC01',0

*****************************************************************

__atoi		equ	$03
機能番号 $03

	１０進文字列を数値に変換する

入力	Ａ０．Ｌ	文字列が格納されているポインタ

	lea	num_str,a0
	moveq.l	#__atoi,d7
	jsr	(a3)

num_str:
	dc.b	'-200',0

	変換可能な文字は、先頭の'-'か、'0'〜'9'のみ

戻り値	Ｄ０．Ｌ	変換された数値
	Ｄ１．Ｌ	変換状態
			正の数の場合
			　１０以下	変換した文字数
			　１１以上	オーバーフロー（Ｄ０は不定）
			負の数の場合
			　変換不可能な文字があった
			　（変換不可能な文字の位置）の負数
			　−３なら２桁変換して３桁目が異常















                              - 8 -

__atois		equ	$04
機能番号 $04

	１０進文字列を数値に変換する
	先頭のタブ、空白は無視する

入力	Ａ０．Ｌ	文字列が格納されているポインタ

	lea	num_str,a0
	moveq.l	#__atois,d7
	jsr	(a3)

num_str:
	dc.b	'   -123',0

	変換可能な文字は、先頭の'-'か、'0'〜'9'のみ

戻り値	Ｄ０．Ｌ	変換された数値
	Ｄ１．Ｌ	変換状態
			正の数の場合
			　１０以下	変換した文字数
			　１１以上	オーバーフロー（Ｄ０は不定）
			負の数の場合
			　変換不可能な文字があった
			　（変換不可能な文字の位置）の負数
			　−３なら２桁変換して３桁目が異常

*****************************************************************

__asc_date	equ	$05
機能番号 $05

	日付文字列を日付バイナリーコードに変換する

入力	Ａ０．Ｌ	文字列が格納されているポインタ

	lea	date_str,a0
	moveq.l	#__asc_date,d7
	jsr	(a3)

date_str:
	dc.b	'88-04-23',0

	変換可能な文字列は次のものがある
	dc.b	'88/04/23',0
	dc.b	'88-04-23',0
	dc.b	'1988/04/23',0
	dc.b	'1988-04-23',0
	dc.b	'88/4/23',0
	dc.b	'88-4-23',0
	dc.b	'1988/4/23',0
	dc.b	'1988-4-23',0

戻り値	Ｄ０．Ｌ	変換された数値
			正の数の場合
			　日付バイナリーコード
			0000_0000_0000_0000_YYYY_YYYM_MMMD_DDDD
			負の数の場合
			　変換不可能な文字があったか、不正な日付だった





                              - 9 -

__date1_asc	equ	$06
機能番号 $06

	日付バイナリーコードを日付文字列に変換する

入力	Ｄ０．Ｌ	日付バイナリーコード
			0000_0000_0000_0000_YYYY_YYYM_MMMD_DDDD
	Ａ０．Ｌ	格納する文字列のポインタ

	move.l	#$1097,d0
	lea	buf_ptr,a0
	moveq.l	#__date1_asc,d7
	jsr	(a3)

buf_ptr:
	ds.b	20

戻り値	なし
	buf_ptrの内容
	dc.b	'88-04-23',0

*****************************************************************

__date2_asc	equ	$07
機能番号 $07

	日付バイナリーコードを日付文字列に変換する

入力	Ｄ０．Ｌ	日付バイナリーコード
			0000_0000_0000_0000_YYYY_YYYM_MMMD_DDDD
	Ａ０．Ｌ	格納する文字列のポインタ

	move.l	#$1097,d0
	lea	buf_ptr,a0
	moveq.l	#__date2_asc,d7
	jsr	(a3)

buf_ptr:
	ds.b	20

戻り値	なし
	buf_ptrの内容
	dc.b	'1988-04-23 (土)',0





















                             - 10 -

__asc_time	equ	$08
機能番号 $08

	時刻文字列を時刻バイナリーコードに変換する

入力	Ａ０．Ｌ	文字列が格納されているポインタ

	lea	time_str,a0
	moveq.l	#__asc_time,d7
	jsr	(a3)

time_str:
	dc.b	'09:01:10',0

	変換可能な文字列は次のものがある
	dc.b	'09:01:10',0
	dc.b	'9:1:10',0

戻り値	Ｄ０．Ｌ	変換された数値
			正の数の場合
			　時刻バイナリーコード
			0000_0000_000H_HHHH_00MM_MMMM_00SS_SSSS
			負の数の場合
			　変換不可能な文字があったか、不正な時刻だった

*****************************************************************

__time1_asc	equ	$09
機能番号 $09

	時刻バイナリーコードを時刻文字列に変換する
	ただし秒は２秒単位

入力	Ｄ０．Ｌ	時刻バイナリーコード
			0000_0000_0000_0000_HHHH_HMMM_MMMS_SSSS
	Ａ０．Ｌ	格納する文字列のポインタ

	move.l	#$9e2f,d0
	lea	buf_ptr,a0
	moveq.l	#__time1_asc,d7
	jsr	(a3)

buf_ptr:
	ds.b	20

戻り値	なし
	buf_ptrの内容
	dc.b	'19:49:30',0
















                             - 11 -

__time2_asc	equ	$0a
機能番号 $0a

	時刻バイナリーコードを時刻文字列に変換する

入力	Ｄ０．Ｌ	時刻バイナリーコード
			0000_0000_000H_HHHH_00MM_MMMM_00SS_SSSS
	Ａ０．Ｌ	格納する文字列のポインタ

	move.l	#$13311f,d0
	lea	buf_ptr,a0
	moveq.l	#__time2_asc,d7
	jsr	(a3)

buf_ptr:
	ds.b	20

戻り値	なし
	buf_ptrの内容
	dc.b	'19:49:31',0

*****************************************************************

__strlen	equ	$0b
機能番号 $0b

	文字列の長さを得る

入力	Ａ０．Ｌ	文字列が格納されているポインタ

	lea	string,a0
	moveq.l	#__strlen,d7
	jsr	(a3)

string:
	dc.b	'abcdef',0

戻り値	Ｄ０．Ｌ	文字列の長さ

*****************************************************************

__strcpy	equ	$0c
機能番号 $0c

	文字列を転送する
	後方に転送するとき領域を重ねてはいけません

入力	Ａ０．Ｌ	転送先のポインタ
	Ａ１．Ｌ	転送する文字列のポインタ

	lea	to_string,a0
	lea	from_string,a1
	moveq.l	#__strcpy,d7
	jsr	(a3)

to_string:
	ds.b	?
from_string:
	dc.b	'abcdefg1234',0

戻り値	なし



                             - 12 -

__strncpy	equ	$0d
機能番号 $0d

	文字列を指定バイト数転送する
	後方に転送するとき領域を重ねてはいけません

入力	Ｄ０．Ｗ	転送するバイト数
	Ａ０．Ｌ	転送先のポインタ
	Ａ１．Ｌ	転送する文字列のポインタ

	move.w	#5,d0
	lea	to_string,a0
	lea	from_string,a1
	moveq.l	#__strcpy,d7
	jsr	(a3)

to_string:
	ds.b	?
from_string:
	dc.b	'abcdefg1234',0

戻り値	なし

*****************************************************************

__strcat	equ	$0e
機能番号 $0e

	文字列を連結する
	連結される文字列と連結する文字列の領域を重ねてはいけません

入力	Ａ０．Ｌ	連結される文字列のポインタ
	Ａ１．Ｌ	連結する文字列のポインタ

	lea	string,a0
	lea	add_string,a1
	moveq.l	#__strcat,d7
	jsr	(a3)

string:
	dc.b	'TEST',0
add_string:
	dc.b	'.TMP',0

戻り値	なし



















                             - 13 -

__strcmp	equ	$0f
機能番号 $0f

	文字列を比較する

入力	Ａ０．Ｌ	比較される文字列のポインタ
	Ａ１．Ｌ	比較する文字列のポインタ

	lea	string_1,a0
	lea	string_2,a1
	moveq.l	#__strcmp,d7
	jsr	(a3)

string_1:
	dc.b	'TEST1',0
string_2:
	dc.b	'TEST2',0

戻り値	Ｄ０．Ｌ	比較結果
			１，０，−１になる
	フラグ		NとZフラグが上記の状態を持つ

*****************************************************************

__strncmp	equ	$10
機能番号 $10

	文字列を指定バイト数比較する

入力	Ｄ０．Ｗ	比較するバイト数
	Ａ０．Ｌ	比較される文字列のポインタ
	Ａ１．Ｌ	比較する文字列のポインタ

	move.w	#5,d0
	lea	string_1,a0
	lea	string_2,a1
	moveq.l	#__strncmp,d7
	jsr	(a3)

string_1:
	dc.b	'TEST1234',0
string_2:
	dc.b	'TEST1',0

戻り値	Ｄ０．Ｌ	比較結果
			１，０，−１になる
	フラグ		NとZフラグが上記の状態を持つ

*****************************************************************

__tolower	equ	$11
機能番号 $11

	英大文字を英小文字に変換する

入力	Ｄ０．Ｂ	文字コード

	move.b	#'A',d0
	moveq.l	#__tolower,d7
	jsr	(a3)

戻り値	Ｄ０．Ｂ	変換した文字コード


                             - 14 -

__toupper	equ	$12
機能番号 $12

	英小文字を英大文字に変換する

入力	Ｄ０．Ｂ	文字コード

	move.b	#'a',d0
	moveq.l	#__toupper,d7
	jsr	(a3)

戻り値	Ｄ０．Ｂ	変換した文字コード

*****************************************************************

__stolower	equ	$13
機能番号 $13

	英大文字列を英小文字列に変換する

入力	Ａ０．Ｌ	文字列のポインタ

	lea	string,a0
	moveq.l	#__stolower,d7
	jsr	(a3)

string:
	dc.b	'TEST123',0

戻り値	なし
	stringの内容
	dc.b	'test123',0

*****************************************************************

__stoupper	equ	$14
機能番号 $14

	英小文字列を英大文字列に変換する

入力	Ａ０．Ｌ	文字列のポインタ

	lea	string,a0
	moveq.l	#__stoupper,d7
	jsr	(a3)

string:
	dc.b	'test123',0

戻り値	なし
	stringの内容
	dc.b	'TEST123',0












                             - 15 -

__strtokn	equ	$15
機能番号 $15

	文字列を空白文字を区切りとして分解する
	空白文字とはタブもふくめる
	ただし ' または " で囲まれたものは１つの文字列とみなす

入力	Ａ０．Ｌ	分解した文字列を格納するポインタ
	Ａ１．Ｌ	分解する文字列のポインタ

	lea	str_buf,a0
	lea	string,a1
	moveq.l	#__strtokn,d7
	jsr	(a3)

str_buf:
	ds.b	?
string:
	dc.b	'test 1 test 2 "test 3 test 4" test 5',0

戻り値	Ａ０．Ｌ	不定
	Ａ１．Ｌ	不定
	Ｄ０．Ｌ	不定
	str_bufの内容
	dc.b	'test',0
	dc.b	'1',0
	dc.b	'test',0
	dc.b	'2',0
	dc.b	'"test 3 test 4"',0
	dc.b	'test',0
	dc.b	'5',0
	dc.b	0

*****************************************************************

__strsrch	equ	$16
機能番号 $16

	複数の文字列の集まったブロックから指定の位置の文字列を検索する
	複数の文字列の集まったブロックとは、環境変数の内容などと同じ構造のもの

入力	Ａ０．Ｌ	検索開始ポインタ
	Ｄ０．Ｗ	検索位置

	lea	str_block,a0
	move.w	#1,d0
	moveq.l	#__strsrch,d7
	jsr	(a3)

str_block:
	dc.b	'string 1',0
	dc.b	'string 2',0
	dc.b	'str 3',0
	dc.b	'str 4',0
	dc.b	'string 5',0
	dc.b	0

戻り値	Ａ０．Ｌ	検索後の文字列のポインタ
	Ｚフラグ	検索結果
			０（ＮＥ）ならば見つかった
			１（ＥＱ）ならば見つからない
	Ｄ０．Ｌ	不定


                             - 16 -

__strbsrch	equ	$17
機能番号 $17

	複数の文字列の集まったブロックから指定の位置の文字列を逆方向に検索する
	複数の文字列の集まったブロックとは、環境変数の内容などと同じ構造のもの

入力	Ａ０．Ｌ	検索開始ポインタ
	Ａ１．Ｌ	検索データの先頭ポインタ
	Ｄ０．Ｗ	検索位置

	lea	srch_pointer,a0
	lea	str_block_top,a1
	move.w	#1,d0
	moveq.l	#__strbsrch,d7
	jsr	(a3)

str_block_top:
	dc.b	'string 1',0
	dc.b	'string 2',0
srch_pointer:
	dc.b	'str 3',0
	dc.b	'str 4',0
	dc.b	'string 5',0
	dc.b	0

戻り値	Ａ０．Ｌ	検索後の文字列のポインタ
	Ｚフラグ	検索結果
			０（ＮＥ）ならば見つかった
			１（ＥＱ）ならば見つからない
	Ｄ０．Ｌ	不定

*****************************************************************

__strbcpy	equ	$18
機能番号 $18

	複数の文字列の集まったブロックを転送する
	複数の文字列の集まったブロックとは、環境変数の内容などと同じ構造のもの
	後方に転送するとき領域を重ねてはいけません

入力	Ａ０．Ｌ	転送先のポインタ
	Ａ１．Ｌ	転送する文字列ブロックのポインタ

	lea	to_strblock,a0
	lea	from_strblock,a1
	moveq.l	#__strbcpy,d7
	jsr	(a3)

to_strblock:
	ds.b	?
from_strblock:
	dc.b	'string 1',0
	dc.b	'string 2',0
	dc.b	'str 3',0
	dc.b	'str 4',0
	dc.b	'string 5',0
	dc.b	0

戻り値	なし





                             - 17 -

__msg_keywait	equ	$19
機能番号 $19

	指定の文字列を標準出力に出力してからキーを押すまで待つ
	ただし先行入力はなくなり、エコーバックしません

入力	Ａ０．Ｌ	出力するメッセージ

	lea	message,a0
	moveq.l	#__msg_keywait,d7
	jsr	(a3)

message:
	dc.b	'HIT ANY KEY !!',$0d,$0a,$00

戻り値	Ｄ０．Ｂ	押されたキーの文字コード

*****************************************************************

__msg_yes_no	equ	$1a
機能番号 $1a

	指定の文字列を標準出力に出力してからキーを押すまで待つ
	ただし先行入力はなくなり、エコーバックします

入力	Ａ０．Ｌ	出力するメッセージ

	lea	message,a0
	moveq.l	#__msg_yes_no,d7
	jsr	(a3)

message:
	dc.b	'ARE YOU SURE ? (Y/N)',$00

戻り値	Ｄ０．Ｂ	押されたキーの文字コード
	Ｄ１．Ｗ	押されたキーの種類
			０	"n" か "N" が押された
			−１	"y" か "Y" が押された
			１	上記以外が押された

*****************************************************************

__print_path	equ	$1b
機能番号 $1b

	現在のカレントパスを標準出力に出力する

入力	Ｄ０．Ｗ	ドライブ番号
			０	カレントドライブ
			１	ドライブＡ：
			２〜	ドライブＢ：〜

	move.w	#1,d0
	moveq.l	#__print_path,d7
	jsr	(a3)

戻り値	なし
	画面での表示
	A:\bin\
	改行はしない




                             - 18 -

__print_date1	equ	$1c
機能番号 $1c

	日付を標準出力に出力する

入力	Ｄ０．Ｌ	日付バイナリーコード
			0000_0000_0000_0000_YYYY_YYYM_MMMD_DDDD

	move.l	#$1097,d0
	moveq.l	#__print_date1,d7
	jsr	(a3)

戻り値	なし
	画面での表示
	88-04-23
	改行はしない

*****************************************************************

__print_date2	equ	$1d
機能番号 $1d

	日付を標準出力に出力する

入力	Ｄ０．Ｌ	日付バイナリーコード
			0000_0000_0000_0000_YYYY_YYYM_MMMD_DDDD

	move.l	#$1097,d0
	moveq.l	#__print_date2,d7
	jsr	(a3)

戻り値	なし
	画面での表示
	1988-04-23 （土）
	改行はしない

*****************************************************************

__print_time1	equ	$1e
機能番号 $1e

	時刻を標準出力に出力する
	ただし秒は２秒単位

入力	Ｄ０．Ｌ	時刻バイナリーコード
			0000_0000_0000_0000_HHHH_HMMM_MMMS_SSSS

	move.l	#$9e2f,d0
	moveq.l	#__print_time1,d7
	jsr	(a3)

戻り値	なし
	画面での表示
	19:49:30
	改行はしない









                             - 19 -

__print_time2	equ	$1f
機能番号 $1f

	時刻を標準出力に出力する

入力	Ｄ０．Ｌ	時刻バイナリーコード
			0000_0000_000H_HHHH_00MM_MMMM_00SS_SSSS

	move.l	#$13311f,d0
	moveq.l	#__print_time2,d7
	jsr	(a3)

戻り値	なし
	画面での表示
	19:49:31
	改行はしない

*****************************************************************

__print_prompt	equ	$20
機能番号 $20

	コマンドプロンプト文字列を標準出力へ出力する

入力	なし

	moveq.l	#__print_prompt,d7
	jsr	(a3)

戻り値	なし

*****************************************************************

__print_crlf	equ	$21
機能番号 $21

	改行文字を標準出力へ出力する

入力	なし

	moveq.l	#__print_crlf,d7
	jsr	(a3)

戻り値	なし

*****************************************************************

__print_space	equ	$22
機能番号 $22

	空白文字を標準出力へ出力する

入力	なし

	moveq.l	#__print_space,d7
	jsr	(a3)

戻り値	なし






                             - 20 -

__cprint	equ	$23
機能番号 $23

	制御文字を含む文字列を普通の文字列に変換して標準出力に出力する

入力	Ａ０．Ｌ	文字列のポインタ

	lea	string,a0
	moveq.l	#__cprint,d7
	jsr	(a3)

string:
	dc.b	$03,$1b,$09,0

戻り値	なし
	画面での表示
	^C^[^I

*****************************************************************

__cputchar	equ	$24
機能番号 $24

	制御文字を普通の文字に変換して標準出力に出力する

入力	Ｄ０．Ｂ	文字コード

	move.b	#$1b,d0
	moveq.l	#__cputchar,d7
	jsr	(a3)

戻り値	Ｄ０．Ｌ	不定
	画面での表示
	^[

*****************************************************************

__eprint	equ	$25
機能番号 $25

	文字列を標準エラー出力に出力する

入力	Ａ０．Ｌ	文字列のポインタ

	lea	string,a0
	moveq.l	#__eprint,d7
	jsr	(a3)

string:
	dc.b	'DISK READ ERROR !!',$0d,$0a,0

戻り値	なし












                             - 21 -

__name_cut	equ	$26
機能番号 $26

	拡張ファイルネーム（９〜１８バイト）を含むファイルネームから拡張
	ファイルネームを取り除く
	ただし８バイト目に漢字の第一バイトがあり９バイトめに'.'がある
	ファイルネームを作ることがあるので注意する
	ドライブ名パス名の付いたものは指定してはいけません。機能番号 $28
	__srch_nameを呼び出しておくこと

入力	Ａ０．Ｌ	ファイルネームのポインタ

	lea	file_name,a0
	moveq.l	#__name_cut,d7
	jsr	(a3)

file_name:
	dc.b	'abcdefghijkl.mno',0

戻り値	なし
	file_nameの内容
	dc.b	'abcdefgh.mno',0

*****************************************************************

__fullpath	equ	$27
機能番号 $27

	パス名を絶対パス名に変換する

入力	Ａ０．Ｌ	パス名のポインタ

	lea	pathname,a0
	moveq.l	#__fullpath,d7
	jsr	(a3)

pathname:
	dc.b	'a:..\bin\',0

戻り値	なし
	pathnameの内容
	dc.b	'a:\x68k\user1\bin\',0






















                             - 22 -

__srch_name	equ	$28
機能番号 $28

	ドライブ名やパス名を含むファイル名から主ファイル名を捜しその
	ポインタを返す
	ただし、ドライブ名やパス名のみでファイル名の無いものを指定
	した場合はその文字列の終わりの位置を返す
	ファイル名の無いものとは、'A:'や'\BIN\'等の文字列
	文字列の中に漢字があっても良い

入力	Ａ０．Ｌ	ドライブ名やパス名を含むファイル名のポインタ

	lea	path_file,a0
	moveq.l	#__srch_name,d7
	jsr	(a3)

path_file:
	dc.b	'A:\BIN\TEST.TXT',0

戻り値	Ａ０．Ｌ	進んだポインタ
			上記例では'TEST.TXT'の所まで進む

*****************************************************************

__wild_conv	equ	$29
機能番号 $29

	ファイル名のなかのワイルドカード文字'*'をワイルドカード文字'?'の
	並びに変換する
	ただし、ドライブ名やパス名を含んでいたりファイル名の無いものを指定
	してはなりません。機能番号 $28 __srch_nameを呼び出しておくこと

入力	Ａ０．Ｌ	ファイル名のポインタ

	lea	file_name,a0
	moveq.l	#__wild_conv,d7
	jsr	(a3)

file_name:
	dc.b	'OLD*.S',0

戻り値	Ｄ０．Ｌ	変換結果
			０	ワイルドカード文字を変換した
			−１	ファイル名が異常
	file_nameの内容
	dc.b	'OLD???????????????.S',0


















                             - 23 -

__wild_set	equ	$2a
機能番号 $2a

	ワイルドカード文字列と、もとになるファイル名から新しいファイル名を
	作成する
	ワイルドカード文字列は機能番号 $29 __wild_convで作成した文字列です
	もとになるファイル名にドライブ名やパス名を含んでいたりファイル名の
	無いものを指定してはなりません。機能番号 $28 __srch_nameを呼び出して
	おくこと
	これはCOPYコマンドやRENコマンドの新規ファイル名作成と同じである

入力	Ａ０．Ｌ	もとになるファイル名のポインタ
	Ａ１．Ｌ	新しいファイル名のポインタ
	Ａ２．Ｌ	ワイルドカード文字列

	lea	source_name,a0
	lea	destination_name,a1
	lea	wild_name,a2
	moveq.l	#__wild_set,d7
	jsr	(a3)

source_name:
	dc.b	'NEWTEXT.BAK',0
wild_name:
	dc.b	'OLD???????????????.S',0

戻り値	なし
	destination_nameの内容
	dc.b	'OLDTEXT.S',0

*****************************************************************

__wild_make_1	equ	$2b
機能番号 $2b

	ファイル名を解析してワイルドカード文字列'*.*'、'*'を付加したり
	エクステンション記号'.'を付加する
	ディレクトリの状態により解析結果が異なります
	エクステンションの無いものを指定するとエクステンション記号のみ付加する
	これはCOPYコマンドやDELコマンドのファイル名解析と同じである

入力	Ａ０．Ｌ	ファイル名のポインタ

	lea	file_name,a0
	moveq.l	#__wild_make_1,d7
	jsr	(a3)

file_name:
	dc.b	'A:\BIN',0

戻り値	なし
	file_nameの内容
	A:のルートディレクトリにサブディレクトリBINが無い場合
	dc.b	'A:\BIN.',0
	A:のルートディレクトリにサブディレクトリBIN有る場合
	dc.b	'A:\BIN\*.*',0








                             - 24 -

__wild_make_2	equ	$2c
機能番号 $2c

	ファイル名を解析してワイルドカード文字列'*.*'、'*'を付加したり
	エクステンションのワイルドカード'.*'を付加する
	ディレクトリの状態により解析結果が異なります
	エクステンションの無いものを指定するとエクステンションのワイルドカード
	'.*'を付加する
	これはDIRコマンドのファイル名解析と同じである

入力	Ａ０．Ｌ	ファイル名のポインタ

	lea	file_name,a0
	moveq.l	#__wild_make_2,d7
	jsr	(a3)

file_name:
	dc.b	'A:\BIN',0

戻り値	なし
	file_nameの内容
	A:のルートディレクトリにサブディレクトリBINが無い場合
	dc.b	'A:\BIN.*',0
	A:のルートディレクトリにサブディレクトリBINが有る場合
	dc.b	'A:\BIN\*.*',0







































                             - 25 -

__files		equ	$2d
機能番号 $2d

	指定したパス名のファイルのディレクトリ情報のテーブルを作成する
	'.'、'..'や隠しファイル、ボリュームラベルは無視します

入力	Ａ０．Ｌ	パス名のポインタ
	Ａ１．Ｌ	作られるディレクトリ情報のテーブルの先頭のポインタ
			４４８３２バイト必要

	lea	path_name,a0
	lea	dir_table,a1
	moveq.l	#__files,d7
	jsr	(a3)

path_name:
	dc.b	'A:\BIN\*.X',0
dir_table:
	ds.b	1401*32

戻り値	Ｄ０．Ｌ	指定パス中に存在したファイル数
			０〜１４００までになる
			１４０１以上の場合はテーブルには１４００ファイルだけ
			作られている
	dir_tableの内容
	一つのファイルの情報として３２バイトある
	dc.b	'CHKDSK             X  ',$00
		ファイルネーム１８文字＋＄２０＋エクステンション３文字＋＄００
		余っている部分には空白文字が詰められる
	dc.b	$20
		ファイルアトリビュート１バイト
	dc.l	2298
		ファイルの長さ４バイト
	dc.w	$0eaf
		ファイルの日付
		YYYY_YYYM_MMMD_DDDD
	dc.w	$6000
		ファイルの時刻
		HHHH_HMMM_MMMS_SSSS
	上記と同じ構造のものが３２バイトづつ続く
	dc.b	'COPY2              X  ',$00
	dc.b	$20
	dc.l	2632
	dc.w	$0eaf
	dc.w	$6000
	上記と同じ構造のものが３２バイトづつ続く
	dc.b	'CUSTOM             X  ',$00
	dc.b	$20
	dc.l	1744
	dc.w	$0eaf
	dc.w	$6000
	最後は終わりのマークとしてファイル名の先頭が＄００になっている
	dc.b	$00
	ds.b	31










                             - 26 -

__drvno_check	equ	$2e
機能番号 $2e

	指定のドライブが存在しているかどうか調べる

入力	Ｄ０．Ｌ	検査ドライブ番号
			０	ドライブＡ：
			１〜	ドライブＢ：〜

	move.l	#3,d0
	moveq.l	#__drvno_check,d7
	jsr	(a3)

戻り値	Ｄ０．Ｌ	検査結果
			０	存在している
			−１	存在していない

*****************************************************************

__get_scrsize	equ	$2f
機能番号 $2f

	現在の画面の大きさを求める
	横方向は６４か９６、縦方向は３１か３２が返る

入力	なし

	moveq.l	#__get_scrsize,d7
	jsr	(a3)

戻り値	Ｄ０．Ｂ	横サイズ
	Ｄ１．Ｂ	縦サイズ

*****************************************************************

__nextline	equ	$30
機能番号 $30

	メモリに読み込まれたテキストファイルイメージのデータを
	検査して次の行の先頭を検索する
	テキストファイルイメージのデータは＄１Ａか＄００で終わる

入力	Ａ０．Ｌ	検索開始ポインタ

	lea	text_buf,a0
	moveq.l	#__nextline,d7
	jsr	(a3)

text_buf:
	dc.b	'abcdefg',$0d,$0a
	dc.b	'123456',$0d,$0a
	dc.b	'ABCDEFGHIJ',$0d,$0a
	dc.b	$1a
	dc.b	$00

戻り値	Ａ０．Ｌ	次の行の先頭ポインタ
	Ｄ０．Ｂ	検索結果
			＄０Ａ	次の行があった
			＄１Ａ	テキストファイルの終りのマークを見つけた
			＄００	テキストファイルが終り




                             - 27 -

__movmem	equ	$31
機能番号 $31

	メモリを指定バイト数コピーする
	後方にコピーするとき領域を重ねてはいけません

入力	Ｄ０．Ｌ	転送するバイト数
	Ａ０．Ｌ	転送するメモリのポインタ
	Ａ１．Ｌ	転送先のポインタ

	move.w	#1024,d0
	lea	from_memory,a0
	lea	to_memory,a1
	moveq.l	#__movmem,d7
	jsr	(a3)

to_memory:
	ds.b	?
from_memory:
	ds.b	?

戻り値	Ｄ０．Ｌ	不定
	Ａ０．Ｌ	不定
	Ａ１．Ｌ	不定

*****************************************************************

__skip_numchr	equ	$32
機能番号 $32

	文字列のポインタを数字文字以外が現れるまで進める
	__atoi、__atoisを呼び出した後に呼び出し、次へ進める時に使用する
	ただし、符号記号'+'、'-'は数字文字以外とする

入力	Ａ０．Ｌ	文字列のポインタ

	lea	string,a0
	moveq.l	#__skip_numchr,d7
	jsr	(a3)

string:
	dc.b	'1988-04-23',0

戻り値	Ａ０．Ｌ	進んだポインタ
			上記例では'1988'の次の'-'まで進む
	Ｄ１．Ｌ	進んだバイト数
			上記例では４になる

















                             - 28 -

__spcget	equ	$33
機能番号 $33

	文字列の先頭の空白文字の数を求める
	空白文字とはタブもふくめる

入力	Ａ０．Ｌ	文字列のポインタ

	lea	string,a0
	moveq.l	#__spcget,d7
	jsr	(a3)

string:
	dc.b	'   TEST1',0

戻り値	Ｄ０．Ｌ	空白文字のバイト数

*****************************************************************

__execute	equ	$34
機能番号 $34

	指定のプロセスを起動する
	プロセスの起動はこれを使用し、直接ＯＳのファンクションコールを使用して
	起動する事は出来ません
	起動後もしメモリ管理がおかしくなるとＣＯＭＭＡＮＤ．Ｘが異常終了して
	呼び出しプログラムに帰らないことがあります。この場合に事後処理が
	必要ならば異常終了直前にユーザープログラムのｅｘｉｔ＿ｐｒｏｇを
	呼び出しますので、そのなかで処理して下さい。
	また、この時に異常終了するＣＯＭＭＡＮＤ．Ｘが常駐部を組み込んだもの
	であればｋｉｌｌ＿ｐｒｏｇも呼び出されます

入力	Ａ０．Ｌ	コマンドパラメータのポインタ
	Ａ１．Ｌ	コマンドファイルのポインタ

	lea	argument,a0
	lea	command,a1
	moveq.l	#__execute,d7
	jsr	(a3)

argument:
	dc.b	12,'/c dir a:*.*',0
command:
	dc.b	'A:\command.x',0

戻り値	Ｄ０．Ｌ	終了ステータス
			＄００００００００〜＄００００ｆｆｆｆの時
				プロセス終了コード
			＄ｆｆｆｆｆｆ？？の時
				ＯＳエラ−コード（起動出来ないなど）














                             - 29 -
