##########################################################################

                              DOCUMENTATION

                                   OF




                                ＦＩＳＨ

                               version 0.8




                                   BY

                             Itagaki Fumihiko


                              o ∞§__§§∞
                            ∞ §§     |§§
                          ∞§ §| 〇^〇 |§§
                         §§ § ;   ゝ  ;§ §
                        § § §  ;.""".;  § §
                           § §   ;;;;;   § §
                          § §            §

##########################################################################
■
■
■  目 次
■
■
■
■
■
■
■
■
■


■ 表紙  1

■ 目次  31

■ このドキュメントの読み方  118

■ fish の外観  181
　　fish が動作する環境  195
　　　　OS  200／端末  249
　　fish の起動  263
　　　　通常の起動方法／特殊な起動方法
　　fish の終了  467
　　　　EOF による終了　472／コマンドによる終了　491／
　　　　エラーによる終了　505／ログイン・シェルの終了（ログアウト）　513／
　　　　終了時の処理　521／終了時の状態　544

■ fish の動作  571
　　1  行の入力  616
　　2  履歴置換  670
　　3  単語分け  989
　　4  履歴登録  1010
　　5  別名展開  1026
　　6  コマンドの構文  1074
　　　　通常のコマンド行  1090／※パイプ  1162／※サブシェル  1173／特別な
　　　　構文  1182
　　7  単一コマンドごとの処理  1346
　　　　7.1  入出力の切り替え  1356
　　　　7.2  コマンド名の解析  1473
　　　　7.3  引数に対する置換  1484
　　　　7.4  単一コマンドの検索  1499
　　　　　　※ハッシュ機構  1558
　　　　7.5  単一コマンドの実行  1583
　　　　　　関数の実行  1586／fish組み込みコマンドの実行  1601／ディスク上
　　　　　　のコマンドの実行  1622／HUPAIR  1705／コマンドラインの壁  1722

■ 単語毎の置換  1771
　　変数置換  1785
　　コマンド置換  2012
　　組み合わせ展開  2040
　　ディレクトリ置換  2063
　　ファイル（ディレクトリ・エントリ）名展開  2099

■ 参照マニュアル  2161
　　エスケープとクオート  2175
　　パターン・マッチング  2193
　　式  2223
　　組み込みコマンド  2676
　　行入力編集機構  4056
　　特別な関数  4661
　　特別なシェル変数  4693
　　特別な環境変数  5263
　　関連ファイル  5395






















■
■
■  こ の ド キ ュ メ ン ト の 読 み 方
■
■
■
■
■
■
■
■
■


　このドキュメントでは，いくつかの特別な用語を用いています．予め説明が必要
と思われるものについて簡単に説明します．


    $%var               環境変数 var の値

    $@var               シェル変数 var の値

    $@var[n]            シェル変数 var の n番目の要素の値

　　~/file              ユーザのホーム・ディレクトリ（すなわちシェル変数
                        home の値）下のファイル file

　　[.%]file            アクセス可能であれば，ファイル .file．さもなくばファ
　　　　　　　　　　　　イル %file．

　　スクリプト　　　　　シェルに与えるコマンドを記述したテキスト・ファイル

　　sourceする          スクリプトを現在のシェル上で実行する

　　作業ディレクトリ    カレント・ドライブのカレント・ディレクトリ

　　完全パス(名)        作業ディレクトリの位置によらずに必ず 1つのファイル
                        やディレクトリを指し示すパス(名)．‘A:/’や‘B:\’
                        のようにドライブ名と / か \ で始まるパスが完全パス
                        です．シェル変数 refersysroot がセットされていれば，
                        （ドライブ名なしで） / で始まるパスも完全パスとして
                        認められます．

　　相対パス(名)        完全パスでないパス(名)．相対パスによって指し示され
                        るファイルやディレクトリは作業ディレクトリの位置に
                        依存します．

　　端末　　　　　　　　Human68k には端末という概念がないので，キャラクタ・
　　　　　　　　　　　　デバイスならば端末と見なしています．














■
■
■  f i s h の 外 観
■
■
■
■
■
■
■
■
■


■
■  fish が動作する環境
■


■ OS


　fish は，version 2.00 以降の Human68k 上で動作します．これよりも古い版の
Human68k 上では動作しません．

オプションのデバイス・ドライバや常駐プログラム等は一切必要ありません．
CONFIG.SYS が空っぽで，HUMAN.SYS の他には何も常駐していない状態でも fish は
動作します．

Human68k の拡張仕様に対しては次のように対応しています．


　　●HUPAIR         （ 板垣 史彦 ）

　　　　完全に対応しています．また，fish 自身も HUPAIR に準拠しています．


　　●TwentyOne      （ Ｅｘｔ ）

　　　　完全に対応しています．ただしファイル名の大文字と小文字を区別するか
　　　　どうかについては，TwentyOne によらず fish 自身が決定する場面がいく
　　　　つかありますので注意してください．

　　　　シェル変数 refersysroot によって，TwentyOne の Rスイッチへの対応と
　　　　補強を行うことができます．


　　●lndrv          （ 沖   勝 ）

　　　　完全に対応しています．システムに lndrv が組み込まれていれば，その機
　　　　能を fish 内でも利用することができます．また，fish はファイル属性の
　　　　第6ビットを，lndrv が定義しているとおりにシンボリック・リンク・ビッ
　　　　トとして扱います．


　　●execd          （ 沖   勝 ）

　　　　fish は execd とほぼ同等の機能を持っており，多くの場合，システムに
　　　　execd が組み込まれていなくても execd とほぼ同等の機能が fish 内部で
　　　　働きますが，fish は極力システムに起動を任せますので，fish になく
　　　　execd にある機能を利用することもできます．ファイル属性の第7ビットに
　　　　ついては，fish は execd が定義しているとおりに実行可能ビットとして
　　　　扱います．


これらの他の拡張仕様に対しては，特に意識した対応は，なされていません．


■ 端末


　現在のところ fish は X68000 Human68k の標準の CON の仕様に依存しており，
これ以外の端末では表示がおかしくなることがあります．

　fish はシフトJIS文字コード（X68000 独自の拡張を含む）に対応しています．

fish が出力するほとんどのメッセージにもシフトJIS文字コードが使用されていま
す．ASCII端末から fish を使用することはもちろん可能ですが，fish から出力さ
れるエラー・メッセージを読むことはできないでしょう．



■
■  fish の起動
■


■　通常の起動方法


　fish の起動方法は次のとおりです．


　fish [ -bcdefhiknstvVxX ] [ 引数 ...  ]
　fish -l


fish に与えられたコマンドラインは HUPAIR にしたがって解釈されます．

fish に HUPAIR の引数0（名前引数）が与えられていて，その最初の文字が‘-’で
あるか，または引数として -lオプションのみが与えられている場合（上記の 2番目
の形式），fish はログイン・シェルとして，起動時と終了時に特別な動作をします．

起動オプションは以下のとおりです. これらのオプションは，たとえば -fk のよう
に 1つの引数内に連結して指定することもできますし，-f -k のように分けて指定
することもできます．


　-b      オプション引数解釈を中断し，これ以降の引数を非オプション引数とし
　　　　　ます．スクリプトのファイル名を -i や -s などという名前に変更して
　　　　　実行された場合の事故を防ぐために用いられます．

　-c      後に続く 1つの引数をコマンド行として実行して終了します．終了時の
　　　　　特別な処理は行いません. 

　-d      起動時にファイル ~/[.%]fishdirs をsourceします．ログイン・シェル
　　　　　ならば，このオプションを指定しなくてもsourceします．ただしいずれ
　　　　　の場合にも -fオプションが同時に指定されているときには
　　　　　~/[.%]fishdirs はsourceされません．

　-e      コマンドが異常終了したときや 0 以外の終了ステータスを返したときに
　　　　　シェルを即座に（何もせずに）終了します．

　-f      起動時にファイル ~/[.%]fishrc をsourceせず，また，ハッシュ機構を
　　　　　オンにしません．終了時の特別な処理は行いません.

　-h      起動時にファイル ~/[.%]history を決して読み込みません．

　-i      fish をインタラクティブ・モードとして，標準入力からコマンドを読み
　　　　　取ります．このオプションは -sオプションを覆います．

　　　　　　　　　　　　オプション以外の引数がなければ，このオプションを指
　　　　　　　　　　　　定しなくても fish は標準入力からコマンドを読み取り
　　　　　　　　　　　　ます．そのとき標準入力が端末であれば，このオプショ
　　　　　　　　　　　　ンを指定しなくても fish は自動的にインタラクティブ・
　　　　　　　　　　　　モードとなります．

　-k      終了時に作業ディレクトリを元に戻しません．

　-n      コマンド行を解析しますが実行はしません．スクリプトの構文をチェッ
　　　　　クするために使用します．

　-s      標準入力からコマンドを読み取ります．

　　　　　　　　　　　　オプション以外の引数がなければ，このオプションを指
　　　　　　　　　　　　定しなくても fish は標準入力からコマンドを読み取り
　　　　　　　　　　　　ます．

　-t      標準入力からコマンド行を 1行だけ読み取って実行して終了します．終
　　　　　了時の特別な処理は行いません.

　-v      シェル変数 verbose をセットします．

　-x      シェル変数 echo をセットします．

　-V      ファイル $%SYSROOT/etc/fishrc をsourceする前にシェル変数 verbose
　　　　　をセットします．

　-X      ファイル $%SYSROOT/etc/fishrc をsourceする前にシェル変数 echo を
　　　　　セットします．


これら以外のオプションは，指定しても無視されます．

-i，-s，-t，-cオプションのいずれも指定されず，さらに，オプションでない引数
が残っていれば，fish はその最初の引数が示すスクリプト・ファイル全体をメモリ
にロードして，それを解釈・実行します．

-cオプションが指定されず，スクリプト引数も指定されていなければ，fish は標準
入力からコマンド行を 1行ずつ読みとって解釈・実行します．このとき標準入力が
端末であれば fish は自動的にインタラクティブ・モードとなります．

いずれの場合にも，残った引数はすべてシェル変数 argv にセットされます．

　fish は起動後，argv の他に以下のシェル変数を初期設定します．

　　　　FISH_AUTHOR     FISH_COPYRIGHT  FISH_VERSION    batshell
　　　　cwd             gid             home            loginsh
　　　　path            prompt          prompt2         refersysroot
　　　　shell           shlvl           temp            term
　　　　uid             user            wordchars

環境変数 PWD と SHLVL もこのとき設定されます．

　変数を初期設定した後，fish は次のスクリプト・ファイルを次の条件で順次（も
しあれば）source（現在のシェル上で実行）します．

　　　　　　　　┏━━━━━━━┓
　　　　　　　　┃     始め     ┃
　　　　　　　　┗━━━┯━━━┛
　　　　　　　　　　　　↓
              $%SYSROOT/etc/fishenv
　　　　　　　　　　　　↓
　　┏━━━━━━━━━━━━━━━━━━━┓
　　┃     -fオプションが指定されている     ┠──────────────┐
　　┗━━━━━━━━━┯━━━━━━━━━┛YES                         │
                      NO│　　　　　　　　　　　　　　　　　　　　　　　　│
　　　　　　　　　　　　↓　　　　　　　　　　　　　　　　　　　　　　　　│
                  ~/[.%]fishenv                                           │
　　　　　　　　　　　　↓　　　　　　　　　　　　　　　　　　　　　　　　│
　　┏━━━━━━━━━━━━━━━━━━━┓                            │
　　┃    インタラクティブ・モードである    ┠─────────────→│
　　┗━━━━━━━━━┯━━━━━━━━━┛NO                          │
                     YES│　　　　　　　　　　　　　　　　　　　　　　　　│
　　　　　　　　　　　　↓　　　　　　　　　　　　　　　　　　　　　　　　│
　　┏━━━━━━━━━━━━━━━━━━━┓                            │
　　┃        ログイン・シェルである        ┠──┐　　　　　　　　　　　│
　　┗━━━━━━━━━┯━━━━━━━━━┛NO  │　　　　　　　　　　　│
                     YES│　　　　　　　　　　　　│　　　　　　　　　　　│
　　　　　　　　　　　　↓              　        │　　　　　　　　　　　│
              $%SYSROOT/etc/fprofile      　      │　　　　　　　　　　　│
　　　　　　　　　　　　↓                  　    │　　　　　　　　　　　│
                  ~/[.%]fprofile       　         │　　　　　　　　　　　│
　　　　　　　　　　　　│               　       │　　　　　　　　　　　│
　　　　　　　　　　　　│←───────────┘　　　　　　　　　　　│
　　　　　　　　　　　　↓　　　　　　　　　　　　　　　　　　　　　　　　│
               $%SYSROOT/etc/fishrc                           　          │
　　　　　　　　　　　　↓　　　　　　　　　　　　　　　　　　　　　　　　│
                   ~/[.%]fishrc                           　              │
　　　　　　　　　　　　↓　　　　　　　　　　　　　　　　　　　　　　　　│
　　┏━━━━━━━━━━━━━━━━━━━┓                            │
　　┃        ログイン・シェルである        ┠──┐　　　　　　　　　　　│
　　┗━━━━━━━━━┯━━━━━━━━━┛NO  │　　　　　　　　　　　│
                     YES│　　　　　　　　　　　　│　　　　　　　　　　　│
　　　　　　　　　　　　↓　　　　　　　　　　　　│　　　　　　　　　　　│
               $%SYSROOT/etc/flogin         　    │　　　　　　　　　　　│
　　　　　　　　　　　　↓　　　　　　　　　　　　│　　　　　　　　　　　│
                   ~/[.%]login          　        │　　　　　　　　　　　│
　　　　　　　　　　　　│　　　　　　　　　　　　↓　　　　　　　　　　　│
　　　　　　　　　　　　│　　　┏━━━━━━━━━━━━━━━━━━━┓│
　　　　　　　　　　　　│←──┨     -dオプションが指定されている     ┃│
　　　　　　　　　　　　│   YES┗━━━━━━━━┯━━━━━━━━━━┛│
　　　　　　　　　　　　↓                      NO│　　　　　　　　　　　│
                  ~/[.%]fishdirs  　              │　　　　　　　　　　　│
　　　　　　　　　　　　│　　　　　　　　　　　　│　　　　　　　　　　　│
　　　　　　　　　　　　│←───────────┘　　　　　　　　　　　│
　　　　　　　　　　　　↓　　　　　　　　　　　　　　　　　　　　　　　　│
　　┏━━━━━━━━━━━━━━━━━━━┓　　　　　　　　　　　　　　│
　　┃     -hオプションが指定されている     ┠──┐　　　　　　　　　　　│
　　┗━━━━━━━━━┯━━━━━━━━━┛YES │　　　　　　　　　　　│
                      NO│　　　　　　　　　　　　│　　　　　　　　　　　│
　　　　　　　　　　　　↓　　　　　　　　　　　　│　　　　　　　　　　　│
　　┏━━━━━━━━━━━━━━━━━━━┓　　│　　　　　　　　　　　│
　　┃シェル変数 history がセットされている ┠─→│　　　　　　　　　　　│
　　┗━━━━━━━━━┯━━━━━━━━━┛NO  │　　　　　　　　　　　│
                     YES│　　　　　　　　　　　　│　　　　　　　　　　　│
　　　　　　　　　　　　│　　　　　　　　　　　　│　　　　　　　　　　　│
                  ~/[.%]history  　               │　　　　　　　　　　　│
　　　　　　　　　　　　│　　　　　　　　　　　　↓　　　　　　　　　　　│
　　　　　　　　　　　　│←───────────────────────┘
　　　　　　　　　　　　↓
　　　　　　　　┏━━━━━━━┓
　　　　　　　　┃    終わり    ┃
　　　　　　　　┗━━━━━━━┛

　~/[.%]history 内の各行は実行されずに履歴リストに登録されます．

　最後に，ここまでの間にハッシュ機構がオンになっておらず，かつ，-f，-n，-t，
-cオプションのいずれも指定されていなければ，自動的にハッシュ表を更新し，ハッ
シュ機構をオンにします．

　以上の初期動作を終えた後，fish はユーザからの入力コマンド行の処理に移行し
ます．


■ 特殊な起動方法


　起動した fish のファイル名の先頭 3文字が‘COM’であると（大文字と小文字は
区別しません），その fish は与えられたコマンドラインを HUPAIRデコードせずに
生のまま解析し，コマンドライン全体を COMMAND.X と同じように解釈します．
COMMAND.X のすべてのオプションを指定することができますが，有効なのは /Cオプ
ションまたは /cオプションのみで，それ以外は無視されます．コマンドライン中，
次の文字列がコマンド行として認識されます．


　　●コマンドラインの先頭の文字が / 以外であれば，それ以降

　　●空白文字に続いて / 以外の文字があれば，それ以降

　　●/C か /c があれば，その直後の空白以外の文字からそれ以降


fish起動オプションは環境変数 COMFISHOPT から得ます．fish起動オプションのう
ち defhknvVxX の任意の組み合わせが指定可能です．

コマンドラインとオプションを解釈した後の初期動作は本来の fish と同じです．
初期動作後は，もしコマンド行があればそれを実行して終了します．コマンド行が
なければ，標準入力からコマンド行を 1行ずつ読みとって解釈・実行します．この
とき標準入力が端末であれば，本来の fish 同様，自動的にインタラクティブ・モー
ドとなります．いずれの場合も，コマンド行を解釈して実行する動作は本来の fish
と同じです．

　この機構は，起動シェルとして COMMAND.X（SHARP/Hudson）を前提としているア
プリケーションに fish を起動させるために用意されています．

fish.x を COMMAND.X という名前のファイルにシンボリック・リンク（またはコピー
）しておけば，起動するシェルが COMMAND.X に決め打ちになっているアプリケーショ
ン（MUTERM（はちくん）など）から fish を起動することができるようになります．

ただし，本物の（SHARP/Hudson の）COMMAND.X を使うこともあるのならば，偽の
COMMAND.X は本物の COMMAND.X とは別のディレクトリに作成しておいて，場合によっ
て起動パスを振り分ける工夫が必要です．

fish.x を COMMAND.X ではなくたとえば COMFISH.X という名前のファイルにリンク
しておき，バイナリ・ファイルの内容を書き換えることができるツール（Ｅｘｔ氏
の dedit など）を使って MUTERM.X などの内部の "COMMAND" の部分を "COMFISH"
に書き換える方法もあります．

MicroEMACS（lika/SALT/PEACE/SHUNA/rima）や ED.R（S.Ueda）などは，起動するシェ
ルを指定することができるようになっているものの，シェルに渡すコマンドライン
はHUPAIRエンコードされず，しかも基本的に COMMAND.X の形式で作成されるため，
起動するシェルとして直接的に fish を指定してもうまくいきません．このような
アプリケーションにも，fish.x を COMMAND.X あるいは COMFISH.X などといった名
前にリンクしたファイルをシェルと起動シェルとして指定すればうまくいきます．



■
■  fish の終了
■


■ EOF による終了


　fish は入力が EOF に至ると終了します．

　スクリプト実行中は，実行位置がスクリプトの終わりにたどり着いて，実行すべ
き行が無くなったときに終了することになります．

　fish の入力が端末である場合にも，端末から EOF が送られると fish は終了し
ます．ただし，シェル変数 ignoreeof をセットしておくと，端末からの EOF は無
視されます．

Human68k ではキャラクタ・デバイスに EOF がありませんので端末から直接 EOF を
入力することはできませんが，シェル変数 usegets をセットしていないならば，
fish の行入力編集機構の機能 eof がその代わりとなります（シェル変数 usegets
をセットしているときには端末から EOF を入力することはできません）．機能 eof
をバインドしたキーが押されると，fish はそれを擬似的に EOF と見なします．


■ コマンドによる終了


　組み込みコマンド return を実行すると，シェルの入力は強制的に EOF となりま
す．関数や組み込みコマンド source を実行しているときならば，その実行を終了
することになります．そうでなくシェルの本来の入力を読み取って実行していると
きならば，そのシェルそのものが終了することになります．

　シェル本体を即座に無条件に終了するには，組み込みコマンド exit を使用しま
す．これを実行すると，関数や組み込みコマンド source を実行しているときにも
シェル本体が無条件に終了します．ただしサブシェルの中での exit はサブシェル
を終了させますが現在のシェルは終了しません．


■ エラーによる終了


　fish 起動時に -eオプションを指定すると，コマンドが異常終了したときや 0 以
外の終了ステータスを返したときに fish は即座に終了します．この場合には，後
述の特別な処理は一切行われません．


■ ログイン・シェルの終了（ログアウト）


　ログイン・シェルとしての fish は，組み込みコマンド logout によって即座に
終了（すなわちログアウト）します．ログイン・シェルに EOF を入力したり組み込
みコマンド exit や return を実行したときには logout が自動的に実行されます．


■ 終了時の処理


　起動時に -f，-t，-cオプションのいずれも指定されていなければ，fish は終了
時に以下の処理を順に行います．


　　●ログイン・シェルとしての fish は，スクリプト・ファイル
　　　$SYSROOT/etc/flogout を（もしあれば）sourceします．次に ~/.logout を
　　　（もしあれば）sourceします．~/.logout を読み取ることができなければ代
　　　わりに ~/%logout を試します．

　　●シェル変数 savedirs がセットされていれば，現在のディレクトリ・スタッ
　　　クの状態と直前の作業ディレクトリの状態を再現するコマンドをファイル
　　　~/.fishdirs に書き込みます．~/.fishdirs が存在せず，~/.fishdirs を新
　　　規に作成することができなければ，代わりに ~/%fishdirs に書き込みます．

　　●シェル変数 savehist がセットされていれば，その値の行数分の履歴リスト
　　　の最新のイベントをファイル ~/.history に書き込みます．~/.history が存
　　　在せず，~/.history を新規に作成することができなければ，代わりに
　　　~/%history に書き込みます．


■ 終了時の状態


　fish の終了ステータスは，本当に終了する時点でのシェル変数 status の値の下
位16ビットです．

　fish は起動時の作業ディレクトリを憶えており，通常は，終了時にはそのディレ
クトリに戻って終了します．ただし fish 起動時に -kオプションを与えられていれ
ば，fish は終了時に作業ディレクトリを元に戻しません．


















■
■
■  f i s h の 動 作
■
■
■
■
■
■
■
■
■


　fish は基本的には次の順序で処理を行います．


　1   1行入力する

　2   履歴置換する

　3   行を単語に分解する

　4   単語の並びを履歴リストに追加する

　5   別名を展開する

　6   コマンドの構文を解析する

　7   （行が通常のコマンド行ならば）各単一コマンドごとに次の順序で処理を行
　　　う

　　　1   入出力の切り替えを解析する

　　　2   コマンド名を解析する

　　　3   引数を置換・展開する

　　　4   コマンドを実行する


以下では，この順序にしたがって解説します．



■
■  1  行の入力
■


　fish は，-cオプションが指定された場合などの特殊なケースを除き，スクリプト・
ファイルが指定されたときにはメモリにロードしたスクリプトから，さもなくば標
準入力からコマンド行を読み取ります．

標準入力からコマンド行を読み取るとき，インタラクティブ・モードではシェル変
数 prompt に設定されたプロンプトが出力されます（ただし -tオプションが指定さ
れた場合には，インタラクティブ・モードであってもプロンプトは出力されません）．

標準入力から行を読み取るとき，標準入力が端末であれば，通常は fish 独自の行
入力編集機構が働き，行を対話的に編集することができますが，シェル変数
usegets がセットされているときには，fish の行入力編集機構によらず DOS ファ
ンクション gets を用いて行を読み取ります．HISTORY.X 等の機能を利用したいな
どの場合にはシェル変数 usegets をセットしてください．なお，このときの入力方
法はコンソール・ドライバの仕様によります．

　　　　　　　　　　　　DOS ファンクション gets は最後の改行文字を削除して
　　　　　　　　　　　　返すので，fish は gets で行を読み取った後，改めて行
                        末に改行コード(0x0a)を加えます．

　いずれの場合にも改行コード(0x0a)までのデータが 1物理行となります．改行コー
ドの直前の復帰コード(0x0d)は破棄されます．fish が改行コードを読み取る前に入
力が EOF に到達した場合，fish はそれまでに読み取ったデータを行として入力せ
ずに破棄します．

　fish がインタラクティブ・モードでなければ，物理行中の文字‘#’からその物
理行の終わりまではコメントであると見なされ削除されます．ただし，次の‘#’は
コメントの開始を示すものとは見なされずに通常の文字として保存されます．


　　●引用符（‘'’，‘"’，‘`’）によりクオートされているか，あるいは
　　　‘\’でエスケープされている‘#’

　　●エスケープもクオートもされていない‘!’，‘!{’，‘$’，‘${’，
　　　‘$@’，‘$@{’，‘$%’，‘$%{’の直後の‘#’


　コメント削除後の物理行の末尾が引用符による囲みの中にある（すなわち引用符
による囲みが閉じていない）場合には，fish は論理行を行を次の物理行に継続しま
す．このとき，行末の改行文字は復帰改行コード(0x0d,0x0a)に置き換えて保存され
ます．

　コメント削除後の物理行の最後の文字（改行文字の直前の文字）がエスケープも
クオートもされていない文字‘\’である場合には，fish はその‘\’とそれに続く
改行文字を削除した上で，論理的な行を次の物理行に継続します．

　論理行の長さは 4096バイトに制限されています．



■
■  2  履歴置換
■


　fish は標準入力からの入力行を履歴リストに保存します（『4 履歴登録』参照）．
履歴置換は，履歴リストに保存されているイベントの一部または全体を現在の行に
挿入する機構です．履歴置換が行われたときには，置換後の行が端末にエコーされ
ます．

　履歴置換を導く文字はシェル変数 histchars で設定することができます．シェル
変数 histchars がセットされていない場合のデフォルトは‘!’と‘^’です．ここ
ではデフォルトの設定で表記して解説します．

　以下の‘!’で始まる履歴置換は，行の任意の場所に置くことができます．


　!N
　!{N}

　　　N番のイベント．


　!-N
　!{-N}

　　　N個前のイベント．


　!str
　!{str}

　　　str で始まる最新のイベント．


　!?str?
　!{?str?}

　　　str を含む最新のイベント．str を省略すると，最近の !?str? 置換におけ
　　　る str または最近の :s/str1/str2/flag/ 修飾（後で解説します）における
　　　str1 のいずれか最近のものが使用されます．str は先頭の 31バイトまでが
　　　有効です．字句解析上の不都合がなければ，str の後ろの‘?’は省略するこ
　　　とができます．


　!!
　!{!}

　　　直前のイベント．


　!#
　!{#}

　　現在の行の先頭からこの置換（!#）の直前までの部分を履歴置換した結果．


■ 履歴置換文字のエスケープ


　履歴置換は行の分解・解釈よりも前に行われますので，履歴置換文字を引用符で
クオートすることはできません．履歴置換文字をエスケープするには‘\’を使用し
てください．履歴置換文字をエスケープしている‘\’は，履歴置換後，履歴リスト
に登録する前に削除されます．

　履歴置換文字の直後の文字が空白文字（スペースおよび水平タブ），‘=’，
‘~’，‘(’，‘\’のいずれかである場合には，その履歴置換文字は履歴置換とは
見なされず，通常の文字として保存されます．ですから，履歴置換文字が‘!’であ
るとき，演算子‘!’，‘!=’，‘!~’ や，‘>! file’，‘>>! file’などを記述
する際に‘!’をエスケープする必要はありません．


■ { } による分離


　{ } は履歴置換をそのあとに続く文字と分離する役目を持ちます．例を示します．


　　　　　% echo foo
　　　　　% !ecd
　　　　　ecd: イベントが見当たりません
　　　　　% !{ec}d
　　　　　food


■ 単語選択子


　履歴イベントには単語分けがなされています．上記の !置換の直後に次の単語選
択子を 1個だけ付加することによって，履歴イベントから一部の単語のみを取り出
すことができます．


　　:n    n番目の単語
　　:n-m  n番目から m番目までの単語
　　:-n   0番目（最初の単語）から n番目までの単語
　　:n-   n番目から最後の 1つ前までの単語
　　:n*   n番目から最後までの単語
　　:*    1番目から最後までの単語


ここで，n および m は，


　　n     n番目の単語
　　^     1番目の単語
　　$     最後の単語
　　%     ?str? による検索にマッチした単語


　!置換に { } による囲みを使用している場合，単語選択子は { } の中になければ
なりません．


■ 修飾子


　上記の !置換の直後に，さらに次の形の修飾子を付加することができます．


　　:[<フラグ>]<修飾操作記号>


　ここで <フラグ> は文字‘a’または‘g’の並びです．それぞれのフラグには，
（修飾操作ごとに若干の差異がありますが）基本的には次の意味があります．


　　a   修飾操作を繰り返し適用します．

　　g   すべての単語を修飾します．


　<修飾操作記号> には次のものがあります．


　　h

　　　　head．ディレクトリ名を含む最初の単語からファイル名が取り除かれ，ド
　　　　ライブ名（もしあれば）とディレクトリ名のみになります．ディレクトリ
　　　　名の最後の / は残りません．たとえば foo/bar/baz は foo/bar に，
　　　　D:/foo/bar は D:/foo になります．aフラグを使用すると，たとえば
　　　　foo/bar/baz は foo に，D:/foo/bar は D: に，/foo/bar は空になります．
　　　　gフラグを使用すると，ディレクトリ名を含むすべての単語に同じ処理が適
        用されます．foo や D:foo のようにディレクトリ名を含まない単語はその
        まま保存されます．


　　t

　　　　tail．最初の単語からドライブ名とディレクトリ名が取り除かれ，ファイ
　　　　ル名のみになります．たとえば foo/bar/baz は baz になり，D:/foo，
　　　　/foo，D:foo，foo はいずれも foo になります．aフラグは何の効果もあり
　　　　ません．gフラグを使用すると，すべての単語に同じ処理が適用されます．


　　r

　　　　root．最初の単語のファイル名部分から拡張子が（もしあれば）取り除か
　　　　れます．たとえば foo.bar.baz は foo.bar になります．aフラグを使用す
　　　　ると，foo.bar.baz，foo.bar，foo はいずれも foo になります．gフラグ
　　　　を使用すると，すべての単語に同じ処理が適用されます．


　　e

　　　　extention．最初の単語のファイル名部分から拡張子以外の部分が取り除か
　　　　れて，ファイル名部分の拡張子のみになります．拡張子の先頭の . は残り
　　　　ません．たとえば foo.bar.baz は baz になり，foo. や foo は空になり
　　　　ます．aフラグは何の効果もありません．gフラグを使用すると，すべての
　　　　単語に同じ処理が適用されます．


　　d

　　　　drive．最初の単語からドライブ名以外の部分が取り除かれ，ドライブ名の
　　　　みになります．ドライブ名に続く‘:’は残りません．たとえば D:/foo は
　　　　D になり，/foo は空になります．aフラグは何の効果もありません．gフラ
　　　　グを使用すると，すべての単語に同じ処理が適用されます．


　　f

　　　　file．最初の単語からドライブ名が（もしあれば）取り除かれます．たと
　　　　えば D:/foo，/foo はいずれも /foo になります．aフラグは何の効果もあ
　　　　りません．gフラグを使用すると，すべての単語に同じ処理が適用されます．


　　/

　　　　/ の追加．最初の単語が空でなく，末尾の文字が : / \ のいずれかでなけ
　　　　れば，末尾に / が追加されます．たとえば foo，/foo，D:foo，D:/foo に
　　　　は / が追加されてそれぞれ foo/，/foo/，D:foo/，D:/foo/ になります．
　　　　D:，D:/，D:foo/，foo/ などはそのまま保存されます．aフラグは何の効果
　　　　もありません．gフラグを使用すると，すべての単語に同じ処理が適用され
　　　　ます．


　　l

　　　　lower．最初の単語中，最初の ASCII英大文字が ASCII英小文字に変換され
        ます．aフラグを使用すると，単語中のすべての ASCII英大文字が小文字に
        変換されます．gフラグを使用すると，すべての単語に同じ処理が適用され
        ます．


　　u

　　　　upper．最初の単語中，最初の ASCII英小文字が ASCII英大文字に変換され
        ます．aフラグを使用すると，単語中のすべての ASCII英小文字が ASCII英
        大文字に変換されます．gフラグを使用すると，すべての単語に同じ処理が
        適用されます．


　　s/str1/str2/sflag/

　　　　substitution．str1 を含む最初の単語の最初の str1 が str2 に置き換え
　　　　られます．aフラグを使用すると，その単語中のすべての str1 が str2 に
　　　　置き換えられます．gフラグを使用すると，すべての単語に同じ処理が適用
        されます．ただし aフラグと gフラグは sflag が空のときにのみ有効です．
        sflag には次のものがあります．


　　　　　g           aフラグと gフラグの両方を指定した場合と同じ結果になり
　　　　　　　　　　　ます．

　　　　　数値 <n> 　 単語の並びの中で <n>番目に現われる str1 のみを置換し
　　　　　　　　　　　ます．<n> は単語の番号ではないことに注意してください．


　　　　修飾操作記号 s の直後の文字が区切り文字として採用されます．これは
　　　　‘/’に限らず，シフトJIS文字を含めた任意の文字を使用することができ
　　　　ます．ただし空白文字（スペースおよび水平タブ）と‘}’は使用できませ
　　　　ん．

　　　　str1 および str2 の中に区切り文字が含まれる場合，その文字は \ でエ
　　　　スケープしなければなりません．文字‘\’が含まれる場合，それは‘\\’
　　　　と記述しなければなりません．区切文字が‘\’であるときには，str1 お
　　　　よび str2 の中に文字‘\’を記述することはできません．

　　　　str1 が空である場合は，最近の s修飾における str1 または最近の
　　　　!?str? 置換における str のいずれか最近のものが使用されます．

　　　　str1 が‘^’である場合，それは各単語の先頭を意味します．str1 が‘$’
　　　　である場合，それは各単語の末尾を意味します．たとえば，:s/^/B:/g/ は
　　　　各単語の頭にプリフィックス‘B:’を付加し，:s/$/.c/g/ は各単語の末尾
　　　　にサフィックス‘.c’を付加します．通常の文字列‘^’ あるいは‘$’を
　　　　置換するには str1 は‘\^’あるいは‘\$’と記述しなければなりません．

　　　　str2 が空である場合には，str1 は空文字列に置き換えられる（すなわち
　　　　削除される）ことになります．

　　　　str2 が‘%’であれば，直前の s修飾における str2 が使用されます．
　　　　str1 を通常の文字列‘%’に置き換えるには，str2 は‘\%’と記述しなけ
　　　　ればなりません．

　　　　str2 の中の文字‘&’は，str1 そのものに置き換えられます．文字‘&’
　　　　を通常の文字として使うには‘\&’と記述しなければなりません．

　　　　字句解析上の不都合がなければ，sflag の後ろの区切り文字は省略するこ
　　　　とができ，さらに，sflag を使用しないなら str2 の後ろの区切り文字も
　　　　省略することができます．

　　　　str1 は 31バイト以下，str2 は 63バイト以下でなければなりません．


　　&sflag

　　　　最近の s修飾と同じ置換を行います．ただしその s修飾での aフラグ，gフ
　　　　ラグ，および sflag は，ここでは影響しません．あくまでもここで指定し
　　　　たもののみが有効です．


　　p

　　　　履歴リストに登録するのみで，実行しません．aフラグと gフラグは何の効
　　　　果もありません．


　単語選択子と共に使用する場合，修飾子は単語選択子に続けて記述します．修飾
子は複数連ねることができます．その場合，それらは左から右に順に処理されます．

　!置換に { } による囲みを使用している場合には，修飾子は { } の中になければ
なりません．


■ 省略記法


　単語選択子の最初の‘:’は，単語選択子が‘^’，‘$’，‘%’，‘*’，‘-’
のいずれかである場合には省略することができます．また，単語選択子かまたは修
飾子が続く‘!!’は‘!’と略記することができます．たとえば


　　　　　!!:$　　!!$　　!:$　　!$


はどれも同じです．


■ 簡便な修正


　入力行の最初の空白文字（スペースおよび水平タブ）以外の文字が‘^’である場
合，


　　　　^str1^str2^sflag^


という形式の履歴置換であると見なされます．これは


　　　　!!:s^str1^str2^sflag^


の省略形です．



■
■  3  単語分け
■


　fish は履歴置換後の入力行を空白文字（スペースおよび水平タブ）で単語に分解
します．以下の綴りは前後に空白文字がなくても 1語と見なされます．


　　　　　　<<<   <<=   <<    <=    <     >>=   >>    >=    >
　　　　　　&&    &=    &     ||    |=    |     ;     (     )


　空白文字や上記の特殊文字を単語の一部として記述するには，その文字をエスケー
プする必要があります．例外として変数置換 $< および $?< の < はエスケープす
る必要はありません．

　1語の長さは 1024バイトに制限されています．



■
■  4  履歴登録
■


　標準入力からの入力行は，単語数が 1個以上あれば履歴リストに追加登録されま
す．このとき，シェル変数 history に設定された期間内に一度も参照されなかった
イベントは履歴リストから削除されます．

　履歴リストの内容を表示するには組み込みコマンド history を使用します．



■
■  5  別名展開
■


　入力行が単語分けされた後，その単語の並びは後述のコマンドの構文にしたがっ
て解析され，各単一コマンドのコマンド名（最初の単語）が別名であるかどうかが
チェックされます．ただしコマンド名の最初の文字が‘\’でエスケープされている
と，そのコマンド名は決して別名と見なされません．

　もしコマンド名が別名であるならば，その単語は新しいテキストに置き換えられ
ます．このとき，置き換わるテキストに対して再び履歴置換が行われます．ただし，
このときには !! は直前の履歴イベントではなく，別名展開の対象となっている単
語の並びを参照します．したがって，たとえば !!:3 は 3番目の引数を，!$ は最後
の引数を取り込み，!* は全引数を取り込みます．新たに置き換わるテキストの中に
履歴置換が 1つもなければ，最後に全引数が取り込まれます．

　行の中で一度でも別名展開が起こったならば，展開後の行の全体が再び単語分け
され，また再び別名展開処理が始まります．ただし，展開回数が 20回を超えるとエ
ラーとして停止します．例外として，置き換わるテキストの最初の単語が別名と同
じである場合には，このコマンドに対して再び別名展開はしません．例えば


　　alias ls 'ls -CF'


を実行した後で


　　ls *.c


を入力すると，これは


　　ls -CF *.c


に展開されますが，この単一コマンドはこれ以上展開されません．

　( ) で囲まれたコマンド（コマンド・グループ）は別名展開されずにサブシェル
に渡され，サブシェルにおいて別名展開されます．

　シェル変数 noalias がセットされているときには別名展開は行われません．また，
関数内の行に対しては別名展開は行われません．



■
■  6  コマンドの構文
■


　別名展開後の単語の並びは，次の 2つに分類されます．


　　●通常のコマンド行

　　●特別な構文のキーワード行


以下，それぞれについて解説します．


■ 通常のコマンド行


　通常のコマンド行は，「単一コマンド」を任意に組み合わせたもの（複合コマン
ド）です．それぞれの単一コマンドは，1個以上の単語が並んだものです．そのうち
最初の単語はコマンド名を示します．残りの単語はコマンドに対する引数です．

　コマンドの組み合わせ（複合コマンド）には以下のものがあります．ここで，C,
C1, C2 もまた複合コマンドを意味します．


　( C )

　　　コマンド・グループ．C をサブシェル（現在のシェルの複製）上で実行しま
　　　す．C が空であってもかまいません．


　C &

　　　C をサブシェル上で実行します．C が空であってもかまいません．

　　　残念なことにバック・グラウンド実行はしません．:-(


　C1 ; C2

　　　C1 を実行し，それが終了したら次いで C2 を実行します．C1，C2 のどちら
　　　かあるいは両方が空であってもかまいません．


　C1 && C2

　　　C1 を実行し，その終了ステータスが 0 であった場合にのみ C2 を実行しま
　　　す．C1，C2 のどちらかあるいは両方が空であってはなりません．


　C1 || C2

　　　C1 を実行し，その終了ステータスが 0 でなかった場合にのみ C2 を実行し
　　　ます．C1，C2 のどちらかあるいは両方が空であってはなりません．


　C1 | C2

　　　C1 の標準出力を C2 の標準入力に接続した上で，まず C1 を実行し，それが
　　　終了したら次いで C2 を実行します．C1，C2 のどちらかあるいは両方が空で
　　　あってはなりません．


　C1 |& C2

　　　C1 の標準出力と標準エラー出力を C2 の標準入力に接続した上で，まず C1
　　　を実行し，それが終了したら次いで C2 を実行します．C1，C2 のどちらかあ
　　　るいは両方が空であってはなりません．


これらの組み合わせの優先順位と結合方向は次のとおりです．


　　　　　　┌────┬────┬────────┐
　　　　　　│優先順位│結合方向│     区切子     │
　　　　　　├────┼────┼────────┤
　　　　　　│   高   │        │  ( )           │
　　　　　　│   ↑   │   →   │   &            │
　　　　　　│   ↓   │   →   │   ;   &&  ||   │
　　　　　　│   低   │   →   │   |   |&       │
　　　　　　└────┴────┴────────┘


いずれの場合にもコマンドは左から右の順に実行されます．


※パイプ


　| および |& はパイプと呼ばれます．fish はパイプを実現するために一時ファイ
ルを使用します．パイプの構成要素は同時には動作せず，左から右に逐次実行され
ます．
　一時ファイルはシェル変数 temp にセットされたディレクトリに作成されます．
もし temp がセットされていなければ，カレント・ドライブのルート・ディレクト
リに作成されます．


※サブシェル


　fish は，必要なとき自分自身（現在のシェル）を複製し，その複製に処理を行わ
せます．この複製されたプロセスをサブシェルと呼びます．サブシェル上でシェル
の状態（環境，変数，入出力，作業ディレクトリ，その他さまざまなデータ等）を
変化させても現在のシェルは変化しません．


■ 特別な構文


　fish には．通常のコマンド行とは別に，以下の特別な構文が用意されています．
これらの構文を構成するためのキーワードを含む行（キーワード行）は，通常のコ
マンド行とは別に処理されます．原則として，キーワードはそれだけを 1行としな
ければなりません．


　if ( <式> ) ...

　　　<式> の値が 0 でなければ ... を実行します．<式> の値は数値でなければ
　　　なりません．

　　　　　if行では，まず ( ) の対がチェックされ，次に ( ) の内側の <式> 全
　　　体が変数置換された後，<式> が評価されます．式評価においては各一次子ご
　　　とにコマンド置換，組み合わせ展開，ディレクトリ置換，ファイル名置換が
　　　行われます．

　　　　　... を実行する際には再び別名展開が行われます．



　if ( <式> ) then
　    . . .
　else if ( <式2> ) then
　    . . .
　. . .
　else
　    . . .
　endif

　　　<式> の値が 0 でなければ，2行目から最初の else の直前までの行が実行さ
　　　れ，その後 endif までの行は無視されます．

　　　<式> の値が 0 ならば最初の else までの行は無視されて <式2> が評価され
　　　ます．<式2> の値が 0 でなければ，その次の行から次の else の直前までの
　　　行が実行され，その後 endif までの行は無視されます．

　　　else if 文は任意の数だけ使用することができますし，1つもなくてもかまい
　　　ません．

　　　<式>，<式2>，… のどれもが 0 であった場合には，最後の else の次の行か
　　　ら endif の直前までの行が実行されます．else の部分は endif の直前に 1
　　　つだけ使用することができます．これもなくてもかまいません．

　　　endif は最後に 1つだけ必要です．

　　　<式>，<式2>，… の値は数値でなければなりません．

　　　　　if行および else if行では，まず ( ) の対がチェックされ，次にその
　　　( ) の内側の <式> 全体が変数置換された後，<式> が評価されます．式評価
　　　においては各一次子ごとにコマンド置換，組み合わせ展開，ディレクトリ置
　　　換，ファイル名置換が行われます．

　　　　　then の代わりに別名を使用することはできません．

　　　　　　　　　　　　【注意】無視されるべき行にも履歴置換，単語分け，履
　　　　　　　　　　　　　　　　歴登録，別名展開は行われます．



　switch ( <文字列> )
　case [ <パターン>: ] ...
　    . . .
　. . .
　default:
　    . . .
　endsw

　　　<文字列> にマッチする <パターン> を持つ case 文かまたは default ラベ
　　　ルが現われるまでの行を無視します．どちらも現われなかった場合には，
　　　endsw までが無視されることになります．

　　　<文字列> と <パターン> との比較については参照マニュアルの『パターン・
　　　マッチング』の項を参照してください．

　　　　　switch行はまず全体が変数置換されます．次に ( ) の対がチェックされ，
　　　<文字列> の部分がコマンド置換，組み合わせ展開，ディレクトリ置換，ファ
　　　イル名置換の順に置換・展開されます．この結果は 1個の単語でなければな
　　　りません．

　　　　　case行に対しては変数置換のみが行われます．

　　　　　　　　　　　　【注意】無視されるべき行にも履歴置換，単語分け，履
　　　　　　　　　　　　　　　　歴登録，別名展開は行われます．



　foreach <変数名> ( <単語の並び> )
　    . . .
　end

　　　<単語の並び> の単語 1つ 1つについて，end までの行を繰り返します．繰り
　　　返しのたびに，順繰りに <単語の並び> から単語が 1つ取り出されてシェル
　　　変数 <変数名> にセットされます．

　　　　　foreach行はまず全体が変数置換されます．次に <変数名> と ( ) の対
　　　がチェックされ，<単語の並び> の部分がコマンド置換，組み合わせ展開，ディ
　　　レクトリ置換，ファイル名置換の順に置換・展開されます．<変数名> の部分
　　　には変数置換以外の置換・展開は行われません．

　　　　　　　　　　　　【注意】<単語の並び> の単語数が 0個であっても，end
　　　　　　　　　　　　　　　　までの行に対して履歴置換，単語分け，履歴登
　　　　　　　　　　　　　　　　録，別名展開は行われます．



　while <式>
　    . . .
　end

　　　<式> の値が 0 になるまで end までの行を繰り返します．<式> の値は数値
　　　でなければなりません．

　　　　　繰り返しのたびに，まず <式> 全体が変数置換された後，<式> が評価さ
　　　れます．式評価においては各一次子ごとにコマンド置換，組み合わせ展開，ディ
　　　レクトリ置換，ファイル名置換が行われます．

　　　　　　　　　　　　【注意】<式> の値が 0 であっても end までの行に対し
　　　　　　　　　　　　　　　　て履歴置換，単語分け，履歴登録，別名展開は
　　　　　　　　　　　　　　　　行われます．



　<ラベル>:

　　　組み込みコマンド goto および onintr による分岐先を示します．<ラベル>
　　　は任意の文字からなる 1個の単語です．長さに制限はありませんが，先頭の
　　　31バイトのみが有効であり，32バイト目以降は無視されます．

　　　同一スクリプト中に同じ綴りのラベルが複数ある場合には最初のもののみが
　　　認められ，それ以外は無視されます．

　　　　　<ラベル> は一切置換・展開されません．



　[ function | defun ] [ sub ] <関数名> ( ) {
　    . . .
　}

　　　関数を定義します．<関数名> に対して変数置換が行われ，その結果の単語が，
　　　定義する関数名となります．この変数置換の結果は 1個の単語でなければな
　　　りません．関数名は 31バイト以下の単語です．関数名の綴りは，ASCII英数
　　　字，‘_’（アンダースコア），シフトJISコードの組み合わせでなければな
　　　らず，さらに，関数名の先頭の文字は ASCII数字であってはなりません．

　　　キーワード function および defun はあってもなくてもかまいません．

　　　キーワード sub を設定すると，その関数は必ずサブシェル上で実行され，現
　　　在のシェルには影響を与えません．キーワード sub が無ければ，関数は入出
　　　力がファイルやパイプに切り替えられていない限り現在のシェル上で実行さ
　　　れます．

　　　<関数名> の後ろの ( ) は，<関数名> の前にキーワードが何も無い場合には
　　　必ず必要です．<関数名> の前に function，defun，または sub があるなら
　　　ば，あってもなくてもかまいません．

　　　　　関数定義時，関数内のコマンド行 . . . に対しては一切の置換は行われ
　　　ません．単語分けされた後，そのまま保存されます．



■
■  7  単一コマンドごとの処理
■


　行が特別な構文のキーワード行でなく通常のコマンド行であるならば，行に含ま
れる単一のコマンドが構文にしたがって 1個ずつ実行されます．そのときどきにお
いて，各単一コマンドには以下の処理が以下の順序で行われます．


■  7.1  入出力の切り替え


　< word
　<! word

　　　コマンドの標準入力を word とします．

　　　word が -d（d は 0 から 4 までの 1桁の数字）である場合，それは標準ハ
　　　ンドル d を意味します．そうでなければ word はファイルかまたはデバイス
　　　です．その場合，word がファイルまたはデバイスとして存在していなければ
　　　エラーとなります．

　　　word がデバイスである場合，その入力ステータスが‘入力可’でなければエ
　　　ラーとなります．ただし‘!’をつけるかまたはシェル変数 forceio をセッ
　　　トしておくとそのチェックは行われません．


　> word
　>! word
　>& word
　>&! word

　　　コマンドの標準出力を（‘&’をつけた形式では標準エラー出力も一緒に）
　　　word に出力します．

　　　word が -d（d は 0 から 4 までの 1桁の数字）である場合，それは標準ハ
　　　ンドル d を意味します．そうでなければ word はファイルかまたはデバイス
　　　です．

　　　word がデバイスである場合，そのデバイスの出力ステータスは‘出力可’で
　　　なければエラーとなります．ただし‘!’をつけるかまたはシェル変数
　　　forceio をセットしておくとそのチェックは行われません．

　　　word が標準ハンドルでもデバイスでもない場合には word は新規ファイルと
　　　して作成されます．word がファイルとして既に存在している場合には，その
　　　ファイルの以前の内容は失われることになります．シェル変数 noclobber を
　　　セットしておくと，word が既に存在しているファイルである場合にはエラー
　　　となります．‘!’をつけると noclobber は無視されます．


　>> word
　>>! word
　>>& word
　>>&! word

　　　‘>’と同様に解釈され，word が標準ハンドルかまたはデバイスである場合
　　　には‘>’と同じ結果となります．

　　　word が標準ハンドルでもデバイスでもなければ，出力はファイル word の末
　　　尾に追加出力されます．word がファイルとして存在していない場合には新規
　　　に作成されます．シェル変数 noclobber をセットしておくと，ファイル word
　　　が存在していない場合にはエラーとなります．‘!’をつけると noclobber
　　　は無視されます．


　<< word

　　　ヒア・ドキュメント．シェルに対して続けて入力される行を，word のみの行
　　　が入力される直前までコマンドの標準入力に入力します．

　　　word がまったくエスケープされていないならば，行は予め変数置換とコマン
　　　ド置換が行われてからコマンドに入力されます．変数置換やコマンド置換を
　　　抑止するためには，‘$’や‘`’を‘\’でエスケープしてください．ここで
　　　は‘'’と‘"’には特別な意味はありません．‘$’，‘`’，および‘\’を
　　　エスケープしている‘\’は削除され，それ以外の‘\’は保存されます．

　　　word の一部または word 全体がエスケープされている場合には，行は一切置
　　　換・展開されず，そのままの形でコマンドに入力されます．

　　　word の綴りは任意ですが，fish のキーワードと同じ綴りは避けるべきです．

　　　ヒア・ドキュメントを含むコマンドは 1行に 1個とするべきです．たとえば，


　　　　　cat -n << EOF ; cat -n << EOF
　　　　　　この行は最初の cat に入力されます．
　　　　　EOF
　　　　　　この行は 2番目の cat に入力されます．
　　　　　EOF


　　　これは間違ってはいません．しかし，このような記述は勧められません．

　　　以下の例は間違っています．


　　　　　program && cat -n << EOF
　　　　　　ここからの行は，program の終了ステータスが 0 でなければヒア・ド
　　　　　　キュメントの内容であるとは認められないので，これは正しくありま
　　　　　　せん．
　　　　　EOF

　　　　　if ($foo) cat -n << EOF
　　　　　　これも同様です．$foo が 0 だと，ここからの行はヒア・ドキュメン
　　　　　　トの内容であるとは認められません．
　　　　　EOF


　　　ヒア・ドキュメントを含むコマンドと他のコマンドや制御文とを 1行の中で
　　　組み合わせるべきではありません．


　<<< word

　　　ヒア・ストリング．word の末尾に復帰改行コード(0x0d,0x0a)を加えたデー
　　　タがコマンドの標準入力に入力されます．


　単語 word は，予め，変数置換，コマンド置換，組み合わせ展開，ホーム・ディ
レクトリ置換，ファイル名展開の順序で置換・展開されます．この結果は 1個の単
語でなければなりません．

　‘!’を使用するときには，それが履歴置換と見なされないよう，‘!’の後ろに
空白文字を置いて‘!’を 1個の単語とする必要があります．


■  7.2  コマンド名の解析


　単一のコマンドから入出力切り替え部分を取り除いた後，単語の並びのうち最初
の単語がコマンド名となり，残りの単語はコマンドに対する引数となります．

　コマンド名に対しては，引数の並びとは別に，予め変数置換，コマンド置換，組
み合わせ展開，ディレクトリ置換，ファイル名展開の順序で置換・展開が行われま
す．この結果は 1語でなければなりません．


■  7.3  引数に対する置換


　まず，引数全体に対して変数置換が無条件に行われます．

　次に，コマンド置換，組み合わせ展開，ディレクトリ置換，ファイル名展開の順
序で置換・展開が行われます．ただし，以下の組み込みコマンドを実行する際には，
ここではこれらの置換・展開を行わず，各コマンドが実行時に個別に処理します．


　　　@         alias     bind      exit      nop       printf
　　　repeat    return    set       setenv    time      unalias
　　　undefun   unset     unsetenv


■  7.4  単一コマンドの検索


　単一コマンドには次の 3つの種類があります．


　　● 関数

　　● fish組み込みコマンド

　　● ディスク上のコマンド・ファイル（外部コマンド）


　fish はまずコマンドが関数であるかどうかを調べます．コマンド名に完全に一致
する名前の関数が定義されていれば，fish はその関数を実行します．

　コマンド名に一致する関数が無ければ、fish組み込みコマンドまたは外部コマン
ドからコマンドが検索されます．コマンド名がドライブ／ディレクトリ名を含んで
いるなら，そのドライブ／ディレクトリ内を検索し，そうでなければ，シェル変数
path にセットされている各ディレクトリ内を順に検索して最初に見つかったものを
採用します．

　組み込みコマンドは仮想的なディレクトリ‘~~’にあるものとしてディスク上の
コマンド・ファイルと同様に検索されます．したがって組み込みコマンドを実行す
るには‘~~/コマンド名’と書くかまたはシェル変数 path の要素に‘~~’が含まれ
ていなければなりません．

　仮想ディレクトリ‘~~’においては，コマンド名に完全に一致する名前の組み込
みコマンドのみが検索されます．

　現実の（ディスク上の）ディレクトリにおいては，以下のパターンにマッチする
ファイルが検索されます．

　　　　　　　　┌──────┬────┐
　　　　　　　　│  パターン  │優先順位│
　　　　　　　　├──────┼────┤
　　　　　　　　│ <name>     │   高   │
　　　　　　　　│ <name>.R   │   ↑   │
　　　　　　　　│ <name>.X   │   ↓   │
　　　　　　　　│ <name>.BAT │   低   │
　　　　　　　　└──────┴────┘

ここで，<name> はコマンド名です．

<name> に‘.’が含まれている場合には <name> のみが検索され，他の 3つは検索
されません．

<name> の照合はシステムに任せていますので，大文字と小文字が区別されるかどう
かはシステム毎に異なります．<name> 以外の部分（拡張子）については，fish は
大文字と小文字を区別せずに照合します．マッチするファイルが，同じ優先順位に
複数ある場合には，先に検索されたファイルを採用します．大文字と小文字を区別
するシステムでは注意してください．

検索されたエントリがディレクトリやボリュームラベルである場合は，実行不可と
して処理されます．さらに，拡張子が .R，.X，.BAT（大文字と小文字は区別しない）
のいずれでもなく，実行可能属性が付いていないファイルも実行不可として処理さ
れます．これらは path 検索時には無視されます．


※ ハッシュ機構


　fish は，シェル変数 path の各ディレクトリの検索を高速に行うためのハッシュ
機構を備えています．

　組み込みコマンド rehash を実行すると内部のハッシュ表が更新されてハッシュ
機構がオンになります．組み込みコマンド unhash を実行するとハッシュ機構はオ
フになり，各ディレクトリが必ず検索されるようになります．

　fish 起動直後（$%SYSROOT/etc/fishrc を実行する前）は，ハッシュ機構はオフ
になっています．~/[.%]fishrc（ログイン・シェルではさらに ~/[.%]login）を実
行した後もなおハッシュ機構がオンにされておらず，かつ，-f，-n，-t，-cオプショ
ンのいずれも指定されていなければ，fish は自動的にハッシュ表を更新し，ハッシュ
機構をオンにします．

　ハッシュ機構がオンになっているときには，シェル変数 path を再設定するとハッ
シュ表が自動的に更新されます．

　ハッシュ機構がオンになっている場合，新しいコマンド・ファイルをシェル変数
path のディレクトリに置いても，そのコマンドが検索されない可能性があります．
その際には組み込みコマンド rehash を実行してハッシュ表を更新してください．

　ハッシュ機構によってコマンド検索は高速化されますが，ハッシュ表の更新には
コマンド・ファイルの数に応じた時間がかかるので，コマンド起動回数の少ないス
クリプトなどではハッシュ機構をオンにしない方が総合的には速い場合もあります．


■  7.5  単一コマンドの実行


● 関数の実行


　キーワード sub が設定された関数は必ずサブシェル上で実行されます．それ以外
の関数は通常は現在のシェル上で実行されますが，入出力がパイプやファイルに切
り替えられている場合にはサブシェル上で実行されます．

　関数への引数はシェル変数 argv にセットされます．関数の実行を終了すると
argv の値は元に戻ります．関数内の $0 は関数名に置き換えられます．

　関数内の行は別名展開されません．

　関数の終了ステータスは，関数終了時のシェル変数 status の値です．


● fish組み込みコマンドの実行


　fish組み込みコマンドは現在のシェル上で実行されます．ただし，入力または出
力がパイプやファイルに切り替えられている場合にはサブシェル上で実行されるも
のもあります．

　fish組み込みコマンドを実行する際には，実行する直前にシェル変数 status に
0 がセットされ，その後，組み込みコマンド実行時にエラーがあったときにのみ，
シェル変数に 1 がセットされます．ですから，set status=69 あるいは
@ status=69 を実行後の status の値は 0 ではなく 69 です．また，return 69 を
実行後の status の値も，やはり 69 です．

　fish組み込みコマンド実行時にエラーがあると fish はそこで停止します．たと
えば cd foo || cd bar という行を記述しても cd bar は決して実行されませんし，
while，foreach，switch，if なども継続されません．^C が押されたときのように，
端末からコマンド行を読み取っているときにはプロンプトに戻ることになり，さも
なくば終了することになります．これを防ぐためには組み込みコマンド noabort を
使用します．


● ディスク上のコマンドの実行


　見つかったコマンド・ファイルの拡張子が .R，.X（大文字と小文字は区別しない）
のいずれかである場合には，fish はそのファイルを実行可能形式ファイルと見なし
て直接起動します．起動方法はシステムに任されます．コマンドに対する引数の並
びとコマンド名（引数0）は HUPAIR（後で解説します）にしたがってエンコードさ
れてコマンドラインに置かれます．この HUPAIRエンコードをバイパスするには，組
み込みコマンド cmd を使用します．

　拡張子が .BAT（大文字と小文字は区別しない）であるファイルはスクリプト・ファ
イルと見なされ，シェル変数 batshell にセットされているインタープリタが起動
されます．インタープリタに対する引数は，batshell の 2番目以降の要素，スクリ
プト・ファイルのパス名，スクリプトに対する引数の並びの順に並べて引き渡され
ます．これらは HUPAIR にしたがってエンコードされてコマンドラインに置かれま
す．

　　　　　　　　　　　　batshell の初期値は COMMAND ですが，Human68k の標準
　　　　　　　　　　　　の COMMAND.X は / を含む名前をパス名として認識しな
　　　　　　　　　　　　いため，記述したコマンド名に / が含まれていると期待
　　　　　　　　　　　　どおり動作しません．.BAT ファイルの指定には / の代
　　　　　　　　　　　　わりに \ を使用するか，さもなくば，batshell の設定
　　　　　　　　　　　　を hcommand などにしておく必要があります．

　コマンド・ファイルの拡張子が上記以外である場合（この場合，ファイルの実行
可能属性は ON でなければなりません）にはコマンド・ファイルの内容が検査され
ます．コマンド・ファイルの内容の先頭 2バイトが‘HU’ならば，.Xタイプの実行
可能形式ファイルとして直接起動します．コマンド・ファイルの先頭 2バイトが
‘#$’または‘#!’ならば，そのファイルをスクリプト・ファイルと見なし，次に
述べる方法で起動します．コマンドファイルがこれら以外である場合には，fish は
その起動をシステムに任せます（標準システムではエラーとなります）．

　スクリプト・ファイルの内容の先頭 2バイトが‘#!’であるとき，それに続けて
インタープリタ名が記述されていれば，そのインタープリタが起動されます．イン
タープリタ名は空白文字（スペース，水平タブ(0x09)，および復帰(0x0d)）を区切
り文字として切り出され，前後の空白は無視されます．インタープリタ名に続く空
白以外の文字から改行コード(0x0a)の直前までの部分は，インタープリタに対して
先行して渡す引数の並びを HUPAIR にしたがってエンコードした文字列と見なされ，
インタープリタに渡すコマンドラインの先頭に置かれます．コマンドラインにはさ
らにスクリプト・ファイルのパス名とスクリプトに対する引数の並びが追加されま
す．これらは HUPAIR にしたがってエンコードされます．

　スクリプト・ファイルの先頭の‘#!’以降改行までが空かまたは空白文字だけで
ある場合，あるいはスクリプト・ファイルの先頭が‘#$’である場合には，シェル
変数 shell にセットされているインタープリタが起動されます．インタープリタに
対する引数は，shell の 2番目以降の要素，スクリプト・ファイルのパス名，スク
リプトに対する引数の並びの順に並べて引き渡されます．これらは HUPAIR にした
がってエンコードされてコマンドラインに置かれます．

　スクリプトを実行するために起動するインタープリタは，ディスク上のコマンド・
ファイルとして通常のコマンドと同様に検索されます（ただしここでは仮想ディレ
クトリ‘~~’は無視されます）．ここで見つかったコマンド・ファイルの拡張子が
.R，.X（大文字と小文字は区別しない）のいずれかである場合には，fish はそのファ
イルを実行可能形式ファイルと見なして直接起動します．起動方法はシステムに任
されます．拡張子が .BAT（大文字と小文字は区別しない）である場合はエラーとな
ります．これら以外の場合（この場合，ファイルの実行可能属性は ON でなければ
なりません），コマンド・ファイルの内容の先頭 2バイトが‘HU’ならば，.Xタイ
プの実行可能形式ファイルとして直接起動し，そうでなければ fish はその起動を
システムに任せます（標準システムではエラーとなります）．

　拡張子によってコマンド・ファイルの種別を判別する際には，コマンド・ファイ
ルがシンボリック・リンクであっても，リンク先ではなくリンク自体の拡張子で判
別されます．コマンド・ファイルをシンボリック・リンクする際にはこのことに注
意しなければなりません．

　起動するコマンド・ファイルに対して fish の環境変数の完全な複製を渡します．
この環境エリアの余白の量はシェル変数 envmargin で制御することができます．

　ディスク上のコマンドを起動し，それが終了したときには，その終了ステータス
（符号付き16ビット整数）がシェル変数 status に自動的にセットされます．

　fish の作業ディレクトリは独立しており，通常は外部のコマンドの影響を受けま
せん．外部のコマンドによって OS のカレント・ディレクトリが変化しても，コマ
ンド終了後には fish の作業ディレクトリはコマンド起動前の状態に戻ります．外
部のコマンドで fish の作業ディレクトリを変えるには，組み込みコマンド cmd を
使用するか，または，そのコマンドをシェル変数 cdcmds にセットしておく必要が
あります．それらにより作業ディレクトリが変化したときには，fish 上で作業ディ
レクトリを変更したときと同じ二次作用が起こります．つまり，シェル変数 cwd と
oldcwd，環境変数 PWD と OLDPWD が新たな値にセットされた後，関数 cwdcmd がも
し定義されていれば実行されます．

　fish の環境変数もまた独立しており，通常は外部のコマンドの影響を受けません．
外部のコマンドで fish の環境変数を変えるには，組み込みコマンド cmd を使用す
るか，そのコマンドをシェル変数 envcmds にセットしておく必要があります．それ
らのコマンド終了時には，そのコマンドに与えた環境エリアに残されている内容が
すべて fish の環境変数に反映されます．


● HUPAIR


　ディスク上のコマンドを起動する際，すでに述べたとおり，コマンドに対する引
数（単語）の並びとコマンド名（引数0）を HUPAIR にしたがってエンコードした文
字列をコマンドラインにセットして渡します．

　HUPAIR とは Human68k User Program Argument Interface Regurations の略です．
つまり，Human68k 上のユーザ・プログラム間で引数を受け渡す方法を規定するもの
です．詳細は，資料 HUPAIR.DOC を参照してください．

　起動するコマンドが HUPAIR デコーダを組み込んだ『HUPAIR 適合プログラム』で
あるなら，fish からの引数の並びは安全確実にコマンドに伝わります．そうでなけ
れば保証の限りではありませんが，通常は問題が起こらないように考慮した設計が
HUPAIR には為されています．


● コマンドラインの壁


　Human68k ではコマンドラインにセットする文字列の長さは 0バイト以上 255バイ
ト以下とされています．現実には 255バイトを超える文字列をセットすることは可
能なのですが，255バイトに制限されていることを前提として書かれたユーザ・プロ
グラムも少なくなく，その中には，渡されたコマンドラインの文字列の長さが 255
バイトを超えていると重大な障害を引き起こすものもあるために，どのプログラム
にも無条件に 255バイトを超える文字列を渡すのは危険です．

　fish は，ディスク上のコマンドを実行しようとするとき，コマンドラインの文字
列が 255バイトを超えている場合には，まずプログラムを一旦ロードし，それが
HUPAIR 適合プログラムであるかどうかを調べます．HUPAIR 適合プログラムであれ
ば 255バイトを超える文字列を問題なく受け取るはずですから，そのままの引数を
渡して実行します．

　コマンドが HUPAIR 適合プログラムでないならば，fish はシェル変数 hugearg
の設定にしたがって対処します．

　set hugearg=force としておくと，そのままの引数を渡して実行します．

　set hugearg=indirect としておくと，シェル変数 temp が示すディレクトリ下の
一時ファイルに引数を書き込み，プログラムには引数として‘-+-+-<パス名>’を渡
して実行します．

　set hugearg=(indirect <文字列>) としておくと，‘-+-+-’の代わりに <文字列>
を使います．

　以上のどれにも当てはまらない場合にはエラーとして実行を諦めます．

　以上の選択は組み込みコマンド cmd によっても行うことができます．




















■
■
■  単 語 ご と の 置 換
■
■
■
■
■
■
■
■
■


■
■  変数置換
■


　単語中の文字‘$’は変数置換を導きます．ただし，後ろに空白文字（スペースお
よび水平タブ）の続く‘$’と単語の末尾の‘$’は，通常の文字として保存されま
す．

　変数置換は‘"’によるクオートの中でも行われます．‘'’によるクオートの中
では行われません．‘`’によるクオート（コマンド置換）の中の変数置換はサブシェ
ルによって行われます．

　シェル変数から複数の要素を取り出した場合，各要素間には 1文字のスペースが
置かれます．ヒア・ドキュメント内でも‘"’によるクオート内でもなければ，置換
結果は空白文字（スペース，水平タブ，復帰，改行）を区切りとして再び単語に分
解されます．


　$var
　${var}
　$@var
　$@{var}
　$%var
　$%{var}

　　　変数 var の値．

　　　‘@’をつけた形式ではシェル変数，‘%’をつけた形式では環境変数が調べ
　　　られます．‘@’も‘%’もつけない形式では，まずシェル変数が調べられ，
　　　シェル変数がセットされていなければ環境変数が調べられます．


　$var[index]
　${var[index]}
　$@var[index]
　$@{var[index]}
　$%var[index]
　$%{var[index]}

　　　変数 var の値の index 番目の要素．

　　　‘@’をつけた形式ではシェル変数，‘%’をつけた形式では環境変数が調べ
　　　られます．‘@’も‘%’もつけない形式では，まずシェル変数が調べられ，
　　　シェル変数がセットされていなければ環境変数が調べられます．


　$#var
　${#var}
　$@#var
　$@{#var}
　$%#var
　$%{#var}

　　　変数 var の要素数．

　　　‘@’をつけた形式ではシェル変数，‘%’をつけた形式では環境変数が調べ
　　　られます．‘@’も‘%’もつけない形式では，まずシェル変数が調べられ，
　　　シェル変数がセットされていなければ環境変数が調べられます．


　$?var
　${?var}
　$@?var
　$@{?var}
　$%?var
　$%{?var}

　　　変数 var がセットされていれば 1．そうでなければ 0．

　　　‘@’をつけた形式ではシェル変数，‘%’をつけた形式では環境変数が調べ
　　　られます．‘@’も‘%’もつけない形式では，まずシェル変数が調べられ，
　　　シェル変数がセットされていなければ環境変数が調べられます．


　var はアルファベット，‘_’またはシフトJIS文字で始まり，アルファベット，
‘_’，数字，またはシフトJISコードの組み合わせが続く綴りです．


　$*
　${*}

　　　$argv と同じ．


　$#

　　　$#argv と同じ．


　$number
　${number}

　　　number は任意の桁数の 10進数です．

　　　number の値が 1 以上である場合は $argv[number] と同じ意味です．ただし
　　　number の値がシェル変数 argv の要素数より大きくてもエラーにはならずに
　　　空文字列となります．

　　　number の値が 0 である場合，スクリプト実行中はスクリプトのファイル名，
　　　関数実行中は関数名，それ以外のときには fish 起動時に与えられた引数0（
　　　名前引数）となります．


　$?0
　${?0}

　　　$0 を置換する名前があるならば 1．なければ 0．


　$<
　${<}

　　　標準入力から入力される 1物理行に置換されます．EOF が入力された場合は
　　　空文字列となります．置換結果は自動的にクオートされて常に 1単語となり
　　　ます．


　$?<
　${?<}

　　　直前の $< が EOF に到達したならば 0．そうでなければ 1．


　$$
　${$}

　　　シェル番号（10進表記）．先祖プロセスに fish が 1つもない状態から起動
　　　された fish のシェル番号は 1 となり，以後 fish を起動する度に，そのシェ
　　　ル番号は 1 ずつ増加します．サブシェルのシェル番号は親シェルと同一です．


　$,
　${,}

　　　0 から 32767 までの範囲の整数の擬似一様乱数．（10進表記）


　$?

　　　$status と同じ．


■ index


　　　n       n番目の単語
　　　n-m     n番目から m番目までの単語
　　　-n      1番目（最初の単語）から n番目までの単語
　　　n-      n番目から最後までの単語
　　　n*      n番目から最後までの単語
　　　*       1番目から最後までの単語（全単語）


　たとえば $p[$q] のように，index にも変数置換を使用することができます．


■ 修飾子


　上記の変数置換の直後に，次の修飾子を付加することができます．


　　:[<フラグ>]<修飾操作記号>


　<フラグ> の意味は履歴置換の修飾と同じです．<修飾操作記号> には次のものが
あります．


　　h
　　t
　　r
　　e
　　d
　　f
　　u
　　l
　　s/str1/str2/sflag/
　　&sflag

　　　　履歴置換の修飾と同じです．


　　q

　　　変数から取り出した要素の 1つ 1つがそのまま置換結果の 1単語となるよう
　　　に各要素をクオートします．aフラグと gフラグは何の効果もありません．


　　x

　　　通常どおり置換結果を再び単語に分解した後に各単語をクオートします．aフ
　　　ラグと gフラグは何の効果もありません．


　複数の修飾子を連ねることができます．それらは左から右に順に処理されます．

　次節で述べる { } による囲みを使用している場合，修飾子は { } の中になけれ
ばなりません．


■ { } による分離


　{ } は変数置換をそのあとに続く文字と分離する役目を持ちます．例を示します．

　　　　　% set foo=bar foo2=quux
　　　　　% echo $foo2
　　　　　quux
　　　　　% echo ${foo}2
　　　　　bar2

　また，次の例のように‘&’などの特殊な文字を含む修飾子を付加する際にも変数
置換を { } で囲む必要があります．

　　　　　% set foo='fish is fun'
　　　　　% echo $foo
　　　　　fish is fun
　　　　　% echo $foo:s/fish/&ing/
　　　　　is fun
　　　　　ing/: コマンドが見当たりません
　　　　　% echo ${foo:s/fish/&ing/}
　　　　　fishing is fun



■
■  コマンド置換
■


　`command` は，文字列 command をコマンド行としてサブシェルで実行し，その標
準出力から最後の復帰と改行を取り除いたデータに置き換えます．

　command は現在のシェルでは一切置換・展開されず，そのままサブシェルに渡さ
れます．command に含まれるメタ文字はすべてサブシェルに解釈されることになり
ます．

　コマンド置換は‘"’によるクオートの中でも行われます．‘'’によるクオート
の中では行われません．

　ヒア・ドキュメント内でなければ，置換データは再び単語に分解されます．‘"’
によるクオートの中では復帰または改行が単語の区切りとなり，出力の 1行が 1単
語となります．‘"’によるクオートの外では，スペース，水平タブ，復帰，改行が
単語の区切りとなります．いずれの場合にも最初と最後の区切り文字は取り除かれ，
新しい単語を生成しません．また，空の単語は破棄されます．

　構文上，command の中に文字‘`’は含められません．さらに，（ヒア・ドキュメ
ント内でなく）コマンド置換が‘"’によるクオートの中にある場合には，文字‘"’
も含められません．これらの文字を含むコマンド行でコマンド置換を行うには，予
めコマンド行を別名に定義してその別名をサブシェルに渡すなどの工夫が必要です．



■
■  組み合わせ展開
■


　単語 a{b,c,d}e は abe ace ade の 3単語に展開されます．展開結果はソートさ
れず，左右の関係が保存されます．

　この組み合わせ展開は，単語の中にいくつあってもかまいません．たとえば
a{b,c}d{e,f}g は abdeg abdfg acdeg acdfg の 4単語に展開されます．また，組み
合わせ展開はいくらでもネストすることができます．たとえば a{b,c{d,e}f,g}h は
abh acdfh acefh agh の 4単語に展開されます．

　特殊な場合として，単語‘{’，‘}’，および単語中の‘{}’はそのまま保存さ
れます．

　シェル変数 noglob がセットされているときには，この組み合わせ展開は行われ
ません．また，‘"’や‘'’によるクオートの中ではこの組み合わせ展開は行われ
ません．‘`’によるクオート（コマンド置換）の中の組み合わせ展開はサブシェル
によって行われます．



■
■  ディレクトリ置換
■


　単語の先頭が次のいずれかであり，その後ろが空か‘/’，‘\’，‘\/’，
‘\\’のいずれかであれば，それぞれは次のように置き換えられます．


　~         ユーザのホーム・ディレクトリ（シェル変数 home の値）

　~user     システム・ファイル $%SYSROOT/etc/passwd に設定されている user
　　　　　　のホーム・ディレクトリ（user は 1文字以上のASCII英数字の綴り）

　=n        ディレクトリ・スタックの n番目の要素（n は 1桁以上の10進数）

　=-        ディレクトリ・スタックの最後の要素


　単語の先頭が‘=’であり，続く文字が数字でも‘-’でもなければ，‘=’に続く
文字列をディスク上の外部コマンド名としてシェル変数 path にしたがって検索し
て見つかったコマンド・ファイルのパス名で単語全体が置き換えられます．

　以上のディレクトリ置換では，シェル変数 nonomatch がセットされていれば，置
換されるべき名前がなくてもエラーとなりません．その場合，その単語は，
nonomatch=drop ならば捨てられ，そうでなければそのまま保存されます．

　symlinks=expand（シェル変数 symlinks の値が expand）であるときには，以上
の置換後，単語がパス名と見なし得る形をしていて，そのパス名を構成するディレ
クトリにエスケープもクオートもされていない‘..’があれば，その‘..’までの
部分が正規化されます．

　以上のディレクトリ置換では，続く文字が‘/’であれば，置き換わる文字列中の
‘\’は‘/’に変えられ，続く文字が‘\\’であれば，置き換わる文字列中の‘/’
は‘\\’に変えられます．たとえば‘~’の置換結果が‘A:\home/ita’であるとき，
‘~/foo’は‘A:/home/ita/foo’に，‘~\\foo’は‘A:\\home\\ita\\foo’になり
ます．ただしシェル変数 refersysroot がセットされているときには，置き換わる
文字列の先頭の 1文字は（それが‘/’か‘\’であっても）置き換えられません．

　以上のディレクトリ置換は，シェル変数 noglob がセットされているときには行
われません．また，‘"’や‘'’によるクオートの中では行われません．‘`’によ
るクオート（コマンド置換）の中のディレクトリ置換はサブシェルによって行われ
ます．



■
■  ファイル（ディレクトリ・エントリ）名展開
■


　パターン・マッチングによりファイル（ディレクトリ・エントリ）名展開が行わ
れます（『パターン・マッチング』参照）．

　ディレクトリの区切り文字としては通常‘/’を用いますが，‘\’をエスケープ
した形である‘\\’と‘/’をエスケープした形である‘\/’もディレクトリの区切
りとして認められます．

　ドライブ名とそれに続く‘:’，およびディレクトリの区切りの‘/’（もしくは
‘\\’，‘\/’）を除いた，パス名の各ディレクトリ部（もしあれば）と最後のファ
イル部のどこにでもパターン・マッチングのメタ文字を使用することができます．
ただし‘.’で始まるエントリはパターンが‘.’で始まっている場合にのみ展開さ
れます．シェル変数 globdotA がセットされていると，‘.’と‘..’はいずれの場
合も展開されません．ボリューム・ラベルは決して展開されません．

　単語をファイル名展開した結果の単語並びは，通常，文字コード順にソートされ
ます．シェル変数 nosort がセットされている場合にはソートされません．

　ファイル名展開は通常，ディレクトリ名やファイル名の ASCII英大文字／小文字
を区別しますが，シェル変数 ciglob がセットされている場合には区別しません．
ただしこの場合にも展開結果のソートは大文字と小文字を区別して行われます．

　コマンドの引数にファイル名展開があるとき，マッチするファイルが 1つも存在
していなければエラーとなりますが，ファイル名展開を含む引数のすべてがマッチ
しなければならないわけではありません．つまり，少なくとも引数のどれか 1つに
マッチするファイルがあればエラーにはなりません．

　シェル変数 nonomatch がセットされている場合には，マッチするファイル名が
1つも存在していなくてもエラーとなりません．ファイル名展開を含む引数のうち，
マッチするファイルがなかったものは，nonomatch=drop ならば捨てられ，そうでな
ければそのまま保存されます．

　シェル変数 noglob がセットされているときには，このファイル名展開は行われ
ません．また，‘"’や‘'’によるクオートの中では，このファイル名展開は行わ
れません．‘`’によるクオート（コマンド置換）の中のファイル名展開はサブシェ
ルによって行われます．























■
■
■  参 照 マ ニ ュ ア ル
■
■
■
■
■
■
■
■
■


■
■  エスケープとクオート
■


　\c            文字 c をエスケープします．

　'string'      string をクオートします．

　"string"      string をクオートしますが，string に対して変数置換とコマン
　　　　　　　　ド置換は行われます．

　`command`     command をサブシェル上で実行し，標準出力に出力された文字列
　　　　　　　　に置き換えます．（コマンド置換）
　　　　　　　　command に対する置換はサブシェル側で行われます．



■
■  パターン・マッチング
■


　ここではファイル名展開，case文，パターン比較演算式（=~ および !~），組み
込みコマンド unalias，undefun，unset，およびシェル変数 cdcmds，envcmds 参照
時において行われるパターン・マッチングについて説明します．

　パターンのメタ文字には次のものがあります．


　　*         0個以上の任意の文字とマッチします．
　　?         任意の 1文字とマッチします．
　　[list]    list 中の 1文字とマッチします．
　　[^list]   list に含まれない 1文字とマッチします．


list 中では‘-’は範囲を表わします．lower-upper は，文字コードが，文字
lower と文字 upper の間にある任意の 1文字とマッチすることになります．

list 中でも文字‘\’は続く文字をエスケープします．エスケープされていない
‘[’または‘[^’の直後では‘-’と‘]’は特別な意味を持ちません．また，特別
な意味を持つ‘-’に続く‘-’と‘]’は特別な意味を持ちません．

　なお，マルチバイト文字も 1文字と見なします．マルチバイト文字は，どの 1バ
イト文字よりも大きいものとします．



■
■  式
■


　ここでは if文，while文，組み込みコマンド @，exit，printf，return における
「式」について解説します．

　式は，予め全体的に変数置換されてから評価されます．さらに，キーワードや演
算子を除く各トークンは，一次子が評価されるとき個別にコマンド置換，組み合わ
せ展開，ディレクトリ置換，ファイル名展開の順序で置換・展開されます．ただし，
演算子 =~ および !~ の直後のトークンが通常の単語である場合，その単語に対し
ては一切の置換・展開は行われません．

　式の演算子は 1個の単語として独立していなければなりません．演算子の前後に
は必ず空白文字（スペースまたは水平タブ）を置くようにしてください．例外とし
て，以下のトークンはコマンドの構文記号として自動的に 1個の単語と見なされる
ので，空白で区切る必要はありません．


　　　　<<    <     >>    >     &&    &     ||    |     (     )


これらの演算子を含む式は，演算子がコマンドの構文記号と見なされぬよう ( ) で
囲まなければなりません．

　fish は式の各項を文字列として評価します．数値演算式においては，各項の文字
列を一旦数値に変換してから演算を行い，その結果を必要最小桁数の 10進表記文字
列に変換します．このとき，値が負数であれば文字列の先頭には符号‘-’が付き，
正数であれば符号は付きません．

　数値演算は符号つき 32ビットの整数型として行います．オーバーフローおよびア
ンダーフローは無視します．0 による除算および剰余算はエラーとします．


■ 文字列から数値への変換規則


　式の値は文字列として表現され，数値が要求される項においては以下の規則によっ
て数値に変換されます．このときオーバーフローは無視されます．


　d...

　　　10進数（d は‘0’から‘9’までのいずれかの文字）


　0d...

　　　8進数（d は‘0’から‘7’までのいずれかの文字）


　0xd...
　0Xd...

　　　16進数（d は‘0’から‘9’まで，‘A’から‘F’まで，‘a’から‘f’ま
　　　でのいずれかの文字）


　これらの表記の前には符号‘-’あるいは‘+’が認められます．もちろん，正数
ならば符号は不要です．


■ 一次式


　一次式の 1つにファイル検査演算式があります．一次式があるべき位置にあって，
‘-’で始まり ASCII英文字が続く単語はファイル検査演算子と見なされます．ファ
イル検査演算式には以下のものがあります．


　-e name

　　name がディレクトリ・エントリとして存在するならば‘1’．そうでなければ
　　‘0’．


　-v name

　　name がディレクトリ・エントリとして存在し，かつ，ボリューム・ラベル属性
　　が ON ならば‘1’．そうでなければ‘0’．


　-d name

　　name がディレクトリならば‘1’．そうでなければ‘0’．ディレクトリ属性が
　　ON である現実のディレクトリ・エントリはもちろん，D: のようなドライブ名の
　　みの名前や，ルート・ディレクトリ，あるいはそれらを指す . や .. およびシ
　　ンボリック・リンクなども，そこにアクセス可能であれば‘1’となります．


　-f name

　　name がディレクトリ・エントリとして存在し，かつ，ディレクトリ属性もボ
　　リューム・ラベル属性も OFF ならば‘1’．そうでなければ‘0’．


  -l name

　　name がディレクトリ・エントリとして存在し，かつ，シンボリック・リンク属
　　性が ON ならば‘1’．そうでなければ‘0’．


　-a name

　　name がディレクトリ・エントリとして存在し，かつ，アーカイブ属性が ON な
　　らば‘1’．そうでなければ‘0’．


　-s name

　　name がディレクトリ・エントリとして存在し，かつ，システム属性が ON なら
　　ば‘1’．そうでなければ‘0’．


　-h name

　　name がディレクトリ・エントリとして存在し，かつ，隠匿属性が ON ならば
　　‘1’．そうでなければ‘0’．


　-w name

　　name がディレクトリ・エントリとして存在し，かつ，読み出し専用属性が OFF
　　ならば‘1’．そうでなければ‘0’．


　-x name

　　name がディレクトリ・エントリとして存在し，かつ，実行可能属性が ON なら
　　ば‘1’．そうでなければ‘0’．


　-z name

　　name がディレクトリ・エントリとして存在し，かつ，サイズが 0 ならば‘1’．
　　そうでなければ‘0’．


　-b name

　　name がオープン可能であり，かつ，その実体がブロック・デバイスであるなら
　　ば‘1’．そうでなければ‘0’．


　-c name

　　name がオープン可能であり，かつ，その実体がキャラクタ・デバイスであるな
　　らば‘1’．そうでなければ‘0’．


　-i name

　　name がオープン可能であり，かつ，その実体が入力可能なデバイスであるなら
　　ば‘1’．そうでなければ‘0’．


　-o name

　　name がオープン可能であり，かつ，その実体が出力可能なデバイスであるなら
　　ば‘1’．そうでなければ‘0’．


　-X name

　　name がコマンドとして実行可能な名前である（which -o name で見つかる）な
　　らば‘1’．そうでなければ‘0’．


　-t n

　　シェルのファイル・デスクリプタ n がコンソールならば‘1’．そうでなけれ
　　ば‘0’．


以上のファイル検査演算子を複数まとめて 1つの演算子として記述することができ
ます．たとえば ( -fw name ) は ( -f name && -w name ) と等価です．

　ファイル検査演算式の他には次の一次式があります．


　sizeof name

　　ディレクトリ・エントリ name のサイズの 10進表記文字列．name が存在しな
　　いならば‘0’．


　timeof name

　　ディレクトリ・エントリ name のタイム・スタンプの値の 10進表記文字列．
　　name が存在しないならば‘0’．


　freeof d:

　　ドライブ d の空き容量（バイト）の 10進表記文字列．カレント・ドライブは
　　‘@:’で指定することができます．


　strlen word

　　word の長さの 10進表記文字列．


　{ command }

　　command をサブシェル上で実行し，その終了ステータスが 0 ならば‘1’．そ
　　うでなければ‘0’．


　( E )

　　式 E の値．


　一次子があるべき位置にある単語が，以上のどれにも当てはまらなければ，その
単語がそのまま一次式の値となります．

　シンボリック・リンク機構を持つシステム上で，以上の一次式において name が
シンボリック・リンクである場合，検査されるのは name 自体ではなく name が指
すリンク先のファイルです．-l name のみは例外で，これは name そのものがシン
ボリック・リンクであるかどうかを検査します．


■ 演算式


　以下に各演算式について解説します．


　+ E

　　　式 E の値は数値でなければなりません．結果は E の値（数値）となります．


　- E

　　　式 E の値は数値でなければなりません．結果は E の値の符号を反転した数
　　　値となります．


　~ E

　　　式 E の値は数値でなければなりません．結果は E の値のビット・パターン
　　　をビット毎に反転した数値となります．


　! E

　　　式 E の値は数値でなければなりません．結果は E の値が 0 ならば‘1’，
　　　そうでなければ‘0’となります．


　E1 * E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 の値と E2
　　　の値とを乗じた数値となります．


　E1 / E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 の値を E2
　　　の値で割った数値となります．E2 の値が 0 だとエラーとなります．


　E1 % E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 の値を E2
　　　の値で割った余り（数値）となります．E2 の値が 0 だとエラーとなります．


　E1 + E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 の値と E2
　　　の値とを加えた数値となります．


　E1 - E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 の値から E2
　　　の値を減じた数値となります．


　E1 << E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 の値のビッ
　　　ト・パターンを (E2)ビットだけ MSB 側にシフトした数値となります．下位
　　　のビットには 0 が詰められます．


　E1 >> E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 の値のビッ
　　　ト・パターンを (E2)ビットだけ LSB側にシフトした数値となります．上位の
　　　ビットには元の MSB（符号ビット）が詰められます．


　E1 <= E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 の値が E2
　　　の値より小さいか等しければ‘1’，そうでなければ‘0’となります．


　E1 >= E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 の値が E2
　　　の値より大きいか等しければ‘1’，そうでなければ‘0’となります．


　E1 < E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 の値が E2
　　　の値より小さければ‘1’，そうでなければ‘0’となります．


　E1 > E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 の値が E2
　　　の値より大きければ‘1’，そうでなければ‘0’となります．


　E1 == E2
　E1 != E2

　　　式 E1 および E2 の値を文字列として比較します．式　E1 == E2 の結果は
　　　E1 の値と E2 の値が同一であれば‘1’，そうでなければ‘0’となります．
　　　式 E1 != E2 の結果はその逆です．

　　　E1 の値と E2 の値が文字列として扱われることに注意してください．


　　　　　foo == foo


　　　の値は‘1’となります．E1 の値と E2 の値が数値と見なし得る場合，たと
　　　えば


　　　　　69 == 69


　　　の値も当然‘1’となりますし，


　　　　　66 + 3 == 69


　　　の値も‘1’となります．左項 66 + 3 は先に計算されて‘69’という文字列
　　　になり，それと右項の文字列‘69’とが比較されることになるからです．し
　　　かし，


　　　　　0x10 == 16


　　　では，一次子‘0x10’は文字列としてそのまま評価されるため，これは右辺
　　　の文字列‘16’とは一致せず，この式の値は‘0’となってしまいます．これ
　　　をたとえば


　　　　　0x10 + 0 == 16


　　　とすると，一次子‘0x10’は演算子‘+’のために一度数値に変換され，それ
　　　に 0 を加えた結果は文字列‘16’に変換されるので，この式の値は‘1’と
　　　なります．


　E1 =~ E2
　E1 !~ E2

　　　式 E1 および E2 を文字列として比較します．== や != との違いは E2 の値
　　　を『パターン』として，パターン比較を行うことです．式　E1 =~ E2 の結果
　　　は，文字列 E1 がパターン E2 にマッチすれば‘1’，そうでなければ‘0’
　　　となります．式　E1 !~ E2 の結果はその逆です．

　　　E2 が一次式（すなわち単語）であるならば，E2 に対して単語毎の置換は行
　　　われません．


　E1 & E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 の値と E2
　　　の値のビット・パターンのビット毎の論理積（数値）となります．


　E1 ^ E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 の値と E2
　　　の値のビット・パターンのビット毎の排他的論理和（数値）となります．


　E1 | E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 の値と E2
　　　の値のビット・パターンのビット毎の論理和（数値）となります．


　E1 && E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 の値と E2
　　　の値のどちらも 0 でなければ‘1’，そうでなければ‘0’となります．この
　　　式では，まず式 E1 が評価され，その値が 0 でなければ式 E2 が評価されま
　　　す．式 E1 の値が 0 であれば式 E2 は評価されません．


　E1 || E2

　　　式 E1 および E2 の値は数値でなければなりません．結果は E1 の値と E2
　　　の値のどちらも 0 ならば‘0’，そうでなければ‘1’となります．この式で
　　　は，まず式 E1 が評価され，その値が 0 ならば式 E2 が評価されます．式
　　　E1 の値が 0 でなければ式 E2 は評価されません．


　E1 ? E2 : E3

　　　式 E1 の値は数値でなければなりません．E1 の値が 0 でなければ式 E2 が
　　　評価され，この式の値は E2 となります．このとき式 E3 は評価されません．
　　　そうでなければ式 E3 が評価され，この式の値は E3 となります．このとき
　　　式 E2 は評価されません．


　E1 , E2

　　　式 E1 を評価してから式 E2 を評価します．結果は E2 となります．


■ 演算子の優先順位


　次の表は演算子の優先順位と結合方向をまとめたものです．


　　┌────┬────┬──────────────────────┐
　　│優先順位│結合方向│                     式                     │
　　├────┼────┼──────────────────────┤
　　│   高   │   ←   │   + E     - E     ~ E     ! E              │
　　│        │   →   │   E1 * E2   E1 / E2   E1 % E2              │
　　│   ↑   │   →   │   E1 + E2   E1 - E2                        │
　　│        │   →   │   E1 << E2  E1 >> E2                       │
　　│        │   →   │   E1 <= E2  E1 >= E2  E1 < E2   E1 > E2    │
　　│        │   →   │   E1 == E2  E1 != E2  E =~ pat  E !~ pat   │
　　│        │   →   │   E1 & E2                                  │
　　│        │   →   │   E1 ^ E2                                  │
　　│        │   →   │   E1 | E2                                  │
　　│        │   →   │   E1 && E2                                 │
　　│   ↓   │   →   │   E1 || E2                                 │
　　│        │   ←   │   E1 ? E2 : E3                             │
　　│   低   │   →   │   E1 , E2                                  │
　　└────┴────┴──────────────────────┘



■
■  組み込みコマンド
■


　fish には以下のコマンドが組み込まれており，これらは仮想的なディレクトリ
‘~~’下に置かれています．

　fish組み込みコマンドを実行する際には，実行する直前にシェル変数 status に
0 がセットされ，その後，組み込みコマンド実行時にエラーがあったときにのみ，
シェル変数に 1 がセットされます．ですから，set status=69 あるいは
@ status=69 を実行後の status の値は 0 ではなく 69 です．また，return 69 を
実行後の status の値も，やはり 69 です．

　fish組み込みコマンド実行時にエラーがあると fish はそこで停止します．たと
えば cd foo || cd bar という行を記述しても cd bar は決して実行されませんし，
while，foreach，switch，if なども継続されません．^C が押されたときのように，
端末からコマンド行を読み取っているときにはプロンプトに戻ることになり，さも
なくば終了することになります．これを防ぐためには組み込みコマンド noabort を
使用します．



@

　組み込みコマンド set と同様に，定義されているシェル変数をすべて表示します．



@ <名前> = <式>

　シェル変数 <名前> に <式> の値をセットします．シェル変数 <名前> の要素数
　は 1個となります．

　<式> の値は数値でなくてはなりません．

　　　代入演算子の前後には空白文字（スペースあるいは水平タブ）があってもな
　くてもかまいません．



@ <名前> *= <式>
@ <名前> /= <式>
@ <名前> %= <式>
@ <名前> += <式>
@ <名前> -= <式>
@ <名前> <<= <式>
@ <名前> >>= <式>
@ <名前> &= <式>
@ <名前> ^= <式>
@ <名前> |= <式>

　シェル変数 <名前> の最初の要素に対して言語Ｃと同様の演算を行います．シェ
　ル変数 <名前> の要素数は 1個になります．

　シェル変数 <名前> の最初の要素および <式> の値は数値でなければなりません．

　　　代入演算子の前後には空白文字（スペースあるいは水平タブ）があってもな
　くてもかまいません．



@ <名前>[<インデックス>] = <式>
@ <名前>[<インデックス>] *= <式>
@ <名前>[<インデックス>] /= <式>
@ <名前>[<インデックス>] %= <式>
@ <名前>[<インデックス>] += <式>
@ <名前>[<インデックス>] -= <式>
@ <名前>[<インデックス>] <<= <式>
@ <名前>[<インデックス>] >>= <式>
@ <名前>[<インデックス>] &= <式>
@ <名前>[<インデックス>] ^= <式>
@ <名前>[<インデックス>] |= <式>

　シェル変数 <名前> の <インデックス> 番目の要素に対して言語Ｃと同様の演算
　を行います．シェル変数 <名前> の <インデックス> 番目の要素と <式> の値は
　数値でなくてはなりません．

　　　代入演算子の前後には空白文字（スペースあるいは水平タブ）があってもな
　くてもかまいません．



@ <名前> ++

　シェル変数 <名前> の最初の要素をインクリメントします．シェル変数 <名前>
　の要素数は 1個になります．

　シェル変数 <名前> の最初の要素が数値であれば，Ｃと同様の算術インクリメン
　トを行います．シェル変数 <名前> の最初の要素が，ASCII英文字かまたは ASCII
　数字による 1文字以上の綴りであり，かつ，最初の文字が ASCII英文字であれば，
　perl と同様のマジカル・インクリメントを行います．例外として，シェル変数
　<名前> がセットされていないか，要素数が 0個であれば，シェル変数 <名前> に
　‘1’をセットします．それ以外の場合はエラーとなります．

　マジカル・インクリメントでは，文字列の右端から見た各桁の文字種は変わりま
　せん．たとえば‘X68’は‘X69’，‘az’は‘ba’，‘Z9’は‘AA0’となります．

　　　演算子の前には空白文字（スペースあるいは水平タブ）があってもなくても
　かまいません．



@ <名前> --

　シェル変数 <名前> の最初の要素に対してＣと同様の算術デクリメントを行いま
　す．シェル変数 <名前> の要素数は 1個になります．

　シェル変数 <名前> の最初の要素は数値でなければなりません．

　例外として，シェル変数 <名前> がセットされていないか，要素数が 0個であれ
　ば，シェル変数 <名前> に‘-1’をセットします．

　　　演算子の前には空白文字（スペースあるいは水平タブ）があってもなくても
　かまいません．



@ <名前>[<インデックス>] ++

　シェル変数 <名前> の <インデックス> 番目の要素をインクリメントします．

　シェル変数 <名前> の <インデックス> 番目の要素が数値であれば，Ｃと同様の
　算術インクリメントを行います．シェル変数 <名前> の最初の要素が，ASCII英文
　字かまたは ASCII数字による 1文字以上の綴りであり，かつ，最初の文字が
　ASCII英文字であれば，perl と同様のマジカル・インクリメントを行います．そ
　れ以外の場合はエラーとなります．

　　　演算子の前には空白文字（スペースあるいは水平タブ）があってもなくても
　かまいません．



@ <名前>[<インデックス>] --

　シェル変数 <名前> の <インデックス> 番目の要素に対してＣと同様の算術デク
　リメントを行います．シェル変数 <名前> の <インデックス> 番目の要素は数値
　でなくてはなりません．

　　　演算子の前には空白文字（スペースあるいは水平タブ）があってもなくても
　かまいません．



alias

　定義されているすべての別名とその定義内容を表示します．



alias <名前>

　別名 <名前> の定義内容を表示します．



alias <名前> <単語の並び>

　<名前> を <単語の並び>（コマンド）の別名として定義します．<名前> はどのよ
　うな綴りでも構いませんが，例外として，alias，unalias を別名として定義する
　ことはできません．また，‘\’を含む名前の別名は決して展開されません．



alloc

　fish が定常的に確保している動的メモリの量と使用状況を表示します．



apply [ -pt ] [ -<N> ] [ -- ] <コマンド行> [ <単語の並び> ]

　<単語の並び> から 1組ずつの単語を順に取り出しながら，それぞれの単語の組に
　ついて <コマンド行> を繰り返し実行します．

　<コマンド行> は 1単語として記述しなければなりません．<コマンド行> は組み
　込みコマンド eval と同様にシェルの入力行として再び解析され実行されます．

　<コマンド行> に含まれる履歴置換 !! は，直前のイベントではなく，<単語の並
　び> から取り出された 1組の単語の並びを参照します．!! には必ず単語選択子を
　指定しなければなりません．そこで使用できる単語選択子は :n または :n-m の
　形式に限られます．:-n，:n-，:n*，:* などの形式を使用することはできません．
　さらに，ここで n および m としては 1 以上の数値かまたは 1番目の単語を表す
　^ のみが許され，0，$，%，* を使用することはできません．一般的には \!:1，
　\!:2，... という形式で単語を参照します．

　<コマンド行> 内に !! による単語の参照がある場合，apply は <コマンド行> が
　参照している単語の番号の最大値の数ずつの単語を <単語の並び> から取り出し
　ます．

　!! による引数の参照が <コマンド行> 内に 1つも無ければ，apply は <単語の並
　び> から <N> 個ずつの単語を取り出して <コマンド行> の末尾に追加します．
　<N> が指定されていない場合のデフォルトは 1 です．特別な場合として <N> が
　0 である場合には，<コマンド行> に単語を追加せずに，<単語の並び> の単語数
　だけ <コマンド行> を繰り返し実行します．

　<単語の並び> の単語数は，<コマンド行> に与えられる単語数の整数倍でなけれ
　ばなりません．

　-tオプションや -pオプションを指定すると，<コマンド行> を実行する前にその
　内容が標準エラー出力に表示されます．-pオプションでは，そこで，実行するか
　どうかが問い合わされます．そのとき‘y’で始まる行を入力すると実行が行われ，
　それ以外の入力ではスキップされます．

　（例）

　　　　apply echo *

　　は ls -1 と同じ結果となります．

　　　　apply -2 diff a1 b1 a2 b2 a3 b3

　　は a1 と b1，a2 と b2，a3 と b3 を比較します．この結果をプリンタに印刷
　　するには

　　　　apply 'diff \!:1 \!:2 | lpr' a1 b1 a2 b2 a3 b3

　　のようにします．

　　　　apply -0 'echo $,' 1 2 3

　　は repeat 3 eval 'echo $,' と同じ結果となります．



bind

　現在のキー・バインドを表示します．ただし self-insert と error は表示しま
　せん．



bind -a

　現在のすべてのキーのバインドを表示します．



bind [ [prefix]-{1|2} ] <キー>

　<キー> または prefix-1 <キー> または prefix-2 <キー> にバインドされている
　機能を表示します．<キー> は 1文字の引数です．制御文字を <キー> として指定
　するために，引数 <キー> を '^D' のように 2文字で表わすことができます．も
　ちろん，もし可能ならば制御文字を直接引数に置いてもかまいません．



bind [ [prefix]-{1|2} ] <キー> <機能> [ <文字列> ]

　<キー> または prefix-1 <キー> または prefix-2 <キー> に <機能> をバインド
　します．<機能> については『行入力編集機構』を参照して下さい．<文字列> は
　機能 eval-command および macro でのみ使われます．



bind -d
bind default

　すべてのキーにデフォルトの機能をバインドします．



breaksw

　現在の switch の endsw の直後に跳びます．現在の行の残りのコマンドは実行さ
　れます．ですから，


　　breaksw ; break


　は，現在の switch〜endsw を脱出した後，その外側の foreach または while の
　ループも脱出します．



break

　現在の foreach / while の end の直後に跳び，ループを脱出します．現在の行
　の残りのコマンドは実行されます．ですから，


　　　break ; break


　は，現在のループを脱出した後，その外側のループも脱出します．



cd [ -lvs ] [ -- ] [ - | <名前> | +<N>[.] ]
chdir [ -lvs ] [ -- ] [ - | <名前> | +<N>[.] ]

　作業ディレクトリを変更します．


　cd
　chdir

　　シェル変数 home の値（最初の単語）のディレクトリに移動します．home の値
　　は完全パス名でなければなりません．

　cd -
　chdir -

　　直前の作業ディレクトリに移動します．

　cd <名前>
　chdir <名前>

　　作業ディレクトリをディレクトリ <名前> に移します．ディレクトリ <名前>
　　が存在しない場合にはシェル変数 cdpath の値の各要素のディレクトリ下のディ
　　レクトリ <名前> について試します．そのどれもが存在しない場合には，シェ
　　ル変数 <名前> の値（最初の単語）を調べ，もしそれが完全パス名であれば，
　　そのディレクトリに移動します．それも存在しなければエラーとなります．特
　　別な場合として，<名前> が空である場合には，引数がない場合と同じくシェル
　　変数 home の値のディレクトリに移動します．

　cd +<N>[.]
　chdir +<N>[.]

　　ディレクトリ・スタックの先頭の要素（現在の作業ディレクトリ）を破棄して，
　　<N>番目の要素を先頭とします．<N> は 1 以上でなければなりません．+<N> の
　　形式では，<N>番目の要素が先頭となるようスタック全体を回転します．+<N>.
　　の形式では，<N>番目の要素を抜き出してスタックの先頭に積みます．


　引数が +<N>[.] か - である場合，および，引数が <名前> であるが実際に移動
　したディレクトリが <名前> そのものではなく cdpath の要素やシェル変数の値
　である場合には，操作が完了後，新しいディレクトリ・スタックの内容が表示さ
　れます．ただしシェル変数 pushdsilent がセットされているかまたは -sオプショ
　ンが指定されている場合には表示されません．-lオプションと -vオプションは，
　この表示の形式を指定します．その意味は組み込みコマンド dirs と同じです．

　ディレクトリを指すシンボリック・リンクからの .. の解釈は，シェル変数
　symlinks によって制御されます．

　エラーが無ければ，シェル変数 cwd と oldcwd，環境変数 PWD と OLDPWD が新た
　な値にセットされ，関数 cwdcmd がもし定義されていれば実行されます．



cdd [<ドライブ名>:][<ディレクトリ名>]

　COMMAND.X の組み込みコマンド CD / CHDIR とほぼ同じ働きをします．つまり，
　<ドライブ名> で指定されるドライブのカレント・ディレクトリの変更や表示を行
　います．<ドライブ名> を省略するとカレント・ドライブを指定したことになりま
　す．

　<ディレクトリ名> を指定しなければ，指定ドライブのカレント・ディレクトリを
　表示します．これは OS が管理しているドライブ毎のカレント・ディレクトリに
　ドライブ名を加えた完全パス名です．

　<ディレクトリ名> を指定すると，指定ドライブのカレント・ディレクトリを <ディ
　レクトリ名> に移します．指定ドライブがカレント・ドライブであると作業ディ
　レクトリが変化することになり，その場合には組み込みコマンド cd，chdir，
　popd，pushd と同じ二次作用が起こります．つまり，シェル変数 cwd と oldcwd，
　環境変数 PWD と OLDPWD が新たな値にセットされた後，関数 cwdcmd がもし定義
　されていれば実行されます．

　<ディレクトリ名> には次の制約があります．

　● 現実のディレクトリでなければならず，シンボリック・リンクは認められませ
　　 ん．

　● シェル変数 symlinks の制御は受けず，シンボリック・リンクからの‘..’は
　　 常にその実体の親ディレクトリを意味します（ただし symlinks=expand では
　　 cdd 実行前に引数が置換されます）．

　● シェル変数 refersysroot の影響を受けません．/ で始まる <ディレクトリ名>
　　 は常に指定ドライブのルート・ディレクトリを意味します．



cmd [ -a | -i[<文字列>] | -f ] [ -rdet ] <コマンド> [ <引数の並び> ]

　<コマンド> を実行します．<コマンド> は単一のコマンド名です．別名は効きま
　せん．cmd はディスク上の外部コマンドを通常と違う方法で起動するために用い
　られます．fish組み込みコマンドや関数には効果はありません．

　<引数の並び> は <コマンド> の引数となります．通常は HUPAIR にしたがってエ
　ンコードされますが，-rオプションを指定すると，<引数の並び> を HUPAIRエン
　コードせずにそのまま単一の空白で連結した文字列が <コマンド> へのパラメー
　タとしてコマンドラインに置かれます．

　<コマンド> が HUPAIRに準拠していない外部コマンドであり，それに渡そうとす
　るコマンドラインの文字列が255バイトを超える場合，次のオプションにより処置
　を指定することができます．

　-a               unset hugearg の場合と同じです．
　-i[<文字列>]     set hugearg=(indirect <文字列>) の場合と同じです．
　-f               set hugearg=force の場合と同じです．

　これらのオプションを複数指定した場合は最後の指定が有効となります．どれも
　指定しなければ通常どおりシェル変数 hugearg の設定が有効となります．

　その他のオプションには次のものがあります．

　-d     <コマンド> による作業ディレクトリの変更を受け入れます．
　-e     <コマンド> による環境変数の変更を受け入れます．
　-t     <コマンド> が消費した時間を表示します．



continue

　現在の foreach/while の end に跳び，foreach/while を継続します．現在の行
　の残りのコマンドは実行されます．ですから，


　　　continue ; echo 'Next'


　は，実際には 'Next' を表示した後に continue することになります．



dirs [ -lv ]

　ディレクトリ・スタックの内容を表示します．最も左に表示されるのがスタック
　の先頭であり，現在の作業ディレクトリを表わします．通常，要素がユーザのホー
　ム・ディレクトリ（シェル変数 home の値）下のディレクトリであれば，ホーム・
　ディレクトリ部分を ~ と略記します（ただし home の値がドライブ名つきの完全
　パスであり，かつルート・ディレクトリでない場合に限る）．-lオプションを指
　定すると，どの場合にもドライブ名つきの完全パス名を表示します．-vオプショ
　ンを指定すると，1行に 1要素の形式でスタックの先頭から順に番号とともに表示
　します．スタックの先頭すなわち現在の作業ディレクトリは 0番であり，以下，
　1, 2, 3, ... と続きます．



echo [ -cern2 ] [ -- ] <単語の並び>

　<単語の並び> を標準出力に出力します．-2オプションを指定すると標準出力では
　なく標準エラー出力に出力します．単語間には 1文字のスペースを出力します．
　通常は最後に復帰改行を出力しますが，-cオプションを指定すると，単語の数が
　0個であるときには復帰改行を出力しません．-nオプションは常に復帰改行の出力
　を抑止します．

　-eオプションを指定すると，以下の文字エスケープ符号を使用することができま
　す．


　　\\  文字‘\’
　　\a  ベル
　　\b  バックスペース
　　\c  最後の復帰改行を抑止する
　　\f  改頁
　　\n  復帰改行
　　\r  復帰
　　\t  水平タブ
　　\v  垂直タブ

　　\d
　　\dd
　　\ddd

　　　　8進表記の文字コード（d は‘0’から‘7’までのいずれかの文字）


　これ以外のシーケンスは，文字エスケープ符号とは見なされず，そのまま出力さ
　れます．

　-rオプションは -eオプションを取り消します．

　<単語の並び> の最初の単語がオプション引数と認められてしまうケースは，
　<単語の並び> の直前に単語‘--’を置いて回避してください．



eval <単語の並び>

　<単語の並び> をスペースで連結した文字列をシェルの入力行として解析し，現在
　のシェル上で実行します．ただし eval の出力がパイプやファイルに切り替えら
　れている場合にはサブシェル上で実行します．



exec

　与えられた入出力をシェルの入出力とします．

　exec がパイプの構成要素（最後を除く）である場合にはサブシェルで実行されま
　す．



exit [ <式> ]

　<式> の値をシェル変数 status にセットして，シェルを終了します．status の
　値の下位16ビットがシェルの終了ステータスとなります．<式> を省略した場合に
　は status はセットされず 0 のままとなり，したがって終了ステータスは 0 と
　なります．

　exit は return とは違ってシェル本体をその時点で即座に終了します．つまり，
　関数や組み込みコマンド source を実行しているときにも，その実行を終了する
　のではなくシェルそのものが終了することになります．

　終了するシェルがログイン・シェルであれば，組み込みコマンド logout が自動
　的に実行されます．



functions

　定義されているすべての関数の内容を標準出力に出力します．



functions <名前>

　関数 <名前> の内容を標準出力に出力します．



getopt <オプション文字列>

　シェル変数 argv の値を引数並びとして解析してオプションとコマンド引数とに
　分解し，オプションをシェル変数 options に，コマンド引数をシェル変数 argv
　にセットします．

　引数並びは次の規則で解析されます．


　　1.  引数並びは単語ごとにオプションとコマンド引数に大別される．

　　2.  1つのオプションは 1文字である．

　　3.  文字‘-’および‘:’をオプション文字として使うことはできない．

　　4.  1つのオプションは 1つのオプション引数を持つことができる．

　　5.  オプション引数を省略可能とすることはできない．

　　6.  オプションには‘-’が先行する．

　　7.  複数のオプションを 1つの‘-’の後ろに連結することができる．

　　8.  引数を持つオプションの直後に 1文字以上の文字列があれば，それがオプ
　　　　ション引数となる．さもなくば次の単語がオプション引数である．

　　9.  オプションはコマンド引数よりも前にある．コマンド引数が 1つでも現れ
　　　　たら，それ以降はすべてコマンド引数である．

　　10. オプション引数でなく‘-’で始まらない単語はコマンド引数である．

　　11. オプション引数でない単語‘-’はコマンド引数である．

　　12. 最初に現れるオプション引数でない単語‘--’は捨てられ，それに続く単
　　　　語はすべてコマンド引数となる．


　<オプション文字列> は，オプションとして有効な文字の並びです．‘:’が続く
　文字は引数を持つオプションを表します．たとえば abcf:o: は a，b，c，f，o
　の 5つのオプションを許し，このうち f と o は引数を持つオプションであるこ
　とを示します．

　シェル変数 options には，1つのオプションが 1単語としてセットされます．引
　数を持つオプションの次には，それに対する引数が置かれます．たとえば
　-a -o xxx -bc は a o xxx b c の 5単語となります．

　<オプション文字列> に含まれないオプションがあったり，あるべきオプション引
　数がない場合にはエラー・メッセージが出力され，options にはそのオプション
　の代わりに‘-’がセットされます．1つでもエラーがあれば，シェル変数 status
　に 1 がセットされます．



glob <単語の並び>

　<単語の並び> を標準出力に出力します．単語間には NUL(0x00) を出力します．



goto <ラベル>

　<ラベル> に跳びます．現在の行の残りのコマンドは実行されます．ですから，


　　　goto foo ; goto bar


　は，ラベル foo に跳んだ後，ラベル bar に跳びます．このコマンドはスクリプ
　ト内でのみ使用可能です．



hashstat

　ハッシュ表によるコマンド検索の成功率を表示します．



history [ -hrt ] [ <イベント数> ]

　保存されている履歴リストから最新の <イベント数> 個のイベントを表示します．
　<イベント数> を省略するとシェル変数 history の値がデフォルトとなります．
　-rオプションを指定すると新しい順に，そうでなければ古い順に表示します．表
　示は 1行に 1イベントの形式で，各行は通常，登録時刻，イベント番号，イベン
　ト本体の順に並んでいます．-tオプションを指定すると登録時刻を表示しません．
　-hオプションを指定すると，さらにイベント番号も表示しません．



history -x <N>[-<M>]

　履歴の N番（から M番まで）のイベントをイベント番号や登録時刻なしで標準出
　力に出力します．



logout

　ログイン・シェルを終了（すなわちログアウト）します．シェルがログイン・シェ
　ルでないならばこのコマンドは無効です．

　fish は，実際に終了する前に，スクリプト・ファイル $SYSROOT/etc/flogout を
　（もしあれば）sourceします．次に ~/.logout を（もしあれば）sourceします．
　~/.logout を読み取ることができなければ代わりに ~/%logout を試します．



noabort <コマンド> [ <引数の並び> ]

　<コマンド> を実行します．<コマンド> が fish組み込みコマンドで実行中にエラー
　があっても，アボートせずシェル変数 status に 1 をセットして構文処理を継続
　します．

　<コマンド> は単一のコマンド名です．別名は効きません．<引数の並び> は <コ
　マンド> の引数となります．



nop

　何もしません．引数はすべて無視し，置換や展開も行いません．



onintr

　^C が押されたときには実行を停止するようにします．このコマンドはスクリプト
　内でのみ使用可能です．



onintr -

　^C が押されても次の行からの実行を継続するようにします．^C 自体を禁止する
　ものではありませんので注意してください．このコマンドはスクリプト内でのみ
　使用可能です．



onintr <ラベル>

　^C が押されたときに <ラベル> に跳ぶようにします．このコマンドはスクリプト
　内でのみ使用可能です．



popd [ -lvs ] [ +<N> ]

　ディレクトリ・スタックから要素を捨てます．


　popd

　　先頭の要素（現在の作業ディレクトリ）を捨てます．

　popd +<N>

　　<N>番目の要素を捨てます．<N> は 1 以上でなければなりません．


　最後にディレクトリ・スタックの内容が表示されます．

　エラーが無ければ，シェル変数 cwd と oldcwd，環境変数 PWD と OLDPWD が新た
　な値にセットされ，関数 cwdcmd がもし定義されていれば実行されます．



printf [ -2 ] [ -- ] <書式制御文字列> [ <単語> | <式> ] ...

　<書式制御文字列> による制御のもとで <単語> や <式> の値を変換して標準出力
　に出力します．-2オプションを指定すると標準出力ではなく標準エラー出力に出
　力します．<書式制御文字列> がオプション引数と認められてしまうケースは，
　<書式制御文字列> の直前に単語‘--’を置いて回避してください．

　<書式制御文字列> には次の 2つの種類のオブジェクトが含まれます．


　　●変換指示

　　●その他の，普通の文字の並び


　変換指示は，続く引数（<単語> または <式>）を変換した文字列を出力します．
　続く引数の数と，それぞれが <単語> であるべきか <式> であるべきかは，<書式
　制御文字列> に含まれる変換指示の数と種類に依存します．<書式制御文字列> の
　変換指示以外の部分は普通の文字の並びとしてそのまま出力されます．

　変換指示は‘%’で始まって変換操作記号で終わります．‘%’と変換操作記号と
　の間には次に示す項目が次に示す順序で置くことができます．


　●　フラグ文字

　　　以下のフラグを任意の順序で任意の組み合わせで使用することができます．
　　　1つも使用しなくてもかまいません．


　　　-         左詰めとします．このフラグを使用しなければ右詰めとなります．

　　　0         右詰めのとき，フィールドの隙間を‘0’で埋めます．このフラ
　　　　　　　　グを使用しなければスペースで埋められます．

　　　　　　　　　　数値変換（d,i,u,o,x,X）においては，符号や接頭辞はフィー
　　　　　　　　ルドの左端に寄せて出力され，数値の上位の桁が‘0’で埋められ
　　　　　　　　ます．

　　　+         符号つき整数変換のとき，必ず‘-’か‘+’のどちらかの符号を
　　　　　　　　つけます．

　　　スペース  符号つき整数変換のとき，必ず符号‘-’かスペースのどちらか
　　　　　　　　をつけます．

　　　#         各変換操作ごとに特別な変換フォーマットを使用します．


　●　最小フィールド幅

　　　フィールドの幅，すなわち少なくとも出力する文字（バイト）数を 10進表記
　　　の正整数で指示します．この表記は‘0’で始まるものであってはなりません．
　　　その‘0’は 0フラグと見なされてしまうからです．

　　　　　最小フィールド幅として‘*’を記述することもできます．そうすると引
　　　数から <式> が 1つ消費され，その <式> の値が最小フィールド幅となりま
　　　す．

　　　　　変換出力が最小フィールド幅よりも短い場合，変換出力は通常はその
　　　フィールドの右側に寄せて出力されます．このとき左側に生じる隙間部分に
　　　は通常はスペースが出力されます．0フラグを使用したときにはスペースの代
　　　わりに‘0’が出力されます．このとき，数値変換（d,i,u,o,x,X）において
　　　は，符号や接頭辞はフィールドの左端に寄せて出力され，数値の上位の桁が
　　　‘0’で埋められます．

　　　　　-フラグを使用したときには変換出力はフィールドの左側に寄せて出力さ
　　　れ，このとき右側に生じる隙間部分にはスペースが出力されます．

　　　　　変換出力が最小フィールド文字幅よりも長い場合には変換出力がそのま
　　　ま出力されます．最小フィールド幅の指示は省略可能です．省略した場合の
　　　デフォルトは 0 です．


　●　精度

　　　‘.’（ピリオド）に続けて，精度を表わす数値を 10進表記の正整数で指示
　　　します．ピリオドのみで，その後ろに数字が続いていない場合，精度は 0 と
　　　見なされます．精度を指定した場合の動作は各変換操作ごとに異なります．


　変換操作記号には次のものがあります．


　　　d   符号つき 10進変換．引数から <式> を 1つ消費し，その <式> の値を符
　　　　　号つき整数として 10進表記に変換して出力します．

　　　　　　　精度が指定されていなければ必要最小限の桁を変換します．精度が
　　　　　指定されているときには，少なくとも精度分の桁を変換します．

　　　　　　　値が負数ならば変換出力の先頭には符号‘-’がつきます．値が正数
　　　　　である場合，+フラグがあるならば符号‘+’がつきます．+フラグがなく
　　　　　スペースフラグがあるならばスペースがつきます．どちらのフラグもな
　　　　　ければ何もつきません．#フラグは何の効果もありません．

　　　i   d と同じです．

　　　u   符号なし 10進変換．引数から <式> を 1つ消費し，その <式> の値を符
　　　　　号なし整数として 10進表記に変換して出力します．

　　　　　　　精度が指定されていなければ必要最小限の桁を変換します．精度が
　　　　　指定されているときには，少なくとも精度分の桁を変換します．

　　　　　　　+，スペース，および #フラグは何の効果もありません．

　　　o   符号なし 8進変換．引数から <式> を 1つ消費し，その <式> の値を符
　　　　　号なし整数として 8進表記に変換して出力します．

　　　　　　　精度が指定されていなければ必要最小限の桁を変換します．精度が
　　　　　指定されているときには，少なくとも精度分の桁を変換します．

　　　　　　　#フラグを使用すると最初の桁の前に‘0’が付きます．この作用は
　　　　　引数の値や変換出力の結果によりません．引数の値が 0 である場合や変
　　　　　換出力の最初の桁が‘0’である場合にも，さらに‘0’が付くことにな
　　　　　ります．指定された精度はこの作用を除いて考えます．

　　　　　　　+ およびスペースフラグは何の効果もありません．

　　　x   符号なし 16進変換．引数から <式> を 1つ消費し，その <式> の値を符
　　　　　号なし整数として 16進表記に変換して出力します．桁として 012345678
　　　　　9abcdef を用います．

　　　　　　　精度が指定されていなければ必要最小限の桁を変換します．精度が
　　　　　指定されているときには，少なくとも精度分の桁を変換します．

　　　　　　　#フラグを使用すると最初に‘0x’が付きます．この作用は引数の値
　　　　　や変換出力の結果によりません．引数の値が 0 であっても‘0x’が付き
　　　　　ます．指定された精度はこの作用を除いて考えます．

　　　　　　　+ およびスペースフラグは何の効果もありません．

　　　X   符号なし 16進変換．引数から <式> を 1つ消費し，その <式> の値を符
　　　　　号なし整数として 16進表記に変換して出力します．桁として 012345678
　　　　　9ABCDEF を用います．

　　　　　　　精度が指定されていなければ必要最小限の桁を変換します．精度が
　　　　　指定されているときには，少なくとも精度分の桁を変換します．

　　　　　　　#フラグを使用すると最初に‘0X’がつきます．この作用は引数の値
　　　　　や変換出力の結果によりません．引数の値が 0 であっても‘0X’が付き
　　　　　ます．指定された精度はこの作用を除いて考えます．

　　　　　　　+ およびスペースフラグは何の効果もありません．

　　　c   <式> の値を 1バイト文字コードとして，その文字を出力します．引数か
　　　　　ら <式> が 1つ消費されます．

　　　　　　　精度は何の意味も持ちません．

　　　　　　　+，スペース，および #フラグは何の効果もありません．

　　　s   引数から <単語> を 1つ消費し，その <単語> を文字列として出力しま
　　　　　す．

　　　　　　　精度が指定されていなければ <単語> 全体を出力します．精度が指
　　　　　定されているときには，その精度（バイト数）分の文字を出力します．
　　　　　ただし <単語> の長さが <精度> よりも小さければ終わりまでを出力し
　　　　　ます．

　　　　　　　+，スペース，および #フラグは何の効果もありません．

　　　%   文字‘%’を出力します．引数は 1つも消費しません．

　　　　　　　精度は何の意味も持ちません．

　　　　　　　-フラグ，0フラグ，および最小フィールド幅はこの変換に対しても
　　　　　例外なく有効です．たとえば %05% は 0000% となります．

　　　　　　　+，スペース，および #フラグは何の効果もありません．


　<書式制御文字列> 中の文字は以下のエスケープ文字で表記することができます．


　　\a  ベル
　　\b  バックスペース
　　\f  改頁
　　\n  復帰改行
　　\r  復帰
　　\t  水平タブ
　　\v  垂直タブ

　　\d
　　\dd
　　\ddd

　　　　8進表記の文字コード（d は‘0’から‘7’までのいずれかの文字）

　　\xd
　　\xdd
　　\xddd

　　　　16進表記の文字コード（d は‘0’から‘9’まで，‘A’から‘F’まで，
　　　　‘a’から‘f’までのいずれかの文字）


　‘\’に続くシーケンスが上記のどれにも当てはまらないならば，‘\’は無視さ
　れます．

　文字‘\’は printf の実行を開始するよりも前に fish によって削除されること
　に注意してください．たとえば \n を printf に渡したいならば，\\n のように
　‘\’を‘\’でエスケープするか，または "\n"，'\n' のようにクオートしなけ
　ればなりません．ミスを減らすため，<書式制御文字列> 全体を常に‘"’または
　‘'’の対でクオートするのが良いでしょう．



pushd [ -lvs ] [ -- ] [ - | <名前> | +<N>[.] ]

　ディレクトリ・スタックを操作します．


　pushd

　　スタックの先頭の 2つの要素を交換します．これは pushd +1. と同じです．

　pushd -

　　直前の作業ディレクトリを新しい作業ディレクトリとしてスタックの先頭に積
　　みます．

　pushd <名前>

　　ディレクトリ <名前> を新しい作業ディレクトリとしてスタックの先頭に積み
　　ます．<名前> は cd <名前> の場合と同様に解釈されます．

　pushd +<N>[.]

　　ディレクトリ・スタックの <N>番目の要素が先頭（作業ディレクトリ）となる
　　よう操作します．スタックの先頭は 0番です．<N> は 1 以上でなければなりま
　　せん．+<N> の形式では，スタック全体を先頭に向かって <N>個分回転します．
　　+<N>. の形式では，<N>番目の要素を抜き出してスタックの先頭に積みます．


　これらの操作が完了した後には新しいディレクトリ・スタックの内容が表示され
　ます．ただしシェル変数 pushdsilent がセットされているかまたは -sオプショ
　ンが指定されている場合には表示されません．-lオプションと -vオプションは，
　この表示の形式を指定します．その意味は組み込みコマンド dirs と同じです．

　ディレクトリを指すシンボリック・リンクからの .. の解釈は，シェル変数
　symlinks によって制御されます．

　エラーが無ければ，シェル変数 cwd と oldcwd，環境変数 PWD と OLDPWD が新た
　な値にセットされ，関数 cwdcmd がもし定義されていれば実行されます．



pwd [ -l ]

　現在の作業ディレクトリを表示します．オプションの意味は組み込みコマンド
　dirs と同じです．



rehash

　コマンド検索ハッシュ表を更新してハッシュ機構をオンにします．



repeat <回数> <コマンド> [ <引数の並び> ]

　<コマンド> を <回数> だけ繰り返し実行します．

　<回数> は符号なし10進表記整数かまたは無限を表す‘oo’です．

　<コマンド> は単一のコマンドかまたはサブシェルです．別名は効きません．<引
　数の並び> は <コマンド> の引数となります．

　<回数> が 0 ならば <コマンド> は実行されませんが，組み込みコマンド repeat
　に対する入出力切り替えは行われることに注意してください．

　シェルが repeat を実行する時点では repeat の引数に対しては変数置換のみが
　行われます．<コマンド> と <引数の並び> に対するコマンド置換，組み合わせ展
　開，ディレクトリ置換，ファイル名展開は，repeat が <コマンド> を実行しよう
　とするたびに行われます．



return [ <式> ]

　<式> の値をシェル変数 status にセットして，シェルの入力を EOF とします．
　関数や組み込みコマンド source を実行しているときには，その実行を終了する
　ことになりますし，シェルの本来の入力を読み取って実行しているときには，そ
　のシェルそのものが終了することになります．シェル本体が終了するとき，それ
　がログイン・シェルであれば，組み込みコマンド logout が自動的に実行されま
　す．

　<式> を省略した場合には status はセットされず，0 のままとなります．

　なお，return は，即座に実行を終了するものではありません．


　　　return 69 ; echo bye bye


　では，return 実行後に status の値は 69 となりますが，次に echo を実行した
　後には status の値は 0 となります．


　　　return 69 ; goto label


　では，return 実行後にラベル label に跳びますので，結果的にシェルの入力は
　EOF とならず，したがって実行は終了しません．



set

　定義されているすべてのシェル変数の値を表示します．値の要素が 1個でなけれ
　ば，値は ( ) で囲まれた単語並びとして表示されます．



set <名前>
set <名前>=<単語>
set <名前>[<インデックス>]
set <名前>[<インデックス>]=<単語>
set <名前>=(<単語の並び>)

　1番目と 2番目の形式は，値として 1個の単語を持つシェル変数 <名前> を定義し
　ます．その値の単語は，1番目の形式では空文字列，2番目の形式では <単語> と
　なります．ただし 2番目の形式においても <単語> が無ければ値の単語は空文字
　列となります．

　3番目と 4番目の形式は，シェル変数 <名前> の <インデックス> 番目の要素に単
　語をセットします．シェル変数 <名前> はすでに定義されていなければならず，
　その要素数は <インデックス> 個以上でなければなりません．セットされる単語
　は，3番目の形式では空文字列，4番目の形式では <単語> です．ただし 4番目の
　形式においても <単語> が無ければ空文字列がセットされます．

　5番目の形式は，0個以上の単語の並びを値として持つシェル変数 <名前> を定義
　します．その値は <単語の並び> となります．‘(’や‘)’の前後には空白があっ
　ても無くてもかまいません．（いずれにしても fish はエスケープされていない
　‘(’や‘)’を 1個の独立した単語として扱います）．

　　　<名前> は 31バイト以下の単語です．<名前> の綴りは，ASCII英数字，‘_’
　（アンダースコア），シフトJISコードの組み合わせでなければならず，さらに，
　<名前> の先頭の文字は ASCII数字であってはなりません．

　　　いずれの形式においても，‘=’の前後に空白を置いて‘=’を独立した 1個
　の単語として記述することができます．だたし，それはあまり勧められません．

　　　これらの引数は，単一の set コマンド内で複数のセットを行うするために繰
　り返すことができます．



setenv

　定義されている環境変数をすべて表示します．



setenv <名前> [ <単語> ]

　環境変数 <名前> を定義し，その値を <単語> とします．<単語> がなければ値は
　空文字列になります．

　　　<名前> の綴りに文字‘=’を使用することはできません．



shift

　シェル変数 argv の要素を左に 1つシフトします．最初の要素は破棄されます．



shift <名前>

　シェル変数 <名前> の要素を左に 1つシフトします．最初の要素は破棄されます．



source [ -h ] [ -- ] <ファイル名> [ <引数の並び> ]

　スクリプト・ファイル <ファイル名> を現在のシェル上で実行します．ただし出
　力がパイプやファイルに切り替えられている場合にはサブシェル上で実行されま
　す．実行に先立って <引数の並び> がシェル変数 argv にセットされ，実行が終
　了すると argv の値は元に戻ります．スクリプト内の $0 は <ファイル名> に置
　き換えられます．

　-hオプションを指定すると，スクリプトからの入力行を解釈／実行せずに履歴リ
　ストに登録します．

　<ファイル名> として '-' を指定すると標準入力から読み取ります．たとえば


　　　make -n | source -


　は make が実行するであろうコマンドを make ではなく fish で実行します．ま
　た，


　　　make -n | source -h -


　とすれば make が実行するであろうコマンドが履歴リストに登録されます．それ
　を


　　　history -x <N>-<M> | source -


　で実行したり，あるいは行編集機能 up-history を用いて編集してから実行する
　ことができます．



srand [ <種> ]

　乱数 $, の新しい系列の種として <種> を使用します．<種> は 0 以上 32767 以
　下の符号なし 10進表記整数です．<種> を省略すると，マシン起動からの経過時
　間が種として使用されます．最初の種は 1 です．



time

　現在の fish を起動してから経過した時間を表示します．



time <コマンド> [ <引数の並び> ]

　<コマンド> を実行し，コマンドが消費した時間を表示します．

　<コマンド> は単一のコマンド名です．別名は効きません．<引数の並び> は <コ
　マンド> の引数となります．

　time の表示は常にシェルの標準出力に対して行われます．time コマンドの出力
　をパイプやファイルに切り替えた場合，<コマンド> の出力は切り替わりますが，
　time コマンドの出力先は切り替わりません．time コマンドの出力も切り替えた
　い場合には time コマンドをサブシェルで実行する必要があります．

　シェルが time を実行する時点では time の引数に対しては変数置換のみが行わ
　れます．<コマンド> と <引数の並び> に対するコマンド置換，組み合わせ展開，
　ディレクトリ置換，ファイル名展開は，time が <コマンド> を実行しようとする
　たびに行われます．

　（例）

　　　　　( time foo > file1 ) > file2

　　　は，コマンド foo の出力を file1 に切り替えて foo を実行し，foo が消費
　　　した時間を file2 に出力します．



unalias <パターン> ...

　<パターン> にマッチする別名をすべて取り消します．<パターン> にマッチする
　別名が定義されていなくてもエラーにはなりません．

　　　単一の unalias コマンドで複数の取り消しを行うために複数の <パターン>
　を並べることができます．



undefun <パターン> ...

　<パターン> にマッチする名前の関数をすべて削除します．<パターン> にマッチ
　する名前の関数が定義されていなくてもエラーにはなりません．

　　　単一の undefun コマンドで複数の削除を行うために複数の <パターン> を並
　べることができます．



unhash

　コマンド検索のハッシュ機構をオフにします．



unset <パターン> ...

　<パターン> にマッチする名前のシェル変数をすべて削除します．<パターン> に
　マッチする名前のシェル変数がセットされていなくてもエラーにはなりません．

　　　単一の unset コマンドで複数の削除を行うために複数の <パターン> を並べ
　ることができます．



unsetenv <名前> ...

　環境変数 <名前> を削除します．環境変数 <名前> がセットされていなくてもエ
　ラーにはなりません．

　　　単一の unsetenv コマンドで複数の削除を行うために複数の <名前> を並べ
　ることができます．



which [ -a ] [ -o | -O ] [ -t | -p ] [ -- ] <コマンド名> ...

　<コマンド名> をコマンドとして検索して，その実体を答えます．次の 3つの項目
　が次の順に検索されます．


　　●別名

　　　　　　ただしシェル変数 noalias がセットされているときには別名は検索さ
　　　　　　れません．

　　●関数

　　●ディスク上の実行可能ファイル（または組み込みコマンド）

　　　　　　<コマンド名> がディレクトリ名を含んでいないならば，シェル変数
　　　　　　path にセットされている各ディレクトリ下の実行可能ファイルが検索
　　　　　　されます．


　組み込みコマンドは仮想ディレクトリ‘~~’下のファイルとして検索されます．

　　　通常は最初に見つかったものだけを答えますが，-aオプションを指定すると
　見つかってもなお検索を続行し，見つかったものすべてを出力します．ただし 1
　つのディレクトリ下で検索される実行可能ファイルは 1つです．

　　　-oオプションを指定すると別名は除外されます．-Oオプションを指定すると
　さらに関数と組み込みコマンドも除外され，ディスク上の実行可能ファイルのみ
　が検索されます．

　　　which の出力は通常は平文の形をしており，別名や関数ならばその内容も出
　力されますが，-tオプションを指定すると次のシンプルな単語のみを出力します．


　　　alias      別名である場合
　　　function   関数である場合
　　　builtin    組み込みコマンドである場合
　　　file       ディスク上の実行可能ファイルである場合


　コマンドがどこにも見当たらなかった場合には何も出力しません．

　　　-pオプションを指定すると，ディスク上の実行ファイルである場合にはその
　パス名のみを出力します．それ以外である場合には何も出力しません．

　　　<コマンド名> は複数並べることができます．ただし，-pオプションを指定し
　ているときには，出力と <コマンド名> との対応がわかりにくく，-tオプション
　を指定しているときにはほとんどわからないことでしょう．

　　　最初の <コマンド名> がオプション引数と認められてしまうケースで，最初
　の<コマンド名> の直前に単語‘--’を置いて回避してください．



xargs [ -n<単語数> | -l[<行数>] | -i[<被置換文字列>] ]
　　　[ -tpx ] [ -s<サイズ> ] [ -e[<EOF単語>] ] [ -- ]
　　　[ <コマンド> [ <引数の並び> ] ]

　<コマンド> と <引数の並び> に標準入力から読み取った引数を加えてコマンド行
　を生成し実行します．

　<コマンド> は単一のコマンド名です．別名は効きません．<コマンド> を省略し
　た場合のデフォルトは '~~/echo' '--' です．

　生成するコマンド行のサイズは，<コマンド> と <引数の並び> の分を含めて4096
　バイトに制限されています．この限度は -sオプションによって変更することがで
　きます．

　コマンド行の生成規則は -nオプション，-lオプション，-iオプションのいずれか
　で指定します．複数を指定すると最後の指定が有効となります．いずれも指定し
　なければ -n2048 がデフォルトとなります．それぞれのオプションについて説明
　します．

　-n<単語数>          標準入力からのデータを，ナル(0x00)，スペース，水平タ
　                    ブ(0x09)，改行(0x0a)，または復帰改行(0x0d,0x0a)を区切
　                    りとして単語に分解し，1回あたり <単語数>分の単語を読
　                    み取って，そのすべての単語を（1単語を 1引数として）
　                    <引数の並び> の後ろに加えます．

　                    入力が <単語数> に満たないうちに EOF に到達した場合は，
　                    それまでに読み取った分を使用します．

　                    生成したコマンド行のサイズが限度を超える場合，通常は
　                    サイズの限度を超える分の引数単語を次回に持ち越します．
　                    -xオプションは，その場合をエラーとします．

　-l[<行数>]          標準入力から 1回あたり <行数>分のデータを入力し，ナル
　                    (0x00)，スペース，水平タブ(0x09)，改行(0x0a)，または
　                    復帰改行(0x0d,0x0a) を区切りとして単語に分解して，そ
　                    のすべての単語を（1単語を 1引数として） <引数の並び>
　                    の後ろに加えます．<行数> のデフォルトは 1 です．

　                    改行までが 1行として数えられます．ただし空の行は行数
　                    に数えずに無視されます．改行の直前が空白文字（スペー
　                    スか水平タブ）である場合には，続く空でない行をまとめ
　                    て 1行として数えます．

　                    入力が <行数>に満たないうちに EOF に到達した場合は，
　                    最後の改行までを使用します．最後の改行から EOF までの
　                    データは捨てられます．

　                    -lオプションを使用すると，自動的に -xオプションも指定
　                    したことになり，生成したコマンド行のサイズが限度を超
　                    える場合はエラーとなります．

　-i[<被置換文字列>]  (Insert mode) 標準入力から 1回あたり 1単語を入力して，
　                    <引数の並び> に含まれる <被置換文字列> をすべてその単
　                    語に置き換えます．<被置換文字列> のデフォルトは‘{}’
　                    です．

　                    -iオプションでは，最初に現れる空白以外の文字から，次
　                    に現れる改行の直前までのデータが 1単語となります．最
　                    後の改行から EOF までのデータは捨てられます．

　                    -iオプションを使用すると，自動的に -xオプションも指定
　                    したことになり，生成したコマンド行のサイズが限度を超
　                    える場合はエラーとなります．

　コマンド行の生成と実行は標準入力が EOF に到達するまで繰り返されます．デフォ
　ルトでは，物理的な EOF の他に，単語‘_’も論理的に EOF と見なされます．
　EOF単語は -eオプションによって変更することができます．

　標準入力からのデータ中に，単一引用符‘'’または二重引用符‘"’による囲み
　があれば，その中の文字はすべて単語の一部となります．ただしナル(0x00) と改
　行(0x0a) は引用符で囲むことはできません．引用符による囲みの外のバック・ス
　ラッシュ‘\’は，続く文字をエスケープして単語の一部とします．ただしナルを
　バック・スラッシュでエスケープすることはできません．

　生成されたコマンド行の実行時には，一切の置換・展開は行われません．

　その他のオプションには次のものがあります．

　-t             (Trace mode) 生成したコマンド行を実行する前に標準エラー出
　               力に表示します．

　-p             (Prompt mode) 生成したコマンド行を実行する前に標準エラー出
　               力に表示し，実行するかどうかを問い合わせます．ここで‘y’
　               で始まる行を入力すると実行が行われ，それ以外の入力ではスキッ
　               プされます．

　-x             生成コマンド行の長さが制限を超える場合をエラーとします．

　-s<サイズ>     生成コマンド行（<コマンド> と <引数の並び> の分を含む）の
　               長さの限度を <サイズ> とします．<サイズ> は 0から4096の範
　               囲でなければなりません．-sオプションを指定しない場合のデフォ
　               ルトは 4096 です．

　-e[<EOF単語>]  <EOF単語> を論理的な EOF とします．<EOF単語> を省略すると，
　               物理的な EOF のみが入力の終わりとなります．-eオプションを
　               指定しないと，単語‘_’が論理的な EOF単語となります．

　なお，-n，-l，-i，-s，-eオプションと，それに対するオプション引数との間に
　は空白を置くことはできません．

　（例）

　　　　xargs ED < filelist

　　は，filelist に記述されているすべてのファイルをすべてエディタに読み込み
　　ます．たとえば filelist の内容が

　　　　main.c main.h
　　　　  sub.c sub.h
　　　　 misc.c

　　であれば，

　　　　ED main.c main.h sub.c sub.h misc.c

　　というコマンド行が生成され実行されることになります．Ｃソース・ファイル
　　のみが必要ならば

　　　　xargs -n1 < filelist | grep '\.c$' | xargs ED

　　とすると良いでしょう．もし ED が 1度に18個を超えるファイルを読み込むこ
　　とができないなら

　　　　xargs -n18 ED < filelist

　　とすれば，最大18ファイルずつに分けて実行されます．

　　　　( echo $user ; pwd ; date ; echo "$0 $*" ) | xargs > logfile

　　は，コマンド・グループ内の出力を 1行にまとめて logfile に書き出します．

　　　　ls $1 | xargs -i mv "$1/{}" "$1/{}.old"

　　は，$1 ディレクトリ内のすべてのファイル名にサフィックス‘.old’を加えま
　　す．

　　　　xargs -n2 << EOF
　　　　  chap1.old chap1.new
　　　　  chap2.old
　　　　    chap2.new
　　　　EOF

　　は，chap1〜3 のそれぞれについて，新旧ファイルを比較します．これは

　　　　apply -2 diff chap1.old chap1.new chap2.old chap2.new

　　と同じ結果となります．

　　　　ls | xargs -l -p LHA a archive.LZH

　　は，作業ディレクトリ内のファイルを 1つずつ選択的にアーカイブします．

　　　　ls | xargs -l -p | xargs LHA a archive.LZH

　　は，アーカイブするかどうかを 1つ 1つ選択した後，選択したファイルを一気
　　にアーカイブします．



■
■  行入力編集機構
■


　fish は編集機能を持つ独自の行入力編集機構を持っています．fish の入力が端
末であって，かつシェル変数 usegets がセットされていなければ，この独自の行入
力編集機構が働きます．

　この独自の行入力編集機構は現在のところ X68000 CON に依存しており，その他
の端末では表示がおかしくなることがあります．

　fish の行入力編集機構では，端末から入力されるすべてのコードに「機能」がバ
インドされています．各コードの機能は，組み込みコマンド bind で自由に変更す
ることができます．

　以下に，各機能について解説します．


abort

　　行入力を中止し，^C 処理に跳びます．


accept-line

　　編集行の内容を 1物理行としてシェルに渡します．行末には改行コード(0x0a)
　　が自動的に付加されます．


backward-char

　　カーソルを直前の文字（もしあれば）に移動します．


backward-word

　　カーソルを直前の‘単語の先頭’（なければ行の先頭）に移動します．


beginning-of-line

　　カーソルを行の先頭に移動します．


capitalize-word

　　カーソルの位置からその直後の‘単語の終わり’までの範囲に ASCII英文字が
    あれば，その最初の 1文字を ASCII英大文字に変換し，残りの ASCII英文字を
    すべて ASCII英小文字に変換します．カーソルは‘単語の終わり’の次の位置
    に移動します．


change-case

　　カーソルの位置の文字が ASCII英小文字ならば ASCII英大文字に，ASCII英大文
　　字ならば ASCII英小文字に変換します．カーソルは続く文字（もしあれば）の
　　位置に移動します．


clear-and-redraw

　　画面をクリアして編集行を書き直します．


complete

　　カーソルの直前までの文字列を補完して，変数名／ユーザ名／コマンド名／ファ
　　イル名／組み込みコマンド名を完成させます．

　　fish は補完のケースを次の順に調べて自動的に候補対象を選択します（ただし
　　判定は必ずしも完璧ではありません）．


　　● 変数名補完

　　　　補完させる文字列が変数置換における変数名と見なし得る場合には変数名
　　　　補完が行われます．変数名に‘{’が先行している場合，変数名が完成した
　　　　とき，シェル変数 addsuffix がセットされているならば‘}’が自動的に
　　　　付加されます．


　　● ユーザ名補完

　　　　（シェル変数 noglob がセットされていなければ）補完させる文字列がディ
　　　　レクトリ置換におけるユーザ名と見なし得る場合にはユーザ名補完が行わ
　　　　れます．シェル変数 addsuffix がセットされているならば，名前が完全に
　　　　完成したとき，その末尾に‘/’が付加されます．


　　● コマンド名補完

　　　　補完させる文字列がコマンド名として解釈され得る位置にある場合にはコ
　　　　マンド名補完が行われます．

　　　　このとき補完させる文字列がドライブ名／ディレクトリ名を含んでいなけ
　　　　れば，（シェル変数 noalias がセットされていなければ）別名，関数，お
　　　　よびシェル変数 path にセットされている各ディレクトリ下のファイル名
　　　　が候補となります．もちろん，path に‘~~’が 1要素としてセットされて
　　　　いれば組み込みコマンド名も候補となります．さらに，補完させる文字列
　　　　が特別な構文のキーワードとして解析される位置にある場合には，特別な
　　　　構文のキーワード（foreach など）も候補となります．path に‘.’が 1
　　　　要素としてセットされていれば現在の作業ディレクトリ下のディレクトリ
　　　　名も候補に加わります．

　　　　通常，path の各ディレクトリのうち完全パスで示されたディレクトリ下の
　　　　ファイル（ボリュームラベルは除く）については，実行可能であるかどう
　　　　かは検査されず無条件に候補となります．これは処理を高速に行うためで
　　　　す．シェル変数 reconlyexec をセットしておくと，実行可能ファイルのみ
　　　　が候補となりますが，候補の検索はやや遅くなります．path の各ディレク
　　　　トリのうち相対パスで示されたディレクトリ下のファイルについては常に
　　　　実行可能ファイルのみが候補となります．したがって path に相対パスが
　　　　多く含まれるとコマンド検索は遅くなります．

　　　　補完させる文字列がドライブ名／ディレクトリ名を含んでいる場合には，
　　　　そのディレクトリ下の実行可能ファイル名およびディレクトリ名が候補と
　　　　なります．補完させる文字列が‘~~/’で始まっている場合は組み込みコマ
　　　　ンド名が候補となります．

　　　　ディスク上のファイルでは次のものが実行可能と判定されます．

　　　　　● 実行可能属性（属性の第7ビット）が ON であるファイル

　　　　　● 拡張子が .R，.X，.BAT（大文字と小文字は区別しない）のいずれか
　　　　　　 であるファイル

　　　　補完させる文字列が空文字列である場合には，コマンド名補完はおそらく
　　　　かなりの時間がかかります．そのため，これを予防する機構が用意されて
　　　　います．シェル変数 nonullcommandc をセットしておくと，空文字列では
　　　　コマンド名補完は行われず，代わりに通常のファイル名補完が行われます．

　　　　シェル変数 addsuffix がセットされているならば，ディレクトリ名が完成
　　　　したときには‘/’が，コマンド・ファイル名が完成したときには‘ ’（
　　　　スペース）が，完成した名前の末尾に付加されます．

　　　　コマンド名補完は fish のコマンド解釈・検索機構やハッシュ機構とは無
　　　　関係に行われますので，補完したコマンドが必ず実行できる保証はありま
　　　　せん．


　　● ファイル名補完

　　　　補完する文字列が上記のいずれのケースにも当てはまらなければ，ディス
　　　　ク上のファイル名として補完します．もちろん，補完する文字列が‘~~/’
　　　　で始まっている場合には組み込みコマンド名が候補となります．

　　　　シェル変数 addsuffix がセットされているならば，ディレクトリ名が完成
　　　　したときには‘/’が，それ以外の名前が完成したときには‘ ’（スペー
　　　　ス）が，完成した名前の末尾に付加されます．


　　コマンド名補完およびファイル名補完においては，（シェル変数 noglob がセッ
　　トされていなければ）fish は補完する文字列を予め一時的にディレクトリ置換
　　してから検索しますので，~/bar，~foo/bar，=2/bar，../bar といった文字列
　　も期待どおりに補完されます．なお，‘=’で始まって‘/’も‘\’も含まない
　　単語に対して補完を行うと，dirs -lv と同じ表示が行われます．

　　通常，ディスク上のファイル名の大文字と小文字は区別されますが，シェル変
　　数 cifilec をセットしておけば区別はされなくなります．ただし，ファイル名
　　の大文字と小文字を区別するシステムでは，補完するパスの途中のディレクト
　　リ名の大文字と小文字は必ず区別されます．

　　シェル変数 showdots がセットされていなければ，ディスク上のディレクトリ・
　　エントリのうち‘.’で始まる名前は‘.’を明示的に入力しない限り候補から
　　除外されます．showdots がセットされていると決して除外されません．ただし，
　　showdots に‘-A’がセットされている場合には，ディレクトリ・エントリ‘.’
　　と‘..’は（たとえそれが明示的に入力されても）常に除外されます．

　　ボリューム・ラベルは常に検索対象から除外されます．

　　補完できる名前の候補が 1つもなければ，通常，ベルが鳴ります．候補が 2つ
　　以上ある場合には，いずれにも共通な部分のみを補い，通常はベルを鳴らしま
　　す．

　　シェル変数 recexact がセットされていると，入力に完全に一致していて 1文
　　字も補う必要のない候補があればそれで完成とし，それより長い名前の候補が
　　あっても無視します．その場合には通常はベルは鳴りません．

　　ベルの鳴る条件はシェル変数 matchbeep と nobeep とで制御することができま
　　す．

　　無視したいサフィックスの列をシェル変数 fignore にセットしておくことによ
　　り，特定のサフィックスを持ったファイルを候補対象から除外することができ
　　ます．ただし，与えられた文字列から完成できる唯一の名前が fignore で除外
　　されているものでしか特定できない場合には，これらのサフィックスを無視し
　　ません．

    補完は ^C により中止することができます．ただし編集行の内容はすべてキャ
    ンセルされます．


copy-prev-word

　　カーソルの直前の‘単語の先頭’（なければ行の先頭）からカーソルの直前ま
　　でをカーソル位置に挿入します．


copy-region

　　マークとカーソルとの間をカット・バッファにコピーします．


delete-backward-char

　　カーソルの直前の文字（もしあれば）を削除します．


delete-forward-char

　　カーソルの位置の文字（もしあれば）を削除します．


delete-forward-char-or-list

　　カーソルが行末にあるときには list 機能が，そうでなければ delete-forward-
    char 機能が働きます．


delete-forward-char-or-list-or-eof

　　編集行が空のときには eof 機能が，そうでなければ delete-forward-char-or-
　　list 機能が働きます．


down-history

　　履歴リストを，より新しい方向に 1行下って編集行に取り込みます．履歴リス
　　トの最新のイベントの次には元の新規入力行が現れます．そこから先には下り
　　ません（ベルが鳴ります）．


downcase-char

　　カーソルの位置の文字が ASCII英大文字ならば ASCII英小文字に変換します．
    カーソルは続く文字（もしあれば）の位置に移動します．


downcase-region

　　マークとカーソルとの間に ASCII英大文字があればすべて ASCII英小文字に変
    換します．


downcase-word

　　カーソルの位置からその直後の‘単語の終わり’までに ASCII英大文字があれ
    ばすべて ASCII英小文字に変換します．カーソルは‘単語の終わり’の次の位
    置に移動します．


end-of-line

　　カーソルを行末に移動します．


eof

　　EOF を入力します．編集行の内容は破棄されます．


error

　　エラー．prefix-1，prefix-2，qouted-insert 等はキャンセルされます．また，
　　シェル変数 nobeep がセットされていない場合にはベルが鳴ります．


eval-command

　　バインドされている文字列をシェルの入力行として解析し，現在のシェル上で
　　実行します．編集行の内容は保存されます．


exchange-point-and-mark

　　マークとカーソルの位置を交換します．


forward-char

　　カーソルを直後の文字（もしあれば）に移動します．


forward-word

　　カーソルを直後の‘単語の終わり’の直後（なければ行末）に移動します．


history-search-backward

　　編集行の先頭からカーソル位置までの部分が一致する行を履歴リストから昇順
　　（古くなる方向）に検索し，見つかった行を編集行に取り込みます．ただし，
　　もし見つかった行の内容が現在の編集行の内容と同じであった場合には，さら
　　に検索を進めます．履歴リストの最古のイベントまでの間に見つからなければ
　　ベルが鳴ります．


history-search-backward-circular

　　history-search-backward と同じですが，見つからずにベルが鳴った後さらに
　　実行すると，元の新規入力行から始まって履歴リストを昇順に再び検索します．


history-search-forward

　　編集行の先頭からカーソル位置までの部分が一致する行を履歴リストから降順
　　（新しくなる方向）に検索し，見つかった行を編集行に取り込みます．ただし，
　　もし見つかった行の内容が現在の編集行の内容と同じであった場合には，さら
　　に検索を進めます．履歴リストの最新イベントの次には元の新規入力行が続い
　　ています．そこまでの間に見つからなければベルが鳴ります．


history-search-forward-circular

　　history-search-forward と同じですが，見つからずにベルが鳴った後さらに実
　　行すると，履歴リストの最古のイベントから降順に再び検索します．


insert-last-word

　　直前の履歴イベントの最後の単語をカーソル位置に挿入します．ただし直前の
　　履歴イベントの単語数が 2個未満であるときには何もしません．


keyboard-quit

　　編集行を消去します．


kill-backward-word

　　カーソルの直前の‘単語の先頭’（なければ行の先頭）からカーソルの直前ま
　　でを削除してカット・バッファにコピーします．


kill-forward-word

　　カーソルの位置から直後の‘単語の終わり’（なければ行末）までを削除して
　　カット・バッファにコピーします．


kill-region

　　マークとカーソルとの間を削除してカット・バッファにコピーします．


kill-to-bol

　　行の先頭からカーソルの直前までを削除してカット・バッファにコピーします．


kill-to-eol

　　カーソルの位置から行末までを削除してカット・バッファにコピーします．


kill-whole-line

　　現在の編集行の内容をまるごと削除してカット・バッファにコピーします．


　　　　　　　　　　　　以上の kill- 機能を連続して使用すると，2回目以降は
　　　　　　　　　　　　カット・バッファがクリアされることなく削除文字列が
　　　　　　　　　　　　カット・バッファに追加されます．


list

　　現在の状態での，機能 complete の候補を文字コード順にソートして表示しま
　　す．ここではシェル変数 fignore は効きません．

　　ファイル名／コマンド名補完（ディレクトリ指定の無いコマンド名補完は除く）
　　においては，各候補名には以下のようにファイルのタイプを表す文字が付加表
　　示されます．

　　ディレクトリは‘/’つきで表示されます．

　　シンボリック・リンクは通常は‘@’つきで表示されます．シェル変数
　　listlinks がセットされていると，ディレクトリへのシンボリック・リンクは
　　‘>’つきで，実体の無いシンボリック・リンクは‘&’つきで表示されます．

　　シェル変数 listexec がセットされていると，次の実行可能エントリは‘*’つ
　　きで表示されます．

　　　● 組み込みコマンド

　　　● 実行可能属性が ON であるファイル

　　　● 拡張子が .R，.X，.BAT（大文字と小文字は区別しない）のいずれかであ
　　　　 るファイル


list-or-eof

　　編集行が空のときには eof 機能が，それ以外の場合には list 機能が働きます．


macro

　　バインドされている文字列を，あたかもユーザがタイプしたかのように入力し
　　ます．


next-word

　　カーソルを直後の‘単語の先頭’（なければ行末）に移動します．


no-op

　　何もしません．kill- 機能の途中に使用されても，その連続性を断ちません．


prefix-1

　　prefix-1 シーケンスを導きます．たとえば


　　　　bind ^[ prefix-1
　　　　bind -1 ^L clear-and-redraw


　　と設定すると，ESC ^L の 2ストロークで，clear-and-redraw 機能が働くこと
　　になります．


prefix-2

　　prefix-2 シーケンスを導きます．たとえば


　　　　bind ^X prefix-2
　　　　bind -2 ^L downcase-region


　　と設定すると，^X ^L の 2ストロークで，downcase-region 機能が働くことに
　　なります．


quit-history

　　履歴リストを抜け出し，編集行の内容を元の新規入力行に戻します．


quoted-insert

　　次に入力されるキャラクタを，通常の文字として編集行に挿入します．


redraw

　　改行して編集行を書き直します．


search-character

　　次に入力されるキャラクタを，カーソルの直後から行末までの中で検索し，も
　　し見つかればカーソルをそこに移動します．見つからなかったならば，編集行
　　の先頭から再び検索します．


self-insert

　　自分自身を編集行に挿入します．


set-mark

　　カーソル位置をマークします．


transpose-chars

　　カーソルの位置の文字と直前の文字とを入れ換えます．ただしカーソルが行末
　　にあるときには，カーソルの直前の 2文字を入れ換えます．いずれの場合にも
　　カーソルは入れ換えた 2文字の直後に移動します．


transpose-gosling

　　カーソルの直前の 2文字を入れ換えます．カーソルは移動しません．


transpose-words

　　カーソルの直前の単語とその直後の単語とを入れ換えます．ただし「その直後
　　の単語」がない場合には，カーソルの直前の 2単語を入れ換えます．いずれの
　　場合にもカーソルは入れ換えた 2単語の直後に移動します．


up-history

　　履歴リストを 1行遡って編集行に取り込みます．履歴リストの最古のイベント
　　からは，それ以上遡りません（ベルが鳴ります）．


upcase-char

　　カーソルの位置の文字が ASCII英小文字ならば ASCII英大文字に変換します．
    カーソルは続く文字（もしあれば）の位置に移動します．


upcase-region

　　マークとカーソルとの間に ASCII英小文字があればすべて ASCII英大文字に変
    換します．


upcase-word

　　カーソルの位置からその直後の‘単語の終わり’までに ASCII英小文字があれ
    ばすべて ASCII英大文字に変換します．カーソルは‘単語の終わり’の次の位
    置に移動します．


yank

　　カット・バッファの内容をカーソルの位置に挿入します．


　各機能において，「単語」は ASCII英数字，シフトJIS文字，およびシェル変数
wordchars にセットされている文字（wordchars がセットされていなければ
*?_-.[]~=）を任意に綴った文字列です．fish の単語分け処理とは無関係であるこ
とに注意してください．


　fish 起動時や bind default が実行されたとき，各入力コードには次の機能がバ
インドされます．


　　　　　^@                      set-mark
　　　　　^A                      beginning-of-line
　　　　　^B                      backward-char
　　　　　^C                      abort
　　　　　^D                      delete-forward-char-or-list-or-eof
　　　　　^E                      end-of-line
　　　　　^F                      forward-char
　　　　　^G                      error
　　　　　^H                      delete-backward-char
　　　　　^I                      complete
　　　　　^J                      accept-line
　　　　　^K                      kill-to-eol
　　　　　^L                      clear-and-redraw
　　　　　^M                      accept-line
　　　　　^N                      down-history
　　　　　^P                      up-history
　　　　　^Q                      quoted-insert
　　　　　^R                      redraw
　　　　　^T                      transpose-chars
　　　　　^U                      kill-whole-line
　　　　　^V                      quoted-insert
　　　　　^W                      kill-region
　　　　　^X                      prefix-2
　　　　　^Y                      yank
　　　　　^[                      prefix-1
　　　　　^?                      delete-backward-char
　　　　　その他                  self-insert

　　　　　prefix-1 ^D             list
　　　　　prefix-1 ^H             kill-backward-word
　　　　　prefix-1 ^I             complete
　　　　　prefix-1 ^L             clear-and-redraw
　　　　　prefix-1 ^[             complete
　　　　　prefix-1 ^_             copy-prev-word
　　　　　prefix-1                set-mark
　　　　　prefix-1 >              quit-history
　　　　　prefix-1 B              backward-word
　　　　　prefix-1 C              capitalize-word
　　　　　prefix-1 D              kill-forward-word
　　　　　prefix-1 F              forward-word
　　　　　prefix-1 L              downcase-word
　　　　　prefix-1 N              history-search-forward-circular
　　　　　prefix-1 P              history-search-backward-circular
　　　　　prefix-1 T              transpose-words
　　　　　prefix-1 U              upcase-word
　　　　　prefix-1 W              copy-region
　　　　　prefix-1 _              insert-last-word
　　　　　prefix-1 b              backward-word
　　　　　prefix-1 c              capitalize-word
　　　　　prefix-1 d              kill-forward-word
　　　　　prefix-1 f              forward-word
　　　　　prefix-1 l              downcase-word
　　　　　prefix-1 n              history-search-forward
　　　　　prefix-1 p              history-search-backward
　　　　　prefix-1 t              transpose-words
　　　　　prefix-1 u              upcase-word
　　　　　prefix-1 w              copy-region
　　　　　prefix-1 ^?             kill-backward-word
　　　　　prefix-1 その他         error

　　　　　prefix-2 ^D             list-raw
　　　　　prefix-2 ^I             complete-raw
　　　　　prefix-2 ^L             downcase-region
　　　　　prefix-2 ^U             upcase-region
　　　　　prefix-2 ^X             exchange-point-and-mark
　　　　　prefix-2 その他         error



■
■　特別な関数
■


cwdcmd

　定義しておくと，作業ディレクトリが再設定されたとき自動的に実行されます．
　引数は与えられません．

　（例）次のように定義しておくと，作業ディレクトリを別のドライブに移動した
　　　　ときに元のドライブのカレント・ディレクトリが自動的に / になります．

　　　　　　function cwdcmd() {
　　　　　　    if ($cwd:d != $oldcwd:d) ~~/cdd ${oldcwd:d}:/
　　　　　　}

　【注意】この関数の中で作業ディレクトリを再設定すると，その時点でまたこの
　　　　　関数が再帰的に呼び出されることになり，無限ループが生成されてしま
　　　　　います．そのようなケースは

　　　　　　function cwdcmd() {
　　　　　　    if ($?in_cwdcmd) return
　　　　　　    set in_cwdcmd
　　　　　　        . . .
　　　　　　    unset in_cwdcmd
　　　　　　}

　　　　　のようにして回避するのが良いでしょう．



■
■  特別なシェル変数
■


FISH_AUTHOR

　fish の作者の氏名．fish 起動時に自動的にセットされます．


FISH_COPYRIGHT

　fish の版権告示．fish 起動時に自動的にセットされます．


FISH_VERSION

　fish のバージョン番号．fish 起動時に自動的にセットされます．
　$@FISH_VERSION[1] はメジャー番号，
　$@FISH_VERSION[2] はマイナー番号，
　$@FISH_VERSION[3] はパッチレベルを示しています．


addsuffix

　セットしておくと，行編集機能 complete によって名前が完全に完成したとき，
　その名前がディレクトリを示すものならば‘/’が，それ以外の場合には‘ ’（
　スペース）が名前の後ろに自動的に付加されるようになります．名前がシンボリッ
　ク・リンクである場合は，その参照ファイルの属性が調べられます．

　addsuffix=exact では，名前が完成した時点ではこの機能は働かず，完成してい
　る名前に対してさらに補完を行ったときに働くようになります．


argv

　fish 起動時，fish に与えられた引数のうち，オプション引数とスクリプト・ファ
　イル名の指定とを除いた残りの引数が自動的にセットされます．関数実行時には
　関数に与えられた引数が自動的にセットされます．


autolist

　セットしておくと，行編集機能 complete や complete-raw で候補が複数あると
　自動的に候補の一覧を表示します．


batshell

　最初の要素は，拡張子が .BAT（大文字と小文字は区別されません）であるスクリ
　プト・コマンドを実行するために起動するインタープリタ名．fish 起動時の初期
　値は‘COMMAND’．2番目以降の要素はインタープリタに先行して渡す引数．初期
　値は空．


cdcmds

　作業ディレクトリの変更を許すコマンド・ファイルのファイル名（ドライブやディ
　レクトリ名は含まない）のパターンの並び．大文字と小文字は区別されます．


cdpath

　ディレクトリ移動の代替パスの並び．


ciglob

　セットしておくと，ファイル名展開時にディレクトリ名やファイル名の大文字と
　小文字を区別しません．


cifilec

　セットしておくと，行編集機能 complete と list でファイル名の大文字と小文
　字を区別しません．ただし，ファイル名の大文字と小文字を区別するシステム上
　では，補完するパスの途中のディレクトリ名の大文字と小文字は必ず区別されま
　す．


cwd

　現在の作業ディレクトリの（ドライブ名つきの）完全パス名．fish 起動時や作業
　ディレクトリ変更時に自動的にセットされます．そのとき環境変数 PWD にも同じ
　値がセットされます．ディレクトリの区切り文字は‘/’です．シンボリック・リ
　ンクとの関係はシェル変数 symlinks によって制御されます．


echo

　セットしておくと，コマンドを実行する直前に，そのコマンドを標準エラー出力
　に出力します．この出力が行われるのはコマンドの標準入出力を切り替えた後で
　あることに注意してください．コマンドの標準エラー出力をファイルに切り替え
　ていれば，この出力は端末ではなくそのファイルに出力されることになります．


envcmds

　fish の環境変数の変更を許すコマンド・ファイルのファイル名（ドライブやディ
　レクトリ名は含まない）のパターンの並び．大文字と小文字は区別されます．


envmargin

　子プロセスに渡す環境変数エリアに用意する余白のバイト数（10進表記）．


fignore

　行編集機能 complete で無視するサフィックスの並び．シェル変数 cifilec が
　セットされている場合には大文字と小文字は区別されません．


forceio

　セットしておくと，入出力切り替え先デバイスの入力ステータス／出力ステータ
　スを無視します．


gid

　ユーザのグループid．fish 起動時に環境変数 GID の値で初期設定されます．


globdotA

　セットしておくと，ファイル名展開において‘.’と‘..’を決して展開しません．


histchars

　2つの履歴置換文字．シフトJIS文字も使用することができます．セットされてい
　ないならば履歴置換文字は‘!’と‘^’になります．


history

　履歴イベントの，それが最後に参照されてからの保存期間（10進表記）．


home

　ユーザのホーム・ディレクトリのパス名．組み込みコマンド cd, chdir, dirs,
　popd, pushd, pwd，ディレクトリ置換，ファイル名完成機能等に使用されます．
　fish 起動時に環境変数 HOME の値で初期設定されます．シェル変数 home を再設
　定すると同じ値が環境変数 HOME にも自動的に設定されます．この値は完全パス
　名であるべきです．


hugearg

　HUPAIR に適合していないコマンドへの引数が 255バイトを超えたときの対処．

　set hugearg=force としておくと，強引にコマンドを起動します．

　set hugearg=indirect としておくと，シェル変数 temp が示すディレクトリ下の
　一時ファイルに引数を書き込み，コマンドには引数として‘-+-+-<パス名>’を渡
　します．

　set hugearg=(indirect <文字列>) としておくと，‘-+-+-’の代わりに <文字列>
　を使います．

　以上のどれにも当てはまらなければエラーとなります．


ignoreeof

　セットしておくと，端末からの EOF を無視し，行編集機能 eof ではシェルを終
　了しないようにします．


listexec

　セットしておくと，ファイル名補完（ディレクトリ指定の無いコマンド名補完は
　除く）の候補一覧表示において，次の実行可能エントリに‘*’マークがつきます
　（ただし遅い）．

　　● 組み込みコマンド

　　● 実行可能属性が ON であるファイル

　　● 拡張子が .R，.X，.BAT（大文字と小文字は区別しない）のいずれかである
　　　 ファイル


listlinks

　セットしておくと，ファイル名補完の候補一覧表示において，ディレクトリへの
　シンボリック・リンクには‘>’，実体がエントリとして存在しないシンボリック・
　リンクには‘&’，それ以外のシンボリック・リンクには‘@’のマークがつきま
　す．この変数がセットされていなければ，シンボリック・リンクはどれも‘@’で
　マークされます．


loginsh

　ログイン・シェルとして起動した fish が起動時に自動的にセットします．


matchbeep

　行編集機能 complete でベルを鳴らす条件を設定します．

　この変数がセットされていなければ，一致する候補が 1つもない場合や一致する
　候補が複数ある場合，また，シェル変数 recexact がセットされているときに完
　全に一致する名前が 1つあるけれどもさらに長い候補がある場合にベルが鳴りま
　す．

　matchbeep=nomatch としておくと，一致する候補が 1つもなかった場合にのみベ
　ルが鳴ります．

　matchbeep=ambiguous としておくと，それに加えて複数の候補がある場合にもま
　たベルが鳴ります．

　matchbeep=notunique としておくと，それに加えて，シェル変数 recexact がセッ
　トしているときにおいて完全に一致する名前が 1つあるけれどもさらに長い候補
　もあるという場合にもベルが鳴ります．

　これら以外の値が設定されていると，補完時にはどの場合にもベルは鳴りません．

　なお，シェル変数 nobeep をセットしておくと，ベルは matchbeep の設定によら
　ず決して鳴りません．


noalias

　セットしておくと別名展開しません．


nobeep

　セットしておくと，行編集中にエラーがあったり行編集機能 complete での補完
　が不完全であった場合にも決してベルを鳴らしません．


noclobber

　セットしておくと，すでに存在しているファイルに出力を切り替えたとき，およ
　び，存在しないファイルに対して出力を追加モードで切り替えたときにエラーと
　なります．出力切り替え指示に‘!’を加えると無視されます．


noglob

　セットしておくと，組み合わせ展開，ディレクトリ置換，ファイル名展開を行い
　ません．


nonomatch

　セットしておくと，ファイル名展開やディレクトリ置換において，置き換わるべ
　き名前がなくてもエラーになりません．それらの置換を含んでいた単語は，
　nonomatch=drop ならば捨てられ，そうでなければそのまま保存されます．


nonullcommandc

　セットしておくと，空文字列ではコマンド名補完は行われず，代わりに通常のファ
　イル名補完が行われます．


nosort

　セットしておくと，ファイル名展開の結果をソートしません．一般的にはディレ
　クトリ・エントリの順序になりますが，ただし，必ずそうなることを保証するも
　のではありません．


noundefined

　セットしておくと，変数置換において，変数が定義されていない場合や添字の範
　囲が無効である場合，エラーとならずに空文字列に置換されます．


oldcwd

　作業ディレクトリを再設定したとき，以前の作業ディレクトリの完全パス名（以
　前に自動的にシェル変数 cwd にセットされた値）が自動的にセットされます．
　そのとき環境変数 OLDPWD にも同じ値がセットされます．


options

　組み込みコマンド getopt によってセットされます．


path

　コマンド検索パスの並び．fish 起動時に環境変数 path の値で初期設定されます．
　このときシェル変数 path の最初の要素は常に‘~~’となり，2番目以降の要素は
　環境変数 path の値を文字‘;’で区切った 1片 1片の単語となります．空単語は
　‘.’に置き換えられます．

　シェル変数 path を設定すると環境変数 path もまた自動的に再設定されます．
　このとき環境変数 path には，シェル変数 path の要素を‘;’で連結した文字列
　が設定されます．ただし，シェル変数 path の要素‘~~’は除外されます．

　ハッシュ機構がオンであるときにシェル変数 path を設定すると，コマンド検索
　のための fish 内部のハッシュ表が自動的に更新されます．


printexitvalue

　セットしておくと，組み込み以外のコマンドが 0 以外の終了ステータスを返した
　とき，その値を表示します．


prompt

　主プロンプトの文字列．fish 起動時，-tオプション，-cオプションのいずれも指
　定されず，スクリプト引数も指定されていなければ，値を '%% ' として初期セッ
　トされ，それ以外の場合には初期セットされません．

　prompt の文字列は，組み込みコマンド printf の書式制御文字列と同様にエスケー
　プ表記で記述することができ，さらに，printf とよく似た‘%’で始まる変換指
　示が用意されています．printf と違っているのは，最小フィールド幅や精度を
　‘*’で指定することができないことと，変換操作記号が異なることです．prompt
　の文字列で使用することができる変換操作記号を以下に示します．ここでは動作
　が最も近い printf の変換操作記号を()内に示し，それと相違があれば特記しま
　す．


　　　! (d)   現在の履歴イベント番号．

　　　/ (s)   現在の作業ディレクトリ（ドライブ名つき完全パス名）．

　　　~ (s)   現在の作業ディレクトリ（可能な限り‘~’を用いて省略する）．

　　　? (d)   シェル変数 status の値．

　　　y (d)   現在時刻の年（1980-2107）．ただし．精度を 2 以下に指定すると
　　　　　　　世紀抜きの年（0〜99）．

　　　m (d)   現在時刻の月（1〜12）．

　　　d (d)   現在時刻の日（1〜31）．

      H (d)   現在時刻の時（0〜23）．

　　　M (d)   現在時刻の分（0〜59）．

　　　S (d)   現在時刻の秒（0〜59）．

　　　w (s)   現在時刻の曜日．#フラグを使用しないと英語（Sunday〜Satday），
　　　　　　　#フラグを使用すると日本語（日〜土）．

　　　h (s)   現在時刻の月（January〜December）．

　　　% (%)   文字‘%’


prompt2

　副プロンプト（if文や switch文などのコンディションにより実行されない行の入
　力を促すとき，while文や foreach文などのループの中の行の入力を促すとき，お
　よび関数定義の際に出力するプロンプト）の文字列．fish 起動時，-tオプション，
　-cオプションのいずれも指定されず，スクリプト引数も指定されていなければ，
　値を '? ' として初期セットされ，それ以外の場合には初期セットされません．

　文字列の記法はシェル変数 prompt と同じです．


pushdsilent

　セットしておくと，組み込みコマンド cd，chdir，popd，pushd が成功したとき
　のディレクトリ・スタックの状態の表示がされなくなります．


recexact

　セットしておくと，行編集機能 complete において候補の中に完全に一致するも
　のがある場合には名前は完全に完成しているものとし，もしそれよりもさらに長
　い別の候補があっても無視します．ただし候補の表示には影響しません．


reconlyexec

　セットしておくと，コマンド名補完において，実行可能でないエントリを常に無
　視します（ただし遅い）．


refersysroot

　この変数がセットされていると fish は，システムに組み込まれた TwentyOne の
　RスイッチがONであると見なして，ドライブ名なしで / で始まるパス名も完全パ
　スとして認めます．さらに，TwentyOne +R の効果が及ばない fish の作業ディレ
　クトリ関連操作に対して TwentyOne +R と同等の処理を fish が行います．

　fish 起動時，ファイル $%SYSROOT/etc/config/refersysroot が存在していれば
　この変数は自動的にセットされます．


savedirs

　セットしておくと，ディレクトリ・スタックの状態と直前の作業ディレクトリの
　状態を再現するファイル ~/[.%]fishdirs が終了時に自動的に作成されます．


savehist

　終了時にファイル ~/[.%]history に保存する履歴イベント数（10進表記）．セッ
　トされていなければ ~/[.%]history は作成されません．


shell

　最初の要素は，実行インタープリタ名が指定されていないスクリプト・コマンド
　を実行するために起動するインタープリタ名．fish 起動時の初期値は‘fish’．
　2番目以降の要素はインタープリタに先行して渡す引数．初期値は‘-f’．


shlvl

　シェルの深さ（10進表記）．fish 起動時に環境変数 SHLVL の値に 1 を加えた値
　がセットされます．環境変数 SHLVL が定義されていない場合や値が無効である場
　合にはシェル変数 shlvl の値は 1 となります．fish はシェル変数 shlvl を初
　期化した後，環境変数 SHLVL をシェル変数 shlvl と同じ値に再設定します．ま
　たシェル変数 shlvl を再設定すると環境変数 SHLVL も自動的に同じ値に再設定
　されます．


showdots

　セットしておくと，空文字列によるファイル名補完で‘.’で始まる名前の候補を
　除外しません．ただし showdots=-A としておくと，ディレクトリ・エントリ‘.’
　と‘..’は（たとえそれが明示的に入力されても）常に除外されます．


status

　コマンドの終了ステータスが自動的にセットされます．コマンドの実行を ^C で
　中断したときや行編集機能 abort が働いたときには 512 がセットされます．


symlinks

　ディレクトリを指すシンボリック・リンクに対する処理を制御します．

　symlinks=chase では，シンボリック・リンクからの‘..’は常に実体の親ディレ
　クトリを指します．cd や pushd への指定パスに含まれる‘..’はすべて実体の
　親ディレクトリを指すことになります．作業ディレクトリの変更先がシンボリッ
　ク・リンクである場合，ディレクトリ・スタックやシェル変数 cwd にはリンクが
　指している実体のパス名がセットされます．

　symlinks=ignore では，cd や pushd は指定のパスに含まれるシンボリック・リ
　ンクを実体に置き換えずに正規化します．作業ディレクトリの変更先がシンボリッ
　ク・リンクである場合，ディレクトリ・スタックやシェル変数 cwd には指定した
　リンク自体のパス名がセットされます．

　symlinks=expand では，コマンド行に含まれる‘..’はコマンドを実行する前に
　予め正規化されます（詳しくは『ディレクトリ置換』の項を参照してください）．
　シェル変数 noglob がセットされていなければ，cd や pushd に対する
　symlinks=ignore と同じ効果が，すべてのコマンドの引数や入出力切り替え先に
　対して与えられることになります．noglob がセットされているときには
　symlinks=ignore と同じです．

　symlinks の設定がこれら以外である場合，cd や pushd は symlinks=ignore の
　場合と同様に，指定のパスに含まれるシンボリック・リンクを実体に置き換えず
　に正規化しますが，ただし，現在の作業ディレクトリからの相対パスは常に実体
　ディレクトリからの相対となります．作業ディレクトリの変更先がシンボリック・
　リンクである場合，symlinks=ignore の場合と同様に，ディレクトリ・スタック
　やシェル変数 cwd には指定したリンク自体のパス名がセットされます．

　（例）

　　% mkdir A:/しずかちゃんの家
　　% touch A:/しずかちゃんの家/しずかちゃんのママ
　　% mkdir A:/しずかちゃんの家/お風呂
　　% mkdir A:/のび太の家
　　% touch A:/のび太の家/のび太のママ
　　% ln -s A:/しずかちゃんの家/お風呂 A:/のび太の家/どこでもドア

　　% ls -lF A:/しずかちゃんの家 A:/のび太の家
　　A:/しずかちゃんの家:
　　total 2
　　d---rw-        0 Sep 14 22:18 お風呂/
　　-a--rw-        0 Sep 14 22:18 しずかちゃんのママ

　　A:/のび太の家:
　　total 2
　　la--rw-       26 Sep 14 22:19 どこでもドア -> A:/しずかちゃんの家/お風呂/
　　-a--rw-        0 Sep 14 22:18 のび太のママ

　　% unset symlinks
　　% cd A:/のび太の家/どこでもドア
　　% dirs
　　A:/のび太の家/どこでもドア
　　% ls ../*ママ
　　../しずかちゃんのママ
　　% cd ..
　　% dirs
　　A:/しずかちゃんの家

　　% set symlinks=chase
　　% cd A:/のび太の家/どこでもドア
　　% dirs
　　A:/しずかちゃんの家/お風呂
　　% ls ../*ママ
　　../しずかちゃんのママ
　　% cd ..
　　% dirs
　　A:/しずかちゃんの家

　　% set symlinks=ignore
　　% cd A:/のび太の家/どこでもドア
　　% dirs
　　A:/のび太の家/どこでもドア
　　% ls ../*ママ
　　../しずかちゃんのママ
　　% cd ..
　　% dirs
　　A:/のび太の家

　　% set symlinks=expand ; unset noglob
　　% cd A:/のび太の家/どこでもドア
　　% dirs
　　A:/のび太の家/どこでもドア
　　% ls ../*ママ
　　A:/のび太の家/のび太のママ
　　% ls ".."/*ママ
　　../しずかちゃんのママ
　　% cd ..
　　% dirs
　　A:/のび太の家


temp

　fish が一時ファイルを作成するディレクトリのパス名．fish 起動時に環境変数
　temp の値で初期設定されます．シェル変数 temp を再設定すると同じ値が環境変
　数 temp にも自動的に設定されます．


term

　ユーザの使用している端末名．fish 起動時に環境変数 TERM の値で初期設定され
　ます．また，このシェル変数 term を再設定すると環境変数 TERM も自動的に再
　設定されます．

　現在のところ，fish 上での効果はありません．


time

　セットしておくと，組み込み以外のコマンド実行後，コマンド経過時間を表示し
　ます．time に値がセットされている場合，その値は10進表記の秒数と見なされ，
　コマンドの経過時間がその秒数以上であったときにのみ経過時間を表示します．

　サブシェルは 1つのコマンドとして計測され，サブシェル内の個々のコマンドに
　対しては効力は及びません．


usegets

　セットしておくと，独自の行入力編集機構の代わりに DOS ファンクション gets
　で行入力を行います．このときには行編集機能は利用できず，また，EOF も入力
　できません．


uid

　ユーザのユーザid．fish 起動時に環境変数 UID の値で初期設定されます．


user

　ユーザのログイン名．fish 起動時に環境変数 USER（設定されていなければ，環
　境変数 LOGNAME）の値で初期設定されます．このシェル変数 user を再設定する
　と環境変数 USER も自動的に再設定されます．


verbose

　セットしておくと，行を入力する度に履歴置換後の行を標準エラー出力に出力し
　ます．


wordchars

　行入力編集機構で「単語」の構成要素として認める記号文字の集合．セットされ
　ていないならば *?_-.[]~= がデフォルトとなります．ASCII英数字とシフトJIS文
　字は常に「単語」の構成要素として認識されますので，wordchars にセットする
　必要はありません．



■
■  特別な環境変数
■


COMFISHOPT

　起動した fish のファイル名の先頭 3文字が‘COM’である場合，その fish はこ
　の変数から起動オプションを得ます．


GID

　fish 起動時，fish がシェル変数 gid を初期設定するために参照します．


HOME

　fish 起動時，fish がシェル変数 home を初期設定するために参照します．シェ
　ル変数 home が再設定されたときには自動的に同じ値に再設定されます．


LOGNAME

　fish 起動時，環境変数 USER が存在していなければ，fish がシェル変数 user
　を初期設定するために参照します．


OLDPWD

　シェル変数 oldcwd が自動的にセットされるとき，同じ値が同時にセットされま
　す．


PWD

　シェル変数 cwd が自動的にセットされるとき，同じ値が同時にセットされます．


SHLVL

　シェルの深さ（10進表記）．fish 起動時，fish は自分自身の環境変数 SHLVL を
　インクリメントします．環境変数 SHLVL が定義されていない場合や値が無効であ
　る場合には 1 に設定されます．この変数は親シェルから子シェルにシェルの深さ
　を通知するために用いられます．fish はシェル変数 shlvl を初期設定するため
　に環境変数 SHLVL を参照します．シェル変数 shlvl が再設定されたときには自
　動的に同じ値に再設定されます．


SYSROOT

　システムのルート・ディレクトリを示しています．

　UNIX では特別なファイルのパス名は伝統的にほぼ固定されています．パスワー
　ド・ファイルは /etc/passwd，ログイン記録ファイルは /etc/utmp と
　/usr/adm/wtmp，オンライン・マニュアルは /usr/man/{cat,man}*，英単語のリス
　トは /usr/dict/word といった具合です．このことは，システム管理者やプログ
　ラム開発者の仕事を簡単にし，プログラムのバグやポーティング時のトラブルを
　防ぎ，異なるシステムのユーザ間のコミュニケーションを取りやすくします．

　Human68k にはディスク・ドライブが複数あってそれぞれが独立しており，その構
　成はユーザの運用に完全に任されているため，特別なファイルのパスを一意に決
　定することができません．そこで，Human68k 上で特別なファイルを探す際には，
　ディレクトリの階層のルート（根元）は UNIX のように『どのシステムにおいて
　もただ一つ』であると見なし，それが現システム上ではどのディレクトリである
　のかを環境変数 SYSROOT が示します．

　SYSROOT には，ドライブ名つきの完全パス名を設定します．

　SYSROOT は，システム立ち上げ時に CONFIG.SYS の ENVSET= で一度だけ設定され，
　その後システムをダウンさせるまでそのまま保持されるべきです．システム運用
　中に変更されるべきではありません．


TERM

　fish 起動時，fish がシェル変数 term を初期設定するために参照します．シェ
　ル変数 term が再設定されたときには自動的に同じ値に再設定されます．


UID

　fish 起動時，fish がシェル変数 uid を初期設定するために参照します．


USER

　fish 起動時，fish がシェル変数 user を初期設定するために参照します．シェ
　ル変数 user が再設定されたときには自動的に同じ値に再設定されます．


path

　fish 起動時，fish がシェル変数 path を初期設定するために参照します．シェ
　ル変数 path が再設定されたときには自動的に再設定されます．設定される値は，
　シェル変数 path の要素を‘;’で連結した文字列です．ただし要素‘~~’は除外
　されます．


temp

　fish 起動時，fish がシェル変数 temp を初期設定するために参照します．シェ
　ル変数 temp が再設定されたときには自動的に同じ値に再設定されます．



■
■  関連ファイル
■


$%SYSROOT/etc/config/refersysroot

　システム調整ファイル．このファイルが存在していると，fish は起動時にシェル
　変数 refersysroot を自動的にセットします．


$%SYSROOT/etc/passwd

　システム設定ファイル．他ユーザのホーム・ディレクトリを得るために参照され
　ます．


$%SYSROOT/etc/fishenv
$%SYSROOT/etc/fprofile
$%SYSROOT/etc/fishrc
$%SYSROOT/etc/flogin

　システム環境ファイル．fish 起動時にもしあればsourceされます．sourceされる
　順序と条件については『fish の起動』の項を参照してください．


~/[.%]fishenv
~/[.%]fprofile
~/[.%]fishrc
~/[.%]login

　個人環境ファイル．fish 起動時にもしあればsourceされます．sourceされる順序
　と条件については『fish の起動』の項を参照してください．


$%SYSROOT/etc/flogout

　システム環境ファイル．ログイン・シェルとして起動した fish が終了する際に
　もしあれば最初にsourceされます．


~/[.%]logout

　個人環境ファイル．ログイン・シェルとして起動した fish が終了する際，
　$%SYSROOT/etc/flogout を（もしあれば）sourceした後に，もしあればsourceさ
　れます．


~/[.%]fishdirs

　個人環境ファイル．fish がログイン・シェルとして起動したとき，あるいは -d
　オプションが指定されて起動したとき，上記の順序で検索され，もしどちらかが
　source可能であれば先に見つかった方がsourceされます．このときsourceされる
　順位と条件について詳しくは『fish の起動』の項を参照してください．

　fish が終了するとき（起動時に -f，-t，-cオプションが指定されていた場合を
　除く），シェル変数 savedirs がセットされていれば，そのときのディレクトリ・
　スタックの内容と直前の作業ディレクトリの状態を再現するコマンドが
　~/.fishdirs に書き込まれます．~/.fishdirs を作成することができない場合に
　は ~/%fishdirs に書き込まれます．


~/[.%]history

　個人環境ファイル．fish 起動時にもしあれば読み込まれて履歴リストに登録され
　ます．

　fish が終了するとき（起動時に -f，-t，-cオプションが指定されていた場合を
　除く），シェル変数 savehist がセットされていれば，その値の最初の単語が示
　す行数分の最新の履歴イベントが ~/.history に書き込まれます．~/.history を
　作成することができない場合には ~/%history に書き込まれます．












