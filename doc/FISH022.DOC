-------------------------------------------------------------------
■ はじめに


	FISH のテスト版 (0 2 2) をリリースするにあたって取り急ぎ
	概要のみをまとめました．より詳しくはとりあえずＣシェルの
	マニュアルや解説書を参考にして下さい．FISH の完成版には平
	易な解説書と厳密な資料と簡素なオンライン・マニュアルとを
	添付したいと思ってい・・・・誰か書いてくれませんか？ :-)


-------------------------------------------------------------------
■ FISH の動作環境


	FISH は，Human68k version 2.02 上で動作します．これよりも
	古い版の Human68k 上での動作は保証しません．もっとも，いず
	れにしても無保証ですが．:-)

	オプションのデバイス・ドライバや常駐プログラムは一切必要あ
	りません．CONFIG.SYS が空っぽでも FISH は動作します．


-------------------------------------------------------------------
■ FISH の動作モード


	FISH には「標準入力モード」と「スクリプト・モード」の 2つ
	のモードがあります．

	FISH への引数にスクリプト・ファイル名があると，FISH はス
	クリプト・モードで動作します．スクリプト・モードでは，ス
	クリプト・ファイル全体をメモリにロードして実行します．

	FISH への引数にスクリプト・ファイル名がなければ，FISH は
	標準入力モードとなります．標準入力モードでは，標準入力か
	ら行を 1行ずつ読みとって解釈し，実行します．

	標準入力モードには，さらに「インタラクティブ（対話的）モー
	ド」と「非インタラクティブ・モード」があります．標準入力
	モードであるとき，標準入力が端末であればインタラクティブ・
	モードとなります．インタラクティブ・モードでは行入力を促
	すプロンプトが出力され，入力行は履歴リストに登録されます．
	また，インタラクティブ・モードではコメントは認められず，
	文字‘#’は保存されます．

	これらのモードとは別に，「ログイン・シェル」であるか否か
	の区別があります．ログイン・シェルは必ず標準入力モードで
	動作し，フラグ引数以外の引数は無視します．また，ログイン・
	シェルに対してはいくつかのフラグ引数は無効となります．原
	則的にはログイン・シェルに対して引数は与えるものではあり
	ません．


-------------------------------------------------------------------
■ 起動


	FISH の起動方法は次のとおりです．

		fish [ -Eddd ] [ -bcefilnstvVxX ] [ 引数 ...  ]

	フラグ引数は次のように解釈されます．

	-Eddd	FISH が持つ環境エリアの大きさをバイト数で設定しま
		す．デフォルトは256です．実際には，親プロセスから
		受け取った環境エリアの大きさとこのオプションで指
		定した大きさ（指定がなければ256）とを比べて大きい
		方をとります．

	-b	オプション解釈処理を強制的に中断し，以降の引数を
		オプション引数でないものとします．このオプション
		は‘-’で始まるスクリプトを実行するために用いられ
		ます．

	-c	後に続く 1つの引数をコマンドとして実行し，終了し
		ます．残りの引数はシェル変数 argv にセットされま
		す．

	-e	コマンドが異常終了したときや，0 以外の終了ステー
		タスを返したときにシェルを終了します．

	-f	~/%fishrc を source しません．FISH を短時間で起動
		することができます．シェル・スクリプトは，先頭行
		に #! A:/bin/fish.x -f と記述して FISH を -f オプ
		ション付きで起動するべきです．これは高速化のため
		でもあり，シェル・スクリプトをシステムやユーザの
		環境に依存させないためでもあります．

	-i	FISH の動作モードを「インタラクティブ・モード」と
		します．スクリプト・ファイルを指定する引数がなく，
		さらに FISH の標準入力が端末であるときには，この
		フラグを指定しなくてもインタラクティブ・モードと
		なります．このフラグを指定すると，フラグ以外の引
		数があっても，それはスクリプト・ファイルの指定と
		は見なされません．

	-l	ログイン・シェルとして動作します．

		このフラグ引数によって FISH をログイン・シェルと
		することは好ましくありません．このフラグは将来消
		える可能性があります．

	-n	入力行を解析しますが，実行はしません．スクリプト
		の文法をチェックするために使用します．

	-s	FISH の動作モードを標準入力モードとします．スクリ
		プト・ファイルを指定する引数がなければ，このフラ
		グを指定しなくても標準入力モードとなります．この
		フラグを指定すると，フラグ以外の引数があっても，
		それはスクリプト・ファイルの指定とは見なされませ
		ん．

	-t	標準入力から 1行を読み取って実行し，終了します．
		‘\’による行継続行は可能です．フラグ引数の処理後
		に残った引数はシェル変数 argv にセットされます．

	-v	シェル変数 verbose をセットします．

	-x	シェル変数 echo をセットします．

	-V	$%SYSROOT/etc/fishrc を実行する前にシェル変数
		verbose をセットします．

	-X	$%SYSROOT/etc/fishrc を実行する前にシェル変数
		echo をセットします．

	-c，-i，-s，-t のいずれも指定されていないとき，フラグ引数
	の処理後に引数が残っていれば，FISH はスクリプト・モードと
	なります．このとき，残った引数の最初が実行するスクリプト
	のパス名となります．この引数は変数置換 "$0" によって得る
	ことができます．さらに残った引数はシェル変数 argv にセッ
	トされます．

	上記以外の場合，FISH は標準入力モードとなり，残った引数は
	すべてシェル変数 argv にセットされます．このとき，標準入
	力が端末であれば，FISH はインタラクティブ・モードとなりま
	す．


	FISH は，次の場合にログイン・シェルとして動作します．

	・ OS から直接起動された場合．

	   CONFIG.SYS に SHELL=A:\bin\fish.x のように記述したり，
	   Human68k のプロンプト # に対して A:\bin\fish のように
	   入力することによって起動された場合です．


	・ 親プロセスのメモリ管理ポインタ + 0x10a（親プロセスのプ
	   ロセス管理ポインタ + 0xfa）からの 6バイトが 'login',0
	   である場合．

	   login.x（あるいは同様なコマンド）によって起動された場
	   合です．


	・ フラグ引数 -l と共に起動されたとき．

	   この手段はあまり好ましくありません．


	FISH は引数を解釈した後，ログイン・シェルであるならば，ユー
	ザのホーム・ディレクトリに移動します．

	次に FISH は，スクリプト・ファイル $%SYSROOT/etc/fishrc
	があれば，それを source（現在のシェルで実行）します．さら
	に，スクリプト・ファイル ~/%fishrc（シェル変数 home にセッ
	トされているディレクトリ下のファイル %fishrc）があれば，
	それを source します．ただし，フラグ引数 -f が指定されて
	いる場合には $%SYSROOT/etc/fishrc と ~/%fishrc は実行しま
	せん．

	次に，FISH がログイン・シェルであるときには，スクリプト・
	ファイル ~/%login があればそれを source します．

	最後に FISH は，フラグ引数 -f が指定されておらず，ファイ
	ル ~/%history があれば，その内容を source -h （履歴リスト
	に登録）します．

	FISH は組み込みコマンド exit の実行または EOF の入力によ
	り終了します．ただし，シェルの入力が端末であるときには，
	シェル変数 ignoreeof がセットされていると EOF では終了し
	ません．シェルの終了ステータスは，シェル変数 status の値
	です．

	ログイン・シェルは組み込みコマンド logout で終了します．
	ログイン・シェルに対して EOF を入力したり組み込みコマンド
	exit を実行すると，組み込みコマンド logout が自動的に実行
	されますので，組み込みコマンド exit や EOF で終了すること
	もできます．

	ログイン・シェルは，組み込みコマンド logout が実行された
	とき，スクリプト・ファイル ~/%logout があれば，それを
	source します．次に，シェル変数 savehist がセットされてい
	れば，その値の行数分の履歴リストの最新のイベントを，ファ
	イル ~/%history に書き込みます．その後，シェル変数 status
	の値を終了ステータスとして終了します．


-------------------------------------------------------------------
■ FISH の構造


	FISH は基本的には次の順序で処理を行います．


	 1  1行入力する

	 2  履歴置換する

	 3  行を単語に分解する

	 4  単語リストを履歴リストに追加する

	 5  別名置換する

	 6  コマンドの構文を解析する

	 7  各単一コマンド毎に，次の順序で処理を行う．

	   7.1  各単一コマンド毎に入出力の切り替えを解析する．こ
	        のとき，切り替え先を示す単語に対して，変数置換，
	        コマンド置換，組み合わせ展開，ホーム・ディレクト
	        リ置換，ファイル名展開の順序で置換・展開を行う．

	   7.2  コマンド名を解析する．このとき，コマンド名を示す
	        単語に対して，変数置換，コマンド置換，組み合わせ
	        展開，ホーム・ディレクトリ置換，ファイル名展開の
	        順序で置換・展開を行う．

	   7.3  引数に対して，変数置換を行う．

	   7.4  引数に対して，コマンド置換，組み合わせ展開，ホー
	        ム・ディレクトリ置換，ファイル名展開の順序で置換・
	        展開を行う．ただし，以下の組み込みコマンドを実行
	        する際には，これらの置換・展開はここでは行わず，
	        各コマンドが個別に処理する．

	        @, alias, bind, exit, repeat, set, setenv, time,
	        unalias, unset, unsetenv

	   7.5  コマンドを実行する


	以下では，この順番に従って解説します．


-------------------------------------------------------------------
■ 行の入力


	FISH は，スクリプト・モードではスクリプト・ファイルから行
	を読み取ります．ここで，1物理行の終わりは LF (0x0a) とし，
	LF の直前に CR (0x0d) がある場合，その CR は無視します．
	FISH が LF を読み取る前にファイルが途切れた場合には，FISH
	はそれまでに読み取ったデータを行として入力せずに捨てます．

	標準入力モードでは標準入力から行を読み取ります．標準入力
	が端末である場合，通常は FISH 独自の行入力機構で行の対話
	的編集を実現しています．この場合には，行編集機能
	accept-line を働かせた時点での編集行の内容が 1物理行とな
	ります．ただし eof を入力したときには，その時点での編集行
	の先頭から eof までの部分が 1物理行となります．

	なお，この行入力機構では DOSファンクション fgetc を用いて
	いるため，行編集中に CTRL+OPT.1+DEL キーや X68000 前面ボ
	タンを押しても，その後何かキーを押すまではそれらの機能は
	働きません．

	標準入力モードであり，標準入力が端末であっても，シェル変
	数 usegets がセットされているときには DOSファンクション
	gets を用いて行を読み取ります．この場合の行入力方法はコン
	ソール・ドライバによります．HISTORY.X 等の機能を利用した
	い場合や，行入力中に CTRL+OPT.1+DEL 他の機能を利用したい
	場合にはシェル変数 usegets をセットしてください．

	標準入力モードであり，標準入力が端末でない場合には，（イ
	ンタラクティブ・モードであっても）FISH は DOSファンクショ
	ン fgets を用いて行を入力します．この場合，標準的なシステ
	ムでは LF が 1物理行の終わりとなり，CR は，それがどこに現
	われようとも削除されます．

	物理行の最後に‘\’を置くと，1文字のブランクをはさんで論
	理的な行を次の物理行に継続することができます．

	引用符（‘'’，‘"’，‘`’）によるクオートの途中で物理行
	の最後に‘\’を置くと復帰改行（CR+LF）の意味になります．

	インタラクティブ・モード以外のモードでは，物理行を 1つの
	論理行に変換した後，論理行中の文字‘#’からその論理行の
	終わりまではコメントであるとして削除します．ただし，以下
	の‘#’にこの特別な意味はありません．

	・ 引用符（‘'’，‘"’，‘`’）や‘\’でエスケープされて
	   いる‘#’

	・ エスケープされていない‘!’，‘!{’，‘$’，‘${’の直
	   後の‘#’

	論理行の長さは4096バイトに制限されています．


-------------------------------------------------------------------
■ 履歴置換


	履歴置換を導く文字はシェル変数 histchars で設定することが
	できます．シェル変数 histchars がセットされていない場合に
	のデフォルトは‘!’と‘^’です．ここではデフォルトの設定
	で表記します．


	!N
	!{N}

		N 番のイベント．


	!-N
	!{-N}

		N 個前のイベント．


	!str
	!{str}

		str で始まる最新のイベント．


	!?str?
	!{?str?}

		str を含む最新のイベント．str を省略すると，最近
		の !?str? 置換における str または最近の
		:s/str1/str2/option/ 修飾（後で解説します）におけ
		る str1 のいずれか最近のものが使用されます．字句
		解析上の不都合がなければ，str の後ろの‘?’は省略
		することができます．str は先頭の31バイトまでが有
		効です．


	!!
	!{!}

		直前のイベント．


	!#
	!{#}
		現在の行の先頭からこの置換（!#）の直前までの部分
		を履歴置換した結果．


	これらの‘!’で始まる履歴置換は，行の任意の場所から始める
	ことができます．

	履歴置換を行ったときには，置換後の行を端末にエコーします．

	履歴置換は行の分解・解釈よりも前に行われますので，‘!’を
	引用符でクオートすることはできません．‘!’をエスケープす
	るには‘\’を使用してください．‘!’をエスケープしている
	‘\’は履歴置換後，履歴リストに登録する前に削除されます．

	‘!’の直後の文字が空白文字（スペース，復帰，改行，改頁，
	水平タブ，垂直タブ），‘=’，‘~’，‘(’，‘\’のいずれ
	かである場合には，その‘!’は履歴置換とは見なさずに保存し
	ます．ですから演算子‘!’，‘!=’，‘!~’ や，‘>! file’，
	‘>>! file’などを記述する際に‘!’をエスケープする必要は
	ありません．


   単語選択子


	上記の !置換の直後に次の単語選択子を 1つだけ付加すること
	ができます．!置換に { } による囲みを使用している場合には，
	単語選択子は { } の中になければなりません．

	:n	n 番目の単語
	:n-m	n 番目から m 番目までの単語
	:-n	0番目から n 番目までの単語
	:n-	n 番目から最後の 1つ前までの単語
	:n*	n 番目から最後までの単語
	:*	1番目から最後までの単語

	ここで，n および m は，

	n	n 番目の単語
	^	1番目の単語
	$	最後の単語
	%	?str? による検索で一致した単語


   修飾子


	上記の !置換の直後に，さらに次の修飾子を付加することがで
	きます．単語選択子と共に付加する場合には単語選択子に続け
	て記述します．複数の修飾子を連ねることができ，それらは左
	から右に順に処理されます．!置換に { } による囲みを使用し
	ている場合には，修飾子は { } の中になければなりません．

	:h

		各単語について，パス名からドライブ名＋ディレクト
		リ部分を取り出します．最後の / は含みません．単語
		にドライブ名＋ディレクトリ部分がないならば，単語
		を元のまま保存します．


	:t

		各単語について，パス名からファイル名部分（拡張子
		も含む）を取り出します．


	:r
		各単語について，パス名から拡張子を除いた部分を取
		り出します．


	:e
		各単語について，パス名からファイル名の拡張子（サ
		フィックス）部分を取り出します．ただし拡張子の先
		頭の‘.’は含みません．


	:d
		各単語について，パス名からドライブ名部分を取り出
		します．ただしドライブ名の最後の‘:’は含みません．


	:f
		各単語について，パス名からドライブ名を除いた部分
		を取り出します．


	:s/str1/str2/option/

		単語中の str1 を str2 に置き換えます．option が空
		ならば，単語リスト中最初に現われる str1 のみが置
		換されます．option として数値 n を記述すると，単
		語リスト中 n番目に現われる str1 のみを置換します．
		n は単語の番号ではないことに注意してください．オ
		プションとして‘g’を記述すると単語リスト中に現わ
		れるすべての str1 を置換します．

		区切り文字‘/’の位置には，‘/’に限らず，‘}’を
		除く，シフトJIS文字を含めた任意の文字を使用するこ
		とができます．

		str1 および str2 の中では，区切り文字として使った
		文字を‘\’でエスケープしなければなりません．str1
		および str2 に文字‘\’そのものを使いたいときには，
		その‘\’は‘\’でエスケープしなければなりません．

		区切り文字として‘\’を使用している場合には‘\’
		をエスケープ文字として使用することはできません．

		str1 が空である場合は，最近の
		:s/str1/str2/option/ 修飾における str1 または最近
		の !?str? 置換における str のいずれか最近のものが
		使用されます．

		str1 が‘^’である場合，それは各単語の先頭を意味
		します．例えば :s/^/B:/g/ は，各単語にプリフィッ
		クス‘B:’を付加します．本来の文字‘^’1文字を
		str1 として使いたい場合には‘\^’と記述しなければ
		なりません．

		str1 が‘$’である場合，それは各単語の末尾を意味
		します．例えば :s/$/.c/g/ は，各単語にサフィック
		ス‘.c’を付加します．本来の文字‘$’1文字を str1
		として使いたい場合には‘\^’と記述しなければなり
		ません．

		str2 が空である場合には，str1 は空文字列に置き換え
		られる（すなわち削除される）ことになります．

		str2 が‘%’であれば，直前の :s/str1/str2/option/
		修飾における str2 が使用されます．本来の文字‘%’
		1文字を str2 として使いたい場合には，‘\%’と記述
		しなければなりません．

		str2 の中の文字‘&’は，str1 そのものに置き換えら
		れます．この場合も，‘&’そのものを使いたい場合に
		は‘\’でエスケープしなければなりません．

		字句解析上の不都合がなければ，最後の‘/’は省略す
		ることができ，さらに，option を付けないならば
		str2 の後ろの‘/’も省略することができます．

		str1 は31バイト以下，str2 は63バイト以下でなければ
		なりません．


	:&option

		以前に行った :s または :& での置換を再度行います．
		ここでの option の意味は :s と同じです．

	:p

		履歴リストに登録するのみで，実行しません．


	修飾子はＣシェルとまったく同じではないことに注意してくだ
	さい．


	{ } は履歴置換をそのあとに続く文字と分離する役目を持ちます．
	例を示します．

		1  % echo foo
		2  % !ecd
		3  ecd: イベントが見当たりません
		4  % !{ec}d
		5  food

	単語選択子の最初の‘:’は，単語選択子が‘^’，‘$’，
	‘%’，‘*’，‘-’のいずれかである場合には省略することが
	できます．また，単語選択子かまたは修飾子が続く‘!!’は
	‘!’と略記することができます．例えば‘!!:$’，‘!!$’
	‘!:$’，‘!$’はどれも同じです．

	入力行の最初の空白文字（スペース，復帰，改行，改頁，水平
	タブ，垂直タブ）以外の文字が‘^’である場合，

		^str1^str2^option^

	という形式の履歴置換であると見なされます．これは

		!:s^str1^str2^option^

	の省略形です．


-------------------------------------------------------------------
■ 単語分け


	FISH は履歴置換後の入力行を空白文字（スペース，復帰，改行，
	改頁，水平タブ，垂直タブ）で単語に分解します．ただし例外
	として以下の綴りは前後に空白文字がなくても 1語と見なしま
	す．

		<<<
		<<=
		<<
		<=
		<
		>>=
		>>
		>=
		>
		&&
		&=
		&
		||
		|=
		|
		;
		(
		)

	空白文字や上記の特殊文字を単語の一部として記述するには，
	後述のクオーティング（エスケーピング）を行う必要があり
	ます．

	1語の長さは255バイトに制限されています．


-------------------------------------------------------------------
■ 履歴登録


	インタラクティブ・モードでは，入力行を単語分けして単語リ
	ストとした後，単語リストが空でなければそれを履歴リストに
	登録します．このとき，シェル変数 history にセットされた
	数が示すイベント期間内に 1度も参照されなかったイベントは
	履歴リストから削除されます．


-------------------------------------------------------------------
■ クオーティング


	\c		文字 c をエスケープします．

	'string'	string をエスケープします．

	"string"	string をエスケープしますが，string に対
			して変数置換とコマンド置換は行われます．

	`command`	command をサブシェル（現在のシェルのコ
			ピー）で実行し，標準出力に出力された文字
			列に置き換えます．（コマンド置換）


-------------------------------------------------------------------
■ コマンドの構文と区切り文字


	単一のコマンドは単語の並びであり，最初の単語はコマンド名，
	残りの単語はコマンドに対する引数です．

	以下に，可能なコマンドの組み合わせを説明します．
	ここでは，コマンドの組み合わせを command あるいは
	command1, command2, ... と記述します．


	( command )

		command をサブシェル（現在のシェルのコピー）で実
		行します．


	command &

		command をサブシェルで実行します．残念なことにバッ
		ク・グラウンド実行はしません．:-(


	command1 ; command2

		command1 を実行し，それが終了したら command2 を実
		行します．


	command1 && command2

		command1 を実行し，その終了ステータスが 0 であっ
		た場合にのみ command2 を実行します．


	command1 || command2

		command1 を実行し，その終了ステータスが 0 でなかっ
		た場合にのみ command2 を実行します．


	command1 | command2

		command1 標準出力を command2 の標準入力に接続して，
		まず，command1 を実行し，次いで command2 を実行し
		ます．


	command1 |& command2

		command1 の標準出力と標準エラー出力を command2 の
		標準入力に接続して，まず command1 を実行し，次い
		で command2 を実行します．


	以上の組み合わせの優先順位は次のとおりです．


	高
	↑	( )
		&
		;  &&  ||
	↓	|  |&
	低


	優先順位が同じものの組み合わせでは，左側にあるものが優先
	します．いずれの場合にもコマンドは左から右の順に実行され
	ます．


-------------------------------------------------------------------
■ 別名置換


	入力行が単語分けされた後，その単語リストは前述のコマンド
	の構文に従って解析され，各単一コマンドのコマンド名（最初
	の単語）が別名であるかどうかがチェックされます．もしコマ
	ンド名が別名であるならば，その単語は新しい（本来の）テキ
	ストに置き換えられます．このとき，置き換わるテキストに対
	して再び履歴置換が行われます．ただし，ここでは !! は直前
	の履歴イベントではなく，元の単一コマンドの単語リストを参
	照します．したがって，たとえば !!:3 は 3番目の引数を，!$
	は元の単一コマンドの最後の引数を取り込み，!* は全引数を取
	り込みます．置き換わるテキストの中に履歴置換が一切なけれ
	ば，置き換わるテキストの後ろに元の単一コマンドの全引数が
	取り込まれます．

	1度でも別名置換が起こったならば，置換後の行全体が再び単語
	分けされ，また再び別名置換処理が始まります．ただし，ルー
	プ回数が20回を越えるとエラーとして停止します．

	例外として，置き換わるテキストの最初の単語が別名と同じで
	ある場合には，このコマンドに対して再び別名置換はしません．
	例えば，alias ls 'ls -CF' として ls *.c を入力すると，こ
	れは ls -CF *.c に置き換えられますが，この単一コマンドに
	対してこれ以上の別名置換は起こりません．

	単一コマンドの最初の単語が‘.’である場合には，この単一コ
	マンドに対して別名置換はしません．そして別名置換処理を終
	えたとき，最初の単語が‘.’である単一コマンドがあれば，そ
	の単語‘.’を削除します．これを利用して別名置換を抑止する
	ことができます．


-------------------------------------------------------------------
■ 入出力の切り替え


	< file
	<! file

		コマンドの標準入力に file から入力します．file が
		ファイルまたはデバイスとして存在していなければエ
		ラーとなります．

		file がデバイスである場合，そのデバイスの入力ステー
		タスは‘入力可’でなければエラーになりますが，
		‘!’を付けると，そのチェックはしません．シェル
		変数 forceio がセットされていれば，‘!’を付けな
		くても，そのチェックはしません．


	> file
	>! file
	>& file
	>&! file

		コマンドの標準出力を（‘&’を付けた形式では，さら
		に標準エラー出力も） file に出力します．file が存
		在していない場合にはファイルとして新規に作成され
		ます．file が存在するファイルである場合には，以前
		の内容は失われます．

		file がデバイスである場合，そのデバイスの出力ステー
		タスは‘出力可’でなければエラーになりますが，
		‘!’を付けると，そのチェックはしません．シェル
		変数 forceio がセットされていれば，‘!’を付けな
		くても，そのチェックはしません．

		シェル変数 noclobber がセットされている場合には，
		file はまだ存在していないファイルか，またはデバイ
		スでなければエラーになりますが，‘!’を付けると，
		そのチェックはしません．


	>> file
	>>! file
	>>& file
	>>&! file

		コマンドの標準出力を（‘&’を付けた形式では，さら
		に標準エラー出力も） file の終わりに追加出力しま
		す．file が存在していない場合にはファイルとして新
		規に作成されます．

		file がデバイスである場合は‘>’と同じです．

		シェル変数 noclobber がセットされている場合には，
		file が存在していなければエラーになりますが，
		‘!’を付けると，そのチェックはしません．


	<< word

		ヒア・ドキュメント．シェルの入力行を、次の行から
		word のみの行が現われる直前の行までをコマンドの標
		準入力に入力します．

		word がまったくエスケープされていないならば，行は
		予め変数置換とコマンド置換を受けます．この場合，
		変数置換とコマンド置換を抑止するためには，‘\’で
		‘$’や‘`’をエスケープします．ここでは‘'’と
		‘"’には特別な意味はありません．‘$’，‘`’，お
		よび‘\’をエスケープしている‘\’は削除されます．
		それ以外の‘\’は保存されます．ここでのコマンド置
		換の結果は，最後の復帰改行が取り除かれる他はすべ
		ての文字が保存されます．

		word の一部または word 全体がエスケープされている
		場合には，行はそのままコマンドに渡されます．

		word の綴りは任意ですが，FISH の予約語と同じ綴り
		は避けるべきです．

		ヒア・ドキュメントを含むコマンドは 1行に1つとする
		べきです．たとえば，

			cat -n << EOF ; cat -n << EOF
			  この行は最初の cat に入力されます．
			EOF
			  この行は二番目の cat に入力されます．
			EOF
			# しかしながら，こののような記述は勧めら
			# れません．

			program && cat -n << EOF
			  ここからの行は，program がエラーだとヒア・
			  ドキュメントの内容とは認められないので，
			  これは正しくありません．
			EOF

			if ($foo) cat -n << EOF
			  これも同様です．$foo が 0 だと，ここから
			  の行はヒア・ドキュメントの内容とは認めら
			  れません．
			EOF


	<<< word

		ヒア・ストリング．word に復帰改行（CR+LF）を加え
		てコマンドの標準入力に入力します．


	上記の file や word は，予め，変数置換，コマンド置換，組
	み合わせ展開，ホーム・ディレクトリ置換，ファイル名展開の
	順序で置換・展開されます．

	‘!’を使用するときには，‘!’の後ろに空白文字（スペース，
	復帰，改行，改頁，水平タブ，垂直タブ）を置いて，‘!’を 1
	つの単語としなければなりません．


-------------------------------------------------------------------
■ 変数置換


	$var
	${var}
	$@var
	$@{var}
	$%var
	$%{var}

		‘@’を付けた形式ではシェル変数 var の，‘%’を付
		けた形式では環境変数 var の値．‘@’も‘%’も付け
		ない形式では，まずシェル変数を調べ，セットされて
		いなければ環境変数を調べます．


	$var[index]
	${var[index]}
	$@var[index]
	$@{var[index]}
	$%var[index]
	$%{var[index]}

		‘@’を付けた形式ではシェル変数 var の，‘%’を付
		けた形式では環境変数 var の index 番目の値．‘@’
		も‘%’も付けない形式では，まずシェル変数を調べ，
		セットされていなければ環境変数を調べます．


	$#var
	${#var}
	$@#var
	$@{#var}
	$%#var
	$%{#var}

		‘@’を付けた形式ではシェル変数 var の，‘%’を付
		けた形式では環境変数 var の単語数．‘@’も‘%’も
		付けない形式では，まずシェル変数を調べ，セットさ
		れていなければ環境変数を調べます．


	$?var
	${?var}
	$@?var
	$@{?var}
	$%?var
	$%{?var}

		‘@’を付けた形式ではシェル変数 var が，‘%’を付
		けた形式では環境変数 var がセットされていれば 1．
		さもなくば 0．‘@’も‘%’も付けない形式では，ま
		ずシェル変数を調べ，セットされていなければ環境変
		数を調べます．


	$*
	${*}

		$argv と同じ．


	$i
	${i}

		$argv[i] と同じ．（i は 1 〜 9）


	$0
	${0}

		スクリプト・モードのとき，スクリプト・ファイルの
		パス名．


	$<
	${<}

		標準入力からの 1物理行．入力された行は 1つの単語
		として扱われ，それ以上の解釈はされません．


	$$
	${$}

		シェル番号．先祖プロセスに FISH が 1つもない状態
		から起動された FISH のシェル番号は 1 となり，以後
		FISH を起動する度に，そのシェル番号は 1 ずつ増加
		します．サブシェルのシェル番号は親シェルと同一で
		す．


   index


	n	n 番目の単語
	n-m	n 番目から m 番目までの単語
	-n	1番目（最初の単語）から n 番目までの単語
	n-	n 番目から最後までの単語
	n*	n 番目から最後までの単語
	*	1番目から最後までの単語（全単語）


	たとえば $p[$q] のように，index にも変数置換を使用するこ
	とができます．


   修飾子


	上記の変数置換の直後に，次の修飾子を付加することができま
	す．複数の修飾子を連ねることができ，それらは左から右に順
	に処理されます．変数置換に { } による囲みを使用している場
	合には，修飾子は { } の中になければなりません．


	:h
	:t
	:r
	:e
	:d
	:f
	:s/str1/str2/option/
	:&option

		履歴置換の修飾と同じです．


	:q

		単語数を保存する形で各単語をクオートします．


	:x

		各単語をさらに単語に分解した上で，それぞれの単語
		をクオートします．


	修飾子はＣシェルとまったく同じではないことに注意してくださ
	い．


	{ } は変数置換をそのあとに続く文字と分離する役目を持ちます．
	例を示します．

		1  % set foo=bar foo2=quux
		2  % echo $foo2
		3  quux
		4  % echo ${foo}2
		5  bar2

	また，次の例のように‘&’などの特殊な文字を含む修飾子を付
	加する際にも変数置換を { } で囲む必要があります．

		1  % set foo='fish is fun'
		2  % echo $foo
		3  fish is fun
		4  % echo $foo:s/fish/&ing/
		5  is fun
                6  ing/: コマンドが見当たりません
		7  % echo ${foo:s/fish/&ing/}
		8  fishing is fun

	変数置換は，‘"’によるクオートの中でも行われます．‘'’
	によるクオートの中では行われません．‘`’によるクオート（
	コマンド置換）の中の変数置換は，サブシェルによって行われ
	ることになります．


-------------------------------------------------------------------
■ コマンド置換


	`command` は command をサブシェル（現在のシェルのコピー）
	で実行し，標準出力に出力された文字列に置き換えます．この
	とき，通常は，空白文字（スペース，復帰，改行，改頁，水平
	タブ，垂直タブ）で別々の単語に分解され，空の単語は破棄さ
	れます．コマンド置換がこのコマンド置換が‘"’によるクオー
	トの中にある場合には，単語の分解は改行または復帰改行だけ
	で行われ，その他の空白文字は保存されます．いずれの場合に
	も，最後の復帰改行だけは取り除かれ，新しい単語を生成しま
	せん．

	‘'’によるクオートの中では，このコマンド置換は行われませ
	ん．


-------------------------------------------------------------------
■ 組み合わせ展開


	a{b,c,d}e は abe ace ade に展開され，a{b,c}{d,e,f}g は
	abdg abeg abfg acdg aceg acfg に展開されます．左右の関係
	は保存されます．特殊な場合として，‘{’，‘}’，および
	‘{}’はそのまま保存されます．

	シェル変数 noglob がセットされているときには，この組み合
	わせ展開は行われません．また，‘"’または‘'’によるクオー
	トの中では，この組み合わせ展開は行われません．‘`’による
	クオート（コマンド置換）の中の組み合わせ展開は，サブシェ
	ルによって行われることになります．


-------------------------------------------------------------------
■ ホーム・ディレクトリ置換


	単語が‘~’であるかまたは単語の先頭が‘~/’であるとき，先
	頭の‘~’はユーザのホーム・ディレクトリ（シェル変数 home
	の値）に置き換えられます．また，単語が‘~user’であるかま
	たは単語の先頭が‘~user/’（user は 1文字以上の ASCII 英
	数字の綴り）であるとき，先頭の‘~user’はユーザ user のホー
	ム・ディレクトリに置き換えられます．FISH はユーザ user の
	ホーム・ディレクトリをシステム・ファイル
	$%SYSROOT/etc/passwd から得ます．

	シェル変数 noglob がセットされているときには，このホーム・
	ディレクトリ置換は行われません．また，‘"’または‘'’に
	よるクオートの中では，このホーム・ディレクトリ置換は行わ
	れません．‘`’によるクオート（コマンド置換）の中のホーム・
	ディレクトリ置換は，サブシェルによって行われることになり
	ます．


-------------------------------------------------------------------
■ ファイル（ディレクトリ・エントリ）名展開


	後述する「式」のパターン比較演算と同じパターン・マッチン
	グによりファイル（ディレクトリ・エントリ）名展開が行われ
	ます．ただしボリューム・ラベルは展開しません．

	ディレクトリの区切り文字としては通常‘/’を用いますが，
	‘\’をエスケープした形である‘\\’および‘/’をエスケー
	プした形である‘\/’もディレクトリの区切りとして認められ
	ます．

	パス名のどの部分にもパターン・マッチのメタ・キャラクタを
	使用することができますが，ドライブ名の‘:’，ディレクトリ
	の区切りの‘/’（もしくは‘\\’，‘\/’）は明示的に記述し
	なければなりません．また，‘.’で始まるエントリは通常は展
	開されませんので，それを展開したい場合には最初の‘.’は明
	示的に記述しなければなりません．

	単語をファイル名展開した結果の単語リストは文字コード順に
	ソートされています．

	コマンドの引数にファイル名展開があるとき，マッチするファ
	イルが 1つも存在していなければエラーとなりますが，ファイ
	ル名展開を含む引数のすべてがマッチしなければならないわけ
	ではありません．

	シェル変数 nonomatch がセットされている場合には，マッチす
	るファイル名が 1つも存在していない場合にもエラーとせず，
	展開前の単語をそのまま保存します．

	ファイル名展開は通常，ファイル名の ASCII英大文字と小文字
	を区別しますが，シェル変数 ciglob がセットされている場合
	には区別しません．ただしこの場合にも展開結果は大文字と小
	文字を区別してソートします．

	シェル変数 noglob がセットされているときには，このファイ
	ル名展開は行われません．また，‘"’または‘'’によるクオー
	トの中では，このファイル名展開は行われません．‘`’による
	クオート（コマンド置換）の中のファイル名展開は，サブシェ
	ルによって行われることになります．


-------------------------------------------------------------------
■ 特別なシェル変数


	FISH_AUTHOR

		FISH の作者の氏名がセットされています．


	FISH_COPYRIGHT

		FISH の版権告示がセットされています．


	FISH_VERSION

		FISH のバージョン番号がセットされています．
		$@FISH_VERSION[1] はメジャー番号，
		$@FISH_VERSION[2] はマイナー番号，
		$@FISH_VERSION[3] はパッチレベルを示します．


	addsuffix

		セットしておくと，行編集機能 complete によって名
		前が完全に完成したとき，その名前がディレクトリを
		示すものならば‘/’が，それ以外の場合には‘ ’（
		スペース）が名前の後ろに自動的に付加されるように
		なります．

		addsuffix=exact では，名前が完成した時点ではこの
		機能は働かず，完成している名前に対してさらに行編
		集機能 complete を行ったときに働くようになります．


	argv

		FISH に与えられたフラグ以外の引数がセットされてい
		ます．


	autolist

		セットしておくと，行編集機能 complete で，複数の
		候補があって，それらの共通部分が 1文字もないとき
		（1文字も補完できないとき），自動的に行編集機能
		list が働いて候補のリストを表示します．

		ただし行編集機能 list を手動で働かせたときと異な
		り，ディレクトリに‘/’は付きません．（バグ）


	batshell

		拡張子が‘.BAT’であるコマンド・ファイルを実行す
		るために exec するシェルのパス名．初期値は
		$%SYSROOT/bin/COMMAND.X です．


	cdpath

		ディレクトリ移動の代替パスのリスト．


	ciglob

		セットしておくと，ファイル名展開時にファイル名の
		大文字と小文字を区別しません．


	cifilec

		セットしておくと，行編集機能 complete と list でファ
		イル名の大文字と小文字を区別しません．ただし，ファイ
		ル名の大文字と小文字を区別するシステム上では，補完す
		るパスの途中のディレクトリ名の大文字と小文字は必ず区
		別されます．


	cwd

		カレントの作業ディレクトリの完全パス名が FISH に
		よって自動的にセットされます．ディレクトリの区切
		り文字は‘/’です．なお，FISH はシェル変数 cwd を
		セットすると同時に，カレントの作業ディレクトリの
		完全パス名を環境変数 PWD にもセットします．環境変
		数 PWD ではディレクトリの区切り文字は‘\’です．


	echo

		セットしておくと，コマンドを実行前に表示します．


	fignore

		ファイル名補完で無視するサフィックスのリスト．


	forceio

		セットしておくと，入出力切り替え先デバイスの入力
		ステータス／出力ステータスを無視します．


	histchars

		2つの履歴置換文字．シフトJIS文字も使用することが
		できます．セットされていないならば履歴置換文字は
		‘!’と‘^’となります．


	history

		履歴イベントの，それが最後に参照されてからの保存
		期間．


	home

		ユーザのホーム・ディレクトリのパス名．組み込みコ
		マンド cd, chdir, dirs, popd, pushd, pwd，ホーム・
		ディレクトリ置換，ファイル名完成機能等に使用され
		ます．起動時に環境変数 HOME の値で初期設定されま
		す．その際，‘\’は‘/’に変換されます．また，こ
		のシェル変数 home を再設定すると，環境変数 HOME
		も自動的に再設定されます．その際には‘/’は‘\’
		に変換されます．


	hugearg

		コマンドへの引数が255バイトを越えたときの対処．
		set hugearg=force としておくと，強引にコマンドを
		起動します．set hugearg=indirect としておくと，引
		数を一時ファイルに書き込み，コマンドには引数とし
		て‘-+-+-<ファイル名>’を渡します．<ファイル名>
		ではディレクトリは‘\’で区切られています．
		set hugearg=(indirect <文字列>) としておくと，
		‘-+-+-’の代わりに <文字列> を使います．以上のど
		れにも当てはまらない場合には，コマンドをロードし
		て HUPAIR適合コマンドであるかどうかを調べ，HUPAIR
		適合コマンドでないならば実行せずにエラーとします．


	ignoreeof

		セットしておくと，端末からの EOF を無視し，EOF で
		はシェルを終了しないようにします．


	matchbeep

		行編集機能 complete でベルを鳴らす条件を設定しま
		す．

		この変数がセットされていなければ，一致する候補が
		1つもない場合や一致する候補が複数ある場合，また，
		シェル変数 recexact がセットされているときに完全
		に一致する名前が 1つあるけれどもさらに長い候補が
		ある場合にベルが鳴ります．

		matchbeep=nomatch としておくと，一致する候補が 1
		つもなかった場合にのみベルが鳴ります．

		matchbeep=ambiguous としておくと，それに加えて複
		数の候補がある場合にもまたベルが鳴ります．

		matchbeep=notunique としておくと，それに加えて，
		シェル変数 recexact がセットしているときにおいて
		完全に一致する名前が 1つあるけれどもさらに長い候
		補もある場合にもベルが鳴ります．

		シェル変数 matchbeep の設定がこれら以外であると，
		補完時にはどの場合にもベルは鳴りません．

		なお，シェル変数 nobeep をセットしておくと，ベル
		はシェル変数 matchbeep の設定によらず決して鳴りま
		せん．


	nobeep

		セットしておくと，行編集中にエラーがあったり行編
		集機能 complete での補完が不完全であった場合にも
		決してベルを鳴らしません．


	noclobber

		セットしておくと，すでに存在しているファイルに出
		力を切り替えたとき，および，存在しないファイルに
		対して出力を追加モードで切り替えたときにエラーと
		なります．


	noglob

		セットしておくと，組み合わせ展開，ホーム・ディレ
		クトリ置換，ファイル名展開を行いません．


	nonomatch

		セットしておくと，ファイル名展開文字に一致するファ
		イルがなかった場合，エラーとはせず，文字を展開せ
		ずに保存します．


	path

		コマンドのパスのリスト．Ｃシェルでは起動時の初期
		値が固定されていますが，FISH は 起動時に環境変数
		path の値で初期設定します．さらに，Ｃシェルと同様，
		環境変数 path を再設定したときにもシェル変数 path
		が自動的に再設定されます．環境変数 path からシェ
		ル変数 path へのインポートの際には，‘\’は‘/’
		に変換され，‘~~’と‘.’ が追加されます．このシェ
		ル変数 path を再設定すると環境変数 path も自動的
		に再設定されます．その際には‘/’は‘\’に変換さ
		れ，‘~~’と‘.’は無視されます．


	prompt

		主プロンプトの文字列．FISH がスクリプト・モードで
		なければ値を '% ' として初期セットされます．FISH
		がスクリプト・モードである場合には初期セットされ
		ません．

		以下のメタ・シーケンスを使用することができます．

		%[-][0][<最小幅>]<変換オペレータ>
		  |  |
		  |  |___ 右詰めのとき，左側には'0'を詰める
		  |
		  |___ 左詰め

		    <最小幅>
			少なくとも出力する文字数を10進整数表記で
			示す．

		    <変換オペレータ>
			!    カレント履歴イベント番号
			p    カレント・ディレクトリ（~ による略記）
			l    カレント・ディレクトリ（完全絶対パス）
			y    年（最小幅が4未満ならば下2桁）
			m    月
			a    月の英語名の略記（3桁）
			d    日
			h    曜日の英語名の略記（3桁）
			s    日本語での曜日（2桁）
			H    時
			M    分
			S    秒

		 %n   復帰改行
		 %%   文字‘%’


	prompt2

		副プロンプト（if文や switch文などのコンディション
		により実行されない行の入力を促すとき，および
		while文や foreach文などのループの中の行の入力を促
		すときに出力するプロンプト）の文字列．FISH がスク
		リプト・モードでなければ値を '? ' として初期セッ
		トされます．FISH がスクリプト・モードである場合に
		は初期セットされません．

		シェル変数 prompt と同じシーケンスを使用すること
		ができます．


	recexact

		セットしておくと，行編集機能 complete において候
		補の中に完全に一致するものがある場合には名前は完
		全に完成しているものとして，もしそれよりもさらに
		長い別の候補があっても無視します．ただし候補の表
		示には影響しません．


	savehist

		ログアウト時に保存する履歴イベント数．


	shell

		既定のシェルのパス名．実行シェルが指定されていな
		いシェル・スクリプトを実行するときにはこの変数に
		設定されているプログラムを起動します．初期値は
		$%SYSROOT/bin/fish.x です．


	status

		コマンドの終了ステータスが FISH によって自動的に
		セットされます．コマンドの実行を ^C で中断したと
		きや行編集機能 abort が働いたときには 512 がセッ
		トされます．


	temp

		FISH が一時ファイルを作成するディレクトリのパス名．
		FISH 起動時に環境変数 temp の値で初期設定されます．
		その際，‘\’は‘/’に変換されます．また，このシェ
		ル変数 temp を再設定すると環境変数 temp も自動的
		に再設定されます．その際には‘/’は‘\’に変換さ
		れます．


	term

		ユーザの使用している端末名．FISH 起動時に環境変数
		TERM の値で初期設定されます．また，このシェル変数
		term を再設定すると環境変数 TERM も自動的に再設定
		されます．

		現在は無視しており，効力はありません．


	time

		（組み込みコマンド以外の）コマンド実行後にコマン
		ド経過時間を表示しない最大の実行時間．


	usegets

		セットしておくと，独自の行入力機構の代わりに DOS
		ファンクション gets で行入力を行います．このとき
		には行編集機能は利用できず，EOF も入力できません．


	user

		ユーザのログイン名．FISH 起動時に環境変数 USER
		（設定されていなければ，環境変数 LOGNAME）の値で
		初期設定されます．このシェル変数 user を再設定す
		ると環境変数 USER も自動的に再設定されます．


	verbose

		セットしておくと，行を入力する度に履歴置換後の行
		を表示します．


-------------------------------------------------------------------
■ FISH 組み込みコマンド


	FISH には以下のコマンドが組み込まれており，これらは仮想的
	なディレクトリ‘~~’下に置かれています．

	組み込みコマンドを実行する際には，実行する直前にシェル変
	数 status に 0 がセットされ，その後，組み込みコマンド実行
	時にエラーがあったときにのみ，シェル変数に 1 がセットされ
	ます．ですから，set status=5 あるいは @ status=5 を実行後
	の status の値は 0 ではなく 5 です．また，exit 5 を実行後
	の status の値も，やはり 5 です．


	alias

		定義されているすべての別名とその意味を表示します．


	alias <名前>

		別名 <名前> の定義を表示します．


	alias <名前> <単語リスト>

		<名前> を <単語リスト>（コマンド）の別名として定
		義します．


	alloc

		Ｃシェルの同名の組み込みコマンドと同じようなもの
		ですが，メモリ使用方式が違うので今のところはあま
		り意味はありません．^^;


	bind

		現在のキー・バインドを表示します．ただし
		self-insert と error は表示しません．


	bind -a

		現在のすべてのキーのバインドを表示します．

	bind <キー>
	bind -1 <キー>
	bind prefix-1 <キー>
	bind -2 <キー>
	bind prefix-2 <キー>

		<キー>，prefix-1 <キー>，prefix-2 <キー> にバイン
		ドされている機能を表示します．<キー> は 1文字の引
		数です．制御文字を <キー> として指定するために，
		引数 <キー> を '^D' のように 2文字で表わすことが
		できます．もちろん，もし可能ならば制御文字を直接
		引数に置いてもかまいません．


	bind <キー> <機能>
	bind -1 <キー> <機能>
	bind prefix-1 <キー> <機能>
	bind -2 <キー> <機能>
	bind prefix-2 <キー> <機能>

		<キー>，prefix-1 <キー>，prefix-2 <キー> に <機能>
		をバインドします．<機能> については後で解説します．


	bind <キー> macro <文字列>
	bind -1 <キー> macro <文字列>
	bind prefix-1 <キー> macro <文字列>
	bind -2 <キー> macro <文字列>
	bind prefix-2 <キー> macro <文字列>

		<キー>，prefix-1 <キー>，prefix-2 <キー> に <文字
		列> をバインドします．このコマンドを実行した後は，
		<キー>（あるいは prefix-1 <キー>，prefix-2 <キー>）
		を押すと，<文字列> があたかもユーザがタイプしたか
		のように入力されます．


	breaksw

		現在の switch の endsw の直後に跳びます．現在の行
		の残りのコマンドは実行されます．ですから，

			breaksw ; break

		は，現在の switch〜endsw を脱出した後，その外側の
		foreach または while のループも脱出します．


	break

		現在の foreach / while の end の直後に跳び，ルー
		プを脱出します．現在の行の残りのコマンドは実行さ
		れます．ですから，

			break ; break

		は，現在のループを脱出した後，その外側のループも
		脱出します．


	cd
	chdir

		ユーザのホーム・ディレクトリに移動します．


	cd +<N>
	chdir +<N>

		ディレクトリ・スタックから現在のカレント・ディレ
		クトリを破棄して，ディレクトリ・スタックの <N>番
		目のディレクトリが先頭（すなわちカレント・ディレ
		クトリ）となるようにディレクトリ・スタックを循環
		送りします．ディレクトリ・スタックの先頭の要素は
		カレント・ディレクトリですから，新たに先頭となっ
		たディレクトリ（元の <N>番目のディレクトリ）に移
		動することになります．


	cd <名前>
	chdir <名前>

		ディレクトリ <名前> に移動します．ディレクトリ
		<名前> が存在しない場合にはシェル変数 cdpath の各
		要素のディレクトリ下のディレクトリ <名前> につい
		て試します．そのどれもが存在しない場合には，シェ
		ル変数 <名前> の値のディレクトリに移動します．そ
		れも存在しなければエラーとなります．


	continue

		現在の foreach / while の end に跳び，foreach /
		while を継続します．現在の行の残りのコマンドは実
		行されます．ですから，

			continue ; echo 'Next!'

		は，実際には 'Next!' を表示した後に continue する
		ことになります．


	dirs [ -l ] [ -v ]

		ディレクトリ・スタックの内容を表示します．左側が
		スタックの先頭であり，カレント・ディレクトリを表
		わします．通常は，要素がユーザのホーム・ディレク
		トリ下のディレクトリである場合，ユーザのホーム・
		ディレクトリ部分は ~ と略記します．-l オプション
		を指定すると，どの場合にも完全パス名を表示します．
		-v オプションを指定すると，1行に 1エレメントの形
		式でスタックの先頭から順に番号とともに表示します．
		スタックの先頭すなわちカレント・ディレクトリは 0
		番 であり，以下，1, 2, 3, ... と続きます．


	echo [ -2 ] [ -n ] [ -e ] [ - ] <単語リスト>

		<単語リスト> を標準出力に出力します．-2 オプショ
		ンを指定すると標準出力ではなく標準エラー出力に出
		力します．単語間には 1文字のスペースを出力します．
		通常は単語の数が 0個でなければ最後に復帰改行を出
		力しますが，-n オプションはそれを抑止します．

		-e オプションを指定すると，UNIX の /bin/echo と同
		じ仕様となり，以下のエスケープ・シーケンスを使用
		することができます．

			\b	バック・スペース
			\c	最後の復帰改行を抑止する
			\f	改頁
			\n	復帰改行
			\r	復帰
			\t	水平タブ
			\v	垂直タブ
			\0ddd	8進表記の文字コード．d は‘0’から
				‘7’までで，1桁から 3桁まで．

		これは ksh / bash ともほぼ同じですが、\0ddd は
		ksh / bash では \ddd であることに注意して下さい．

		-e オプションを指定したときには，単語の数が 0個で
		あっても最後に復帰改行を出力します．これを抑止す
		るには，単語リストの中に‘\c’を置くかまたはオプ
		ション引数 -n を指定します．

		<単語リスト> の最初の単語がオプション引数と認めら
		れてしまうケースでは，<単語リスト> の直前に単語
		‘-’を置いて，それを回避してください．

		alias echo '~~/echo -e -' によって echo を完璧に
		UNIX の /bin/echo と同じにすることができます．


	eval <単語リスト>

		<単語リスト> をシェルの入力行として解析し，現在の
		シェルで実行します．ただし出力がパイプやファイル
		に切り替えられている場合にはサブシェルで実行され
		ます．


	exit [ <式> ]

		現在の行を実行した後にシェルを終了させます．exit
		自体の終了ステータスは <式> の値です．<式> を省略
		した場合には 0 となります．

		シェルは終了する際，通常はシェル変数 status の値
		をシェルの終了ステータスとします．ですから，

			exit 5

		を実行すると，シェル変数 status の値は 5 となり，
		シェルは終了ステータスを 5 として終了します．

			exit 5 ; echo bye bye

		では，exit 実行後にシェル変数 status の値は 5 と
		なりますが，その後 echo を実行して，status は 0
		となり，シェルは終了ステータスを 0 として終了しま
		す．

			exit 5 ; goto label

		では，exit 実行後，ラベル label に跳びますので，
		シェルは終了しません．


	glob <単語リスト>

		<単語リスト> を標準出力に出力します．単語間には
		NUL (0x00) を出力します．そのほかには何も追加し
		ません．


	goto <ラベル>

		<ラベル> に跳びます．現在の行の残りのコマンドは実
		行されます．ですから，

			goto foo ; goto bar

		は，ラベル foo に跳んだ後，ラベル bar に跳びます．
		シェルの入力が標準入力であるときには goto は実行
		できません．


	hashstat

		ハッシュ表によるコマンド検索の成功度を表示します．


	history [ -h ] [ -r ] [<数>]

		保存されている履歴リストから最新の <数> 個のイベ
		ントを，イベント番号および登録された時刻と共に表
		示します．<数> を省略するとシェル変数 history の
		値がデフォルトとなります．-r オプションを指定する
		と新しい順に，さもなくば古い順に表示します．-h オ
		プションを指定するとイベント番号や登録された時刻
		を付けずにイベント本体のみを表示します．


	history -x <N>[-<M>]

		履歴の N番（から M番まで）のイベントをイベント番
		号や登録時刻なしで標準出力に出力します．


	logout

		ログイン・シェルを即座に終了させます．


	onintr

		^C が押されたときには実行を停止するようにします．
		シェルの入力が標準入力であるときには実行できませ
		ん．


	onintr -

		^C が押されても次の行からの実行を継続するようにし
		ます．^C 自体を禁止するものではありませんので注意
		してください．シェルの入力が標準入力であるときに
		は実行できません．


	onintr <ラベル>

		^C が押されたときに <ラベル> に跳ぶようにします．
		シェルの入力が標準入力であるときには実行できませ
		ん．


	popd

		ディレクトリ・スタックの先頭のディレクトリ（すな
		わちカレント・ディレクトリ）を破棄して，新たに先
		頭となったディレクトリに移動します．


	popd +<N>

		ディレクトリ・スタックの <N>番目のディレクトリを
		破棄します．ディレクトリ・スタックの先頭（すなわ
		ちカレント・ディレクトリ）は 0番です．<N> は 1以
		上でなければなりません．


	pushd

		ディレクトリ・スタックの先頭の 2つのディレクトリ
		を交換します．ディレクトリ・スタックの先頭の要素
		はカレント・ディレクトリですから，新たに先頭となっ
		たディレクトリに移動することになります．


	pushd +<N>

		ディレクトリ・スタックの <N>番目のディレクトリが
		先頭（すなわちカレント・ディレクトリ）となるよう
		にディレクトリ・スタックをカレント・ディレクトリ
		を含めて循環送りします．ディレクトリ・スタックの
		先頭の要素はカレント・ディレクトリですから，新た
		に先頭となったディレクトリ（元の <N>番目のディレ
		クトリ）に移動することになります．ディレクトリ・
		スタックの先頭（すなわちカレント・ディレクトリ）
		は 0番です．<N> は 1以上でなければなりません．


	pushd <名前>

		カレント・ディレクトリの完全パス名をディレクトリ・
		スタックにプッシュした後に，ディレクトリ <名前>
		に移動します．cd コマンド同様，ディレクトリ <名前>
		が存在しない場合にはシェル変数 cdpath の各要素の
		ディレクトリ下のディレクトリ <名前> について試し
		ます．そのどれもが存在しない場合には，シェル変数
		<名前> の値のディレクトリに移動します．それも存在
		しなければエラーとなります．


	pwd [ -l ]

		カレント・ディレクトリを表示します．通常は，カレ
		ント・ディレクトリがユーザのホーム・ディレクトリ
		下のディレクトリである場合，ユーザのホーム・ディ
		レクトリ部分は ~ と略記します．-l オプションを指
		定すると，どの場合にも完全パス名を表示します．


	rehash

		コマンド検索ハッシュ表を更新します．


	repeat <回数> <コマンド>

		<コマンド> を <回数> だけ繰り返し実行します．<コ
		マンド>	は単一のコマンドもしくはサブシェルでなけ
		ればならず，別名も効きません．<回数> が 0 ならば
		<コマンド> は実行されませんが，組み込みコマンド
		repeat に対する入出力切り替えは行われることに注意
		してください．


	set

		定義されているシェル変数をすべて表示します．変数
		の値は ( )で囲って表示されます．ただし要素数が 1
		個ならば ( ) は付きません．


	set <名前>
	set <名前>=<単語>
	set <名前>[<インデックス>]=<単語>
	set <名前>=(<単語リスト>)

		最初の形式は値が 1つの空単語であるシェル変数 <名
		前> をセットします．2番目の形式は値が 1つの <単語>
		であるシェル変数 <名前> をセットします．3番目の形
		式はシェル変数 <名前> の <インデックス> 番目の要
		素を <単語> とします．この形式のセットを行うには，
		<インデックス> 以上の数の要素を持つシェル変数 <名
		前> が既にセットされている必要があります．最後の
		形式は値が <単語リスト> であるシェル変数 <名前>
		をセットします．

		いずれの形式においても，‘=’の前後には空白文字
		（スペース，復帰，改行，改頁，水平タブ，垂直タブ）
		があってもなくてもかまいません．

		これらの引数は，単一の set コマンド内で複数のセッ
		トを行うするために繰り返すことができます．


	setenv

		定義されている環境変数をすべて表示します．


	setenv <名前>

		値が空文字列である環境変数 <名前> をセットします．


	setenv <名前> <値>

		値が <値> である環境変数 <名前> をセットします．


	shift

		シェル変数 argv の要素を左に 1つシフトします．最
		初の要素は破棄されます．


	shift <名前>

		シェル変数 <名前> の要素を左に 1つシフトします．
		最初の要素は破棄されます．


	source [ -h ] <ファイル名>

		スクリプト・ファイル <ファイル名> を現在のシェル
		で実行します．ただし出力がパイプやファイルに切り
		替えられている場合にはサブシェルで実行されます．
		-h オプションを指定するとコマンドを実行せず，スク
		リプトからの入力行を履歴リストに登録します．
		<ファイル名> として '-' を指定すると標準入力から
		読み取ります．たとえば

			make -n | source -

		は make が実行するであろうコマンドを make ではな
		く fish で実行します．また，

			make -n | source -h -

		とすれば make が実行するであろうコマンドが履歴リ
		ストに登録されます．それを

			history -x <N>-<M> | source -

		で実行したり，あるいは行編集機能 up-history を用
		いて編集してから実行することができます．


	time

		現在の FISH を起動してから経過した時間を表示しま
		す．


	time <コマンド>

		<コマンド> を実行し，コマンドが終了するまでに経過
		した時間を表示します．<コマンド> は単一のコマンド
		でなければならず，別名も効きません．


	unalias <パターン> ...

		<パターン> にマッチする別名をすべて取り消します．
		<パターン> にマッチする別名が定義されていなくても
		エラーにはなりません．単一の unalias コマンドで複
		数の取り消しを行うために複数の <パターン> を並べ
		ることができます．


	unhash

		コマンド検索ハッシュ表を使用しないようにします．


	unset <パターン> ...

		<パターン> にマッチするシェル変数をすべて削除しま
		す．<パターン> にマッチするシェル変数がセットされ
		ていなくてもエラーにはなりません．単一の unset コ
		マンドで複数の削除を行うために複数の <パターン>
		を並べることができます．


	unsetenv <名前> ...

		環境変数 <名前> を削除します．環境変数 <名前> が
		セットされていなくてもエラーにはなりません．単一
		の unsetenv コマンドで複数の削除を行うために複数
		の <名前> を並べることができます．


	which <コマンド名>
	which -o <コマンド名>
	which -O <コマンド名>

		コマンド <コマンド名> を検索し，そのパス名を表示
		します．-o オプションを指定すると別名は除外して検
		索し，-O オプションを指定するとさらに組み込みコマ
		ンドも除外して検索します．


	@

		set と同じです．


	@ <名前> = <式>

		値が <式> の値 1つであるシェル変数 <名前> をセッ
		トします．代入演算子の前後には空白文字（スペース，
		復帰，改行，改頁，水平タブ，垂直タブ）があっても
		なくてもかまいません．


	@ <名前> *= <式>
	@ <名前> /= <式>
	@ <名前> %= <式>
	@ <名前> += <式>
	@ <名前> -= <式>
	@ <名前> <<= <式>
	@ <名前> >>= <式>
	@ <名前> &= <式>
	@ <名前> ^= <式>
	@ <名前> |= <式>

		シェル変数 <名前> の最初の要素の値と <式> の値と
		をＣと同様に演算し，結果をシェル変数 <名前> にセッ
		トします．シェル変数 <名前> の要素数は 1つとなり
		ます．代入演算子の前後には空白文字（スペース，復
		帰，改行，改頁，水平タブ，垂直タブ）があってもな
		くてもかまいません．


	@ <名前>[<インデックス>] = <式>
	@ <名前>[<インデックス>] *= <式>
	@ <名前>[<インデックス>] /= <式>
	@ <名前>[<インデックス>] %= <式>
	@ <名前>[<インデックス>] += <式>
	@ <名前>[<インデックス>] -= <式>
	@ <名前>[<インデックス>] <<= <式>
	@ <名前>[<インデックス>] >>= <式>
	@ <名前>[<インデックス>] &= <式>
	@ <名前>[<インデックス>] ^= <式>
	@ <名前>[<インデックス>] |= <式>

		シェル変数 <名前> の <インデックス> 番目の要素の
		値と <式> の値とをＣと同様に演算し，結果をシェル
		変数 <名前> の <インデックス> 番目の要素にセット
		します．代入演算子の前後には空白文字（スペース，
		復帰，改行，改頁，水平タブ，垂直タブ）があっても
		なくてもかまいません．


	@ <名前> ++
	@ <名前> --

		シェル変数 <名前> の最初の要素の値に 1 を加算／減
		算した結果をシェル変数 <名前> にセットします．シェ
		ル変数 <名前> の要素数は 1つとなります．演算子の
		前には空白文字（スペース，復帰，改行，改頁，水平
		タブ，垂直タブ）があってもなくてもかまいません．


	@ <名前>[<インデックス>] ++
	@ <名前>[<インデックス>] --

		シェル変数 <名前> の <インデックス> 番目の要素の
		値に 1 を加算／減算した結果をシェル変数 <名前> の
		<インデックス> 番目の要素にセットします．演算子の
		前には空白文字（スペース，復帰，改行，改頁，水平
		タブ，垂直タブ）があってもなくてもかまいません．


-------------------------------------------------------------------
■ FISH の制御文


	FISH は以下の文を「組み込みコマンド」としてではなく，独立
	した「文」としてコマンドよりも前に解釈します．これらの文
	は，それだけを 1行としなければなりません．

	これらの文の動作はＣシェルとほぼ同じです．ここではＣシェ
	ルとの相違点のみを述べます．


	if ( <式> ) <コマンド>

	    ・ ( ) は必要です．

	    ・ 別名コマンドを使用することができます．

	    ・ if (1) command1;command2 はＣシェルでは
	       {if 1 command1} と {command2} の 2つのコマンドのリ
	       ストと解釈されますが，FISH は
	       if (1) {command1;command2} という 1つの文であると
	       解釈します．


	if ( <式> ) then
	    ...
	else if ( <式> ) then
	    ...
	...
	else
	    ...
	endif

	    ・ 式 の前後の ( ) は必要です．

	    ・ 実行されない行も履歴リストに追加します．


	switch ( <文字列> )
	case <パターン>:
	    ...
	...
	default:
	    ...
	endsw

	    ・ 実行されない行も履歴リストに追加します．


	foreach var ( <単語リスト> )
	    ...
	end

	    ・ Ｃシェルでは対話モードで <単語リスト> が 1度余計に
	       評価されてしまいますが，このバグは FISH にはありま
	       せん．

	    ・ 対話モードではループの中の行も履歴リストに追加しま
	       す．


	while <式>
	    ...
	end

	    ・ Ｃシェルでは対話モードで <単語リスト> が 1度余計に
	       評価されてしまいますが，このバグは FISH にはありま
	       せん．

	    ・ 対話モードではループの中の行も履歴リストに追加しま
	       す．


	<ラベル>:

	    ・ <ラベル> は先頭の31バイトのみが有効です．


-------------------------------------------------------------------
■ 式


	式の値は，符号付き32ビット整数であり，オーバーフローおよ
	びアンダーフローは無視します．例外として，0 による除算お
	よび剰余算はエラーとします．


	以下に式と演算子について解説します．


	優先順位  結合方向              式
	--------------------------------------------------------
	   高        <-    + E     - E     ~ E     ! E
	             ->    E1 * E2   E1 / E2   E1 % E2
	   ↑        ->    E1 + E2   E1 - E2
	             ->    E1 << E2  E1 >> E2
	             ->    E1 <= E2  E1 >= E2  E1 < E2   E1 > E2
	             ->    E1 == E2  E1 != E2  E =~ pat  E !~ pat
	             ->    E1 & E2
	             ->    E1 ^ E2
	             ->    E1 | E2
	             ->    E1 && E2
	   ↓        ->    E1 || E2
	             <-    E1 ? E2 : E3
	   低        ->    E1 , E2
	--------------------------------------------------------

	演算子は 1つの単語として独立していなければなりません．演
	算子の前後には必ず空白文字（スペース，復帰，改行，改頁，
	水平タブ，垂直タブ）を置くようにしてください．例外として
	‘||’や‘(’など，自動的に 1つの単語と見なされる綴りもあ
	ります．（「単語分け」参照）

	‘==’，‘!=’，‘=~’，‘!~’ 以外は数値演算子であり，言
	語Ｃと同じです．E，E1，E2，および E3 は符号付き32ビット整
	数として扱われます．これらの式の値は，内部的には10進表記
	の文字列の状態で処理されています．演算を行う際には一旦数
	値に変換して演算を行い，その結果を再び文字列に変換してい
	ます．

	‘==’と‘!=’も言語Ｃと同じ意味ですが，E1 と E2 を数値と
	してではなく文字列として比較します．式 foo == foo の値は
	1 となります．E1 と E2 を数値とした場合，たとえば式
	69 == 69 の値も当然 1 となりますし，式 66 + 3 == 69 の値
	も 1 となります．左辺の式 66 + 3 は先に計算されて 69 とい
	う文字列になり，それと右辺の文字列 69 とが比較されること
	になるからです．ただし，0x10 == 16 では，一次子 0x10 は文
	字列としてそのまま評価されるため，これは右辺の文字列 16
	とは一致せず，この式の値は 0 となってしまいます．これを例
	えば 0x10 + 0 == 16 とすると，一次子 0x10 は演算子‘+’の
	ために一度数値に変換され，それに 0 を加えた結果は文字列
	‘16’に変換されるので，この式の値は 1 となります．

	‘=~’と‘!~’ではパターン比較を行います．これらにおいて
	は左辺の E は‘==’や‘!=’と同様ですが，右辺の pat はメ
	タ・キャラクタを含むパターンです．メタ・キャラクタには次
	のものがあります．

		*	0個以上の文字とマッチします．
		?	任意の 1文字とマッチします．
		[list]  list 中の 1文字とマッチします．
		[^list] list に含まれない 1文字とマッチします．

	list 中では‘-’は範囲を表わします．lower-upper は，文字
	コード上文字 lower と文字 upper の間にある任意の 1文字と
	マッチすることになります．

	list 中でも文字‘\’は続く文字をエスケープします．エスケー
	プされていない‘[’または‘[^’の直後では‘-’と‘]’は特
	別な意味を持ちません．また，特別な意味を持つ‘-’に続く
	‘-’と‘]’は特別な意味を持ちません．Ｃシェルとまったく
	同じではないことに注意して下さい．

	なお，マルチバイト文字も 1文字と見なします．マルチバイト
	文字は，どの 1バイト文字よりも大きいものとします．


   一次式


	ddd..

		10進数


	0ddd..

		8進数


	0xddd..
	0Xddd..

		16進数


	-d file

		file がディレクトリ・エントリとして存在し，且，ディ
		レクトリ属性が ON ならば 1．さもなくば 0．


	-e file

		file がディレクトリ・エントリとして存在するならば
		1．さもなくば 0．


	-f file
		file がディレクトリ・エントリとして存在し，且，通
		常のファイルならば 1．さもなくば 0．


	-w file

		file がディレクトリ・エントリとして存在し，且，読
		み込み専用属性が OFF ならば 1．さもなくば 0．


	-z file

		file がディレクトリ・エントリとして存在し，且，サ
		イズが 0 ならば 1．さもなくば 0．


	-c name

		name がオープン可能であり，且，キャラクタ・デバイ
		スであるならば 1．さもなくば 0．


	-b name

		name がオープン可能であり，且，ブロック・デバイス
		であるならば 1．さもなくば 0．


	-a file

		file がディレクトリ・エントリとして存在し，且，アー
		カイブ属性が ON ならば 1．さもなくば 0．


	-h file

		file がディレクトリ・エントリとして存在し，且，隠
		匿属性が ON ならば 1．さもなくば 0．


	-s file

		file がディレクトリ・エントリとして存在し，且，シ
		ステム属性が ON ならば 1．さもなくば 0．


	-v file

		file がディレクトリ・エントリとして存在し，且，ボ
		リューム・ラベル属性が ON ならば 1．さもなくば 0．


	-t n
		シェルのファイル・デスクリプタ n がコンソールなら
		ば 1．さもなくば 0．


	sizeof file

		ディレクトリ・エントリ file のサイズ．file が存在
		しないならば 0．


	timeof file

		ディレクトリ・エントリ file のタイム・スタンプの
		値．file が存在しないならば 0．


	freeof d:

		ドライブ d の空き容量（バイト）．カレントのドライ
		ブは‘@:’で指定することができます。


	strlen word

		word の長さ．


	{ command }

		command をサブシェル（現在のシェルのコピー）
		で実行し，その終了ステータスが 0 ならば 1．
		さもなくば 0．


	( E )

		式 E の値．


	式は，予め全体的に変数置換されてから評価されます．さらに，
	キーワードや演算子を除いた各トークンに対して個別にコマン
	ド置換，組み合わせ展開，ホーム・ディレクトリ置換，ファイ
	ル名展開の順序で置換・展開が行われます．ただし，演算子
	‘=~’および‘!~’の右辺のトークンに対しては一切置換・展
	開を行いません．


-------------------------------------------------------------------
■ コマンドの実行


	FISH に対して -c オプションも -t オプションも指定されてい
	なければ，FISH は起動時にシェル変数 path にセットされてい
	る各ディレクトリのうち完全パスであるディレクトリにあるエ
	ントリを内部のハッシュ表にハッシュします．また，シェル変
	数 path をセットすると，ハッシュ表を自動的に更新します．
	環境変数 path をセットするとシェル変数 path も自動的にセッ
	トされ，ハッシュ表を更新します．組み込みコマンド rehash
	を実行したときにもハッシュ表を更新します．

	FISH は，コマンド名がドライブ／ディレクトリ名を含んでいな
	い場合には，シェル変数 path にセットされている各ディレク
	トリからコマンドを検索します．このとき，ボリューム・ラベ
	ルとディレクトリは除外します．このとき，内部のハッシュ表
	を利用して，コマンドが存在する可能性のないディレクトリで
	は検索を行いません．このハッシュ機構によって，シェル変数
	path に多数のディレクトリがセットされている場合のコマンド
	の検索を高速化しています．新しいコマンド・ファイルをシェ
	ル変数 path のディレクトリに置いた後には，組み込みコマン
	ド rehash を実行してハッシュ表を更新しないと，そのコマン
	ドは検索されない可能性があります．ハッシュ機構を組み込み
	コマンド unhash によってオフにしている場合や，-c オプショ
	ンまたは -t オプションが指定されていてハッシュ表が作成さ
	れていない場合，および検索するディレクトリが完全パスでな
	い場合には，必ず検索を行います．

	コマンド名がドライブ名／ディレクトリ名を含んでいる場合に
	はそのドライブ／ディレクトリからコマンドを検索します．

	検索を行う各々のディレクトリにおいては，まず，コマンド名
	のファイル名部分（ドライブ名／ディレクトリ名を除いた部分）
	と完全に一致するファイルを検索します．ここで一致するファ
	イルがなかったとき，コマンド名のファイル名部分に‘.’が含
	まれていなければ以下の拡張子を持つファイルも検索対象とし
	て再検索します．

		--------------------
		 拡張子    優先順位
		--------------------
		  .R          高
		  .Z          ↑
		  .X          ↓
		  .BAT        低
		--------------------

	なお，これらの拡張子部分については大文字と小文字を区別せ
	ずに照合し，優先順位が同じであれば最後に検索されたファイ
	ルを採用します．大文字と小文字を区別するシステムでは注意
	が必要です．

	見つかったコマンド・ファイルの拡張子が‘.R’，‘.Z’，
	‘.X’のいずれか（大文字と小文字は区別しません）である場
	合，FISH はそのファイルを直接 exec します．拡張子が
	‘.BAT’（大文字と小文字は区別しません）である場合には，
	そのコマンド・ファイルのパス名の‘/’を‘\’に替えた名前
	を引数として，シェル変数 batshell にセットされているコマ
	ンド・ファイルを exec します．それ以外の場合，ファイルの
	内容の先頭が‘#$’または‘#!’であれば，このファイルをス
	クリプトであると見なして実行し，さもなくば実行しません．
	スクリプト・ファイルの先頭行に‘#!’に続けてコマンド・ファ
	イルのパス名と引数が記述されていれば，その引数の後ろにス
	クリプトのパス名を加え，そのコマンド・ファイルを exec し
	ます．先頭行の‘#!’以降 LF（改行）までが空であるか空白文
	字（スペース，復帰，改頁，水平タブ，垂直タブ）だけである
	場合，またはスクリプト・ファイルの内容の先頭が‘#$’であ
	る場合には，スクリプトのパス名を引数として，シェル変数
	shell にセットされているコマンド・ファイルを exec します．

	検索パス‘~~’は，仮想的に組み込みコマンドが置かれている
	ディレクトリを意味します．仮想ディレクトリ‘~~’を検索す
	る際には大文字と小文字を区別し，拡張子も補いません．

	実行するコマンドが組み込みコマンドでなければ，コマンドの
	実行が終わる度にその終了ステータスがシェル変数 status に
	セットされます．

	組み込みコマンドを実行する際には，実行する直前にシェル変
	数 status に 0 がセットされ，その後，組み込みコマンド実行
	時にエラーがあったときにのみ，シェル変数に 1 がセットされ
	ます．ですから，set status=5 あるいは @ status=5 を実行後
	の status の値は 0 ではなく 5 です．また，exit 5 を実行後
	の status の値も，やはり 5 です．


-------------------------------------------------------------------
■ 特別な環境変数


	HOME

		FISH 起動時，FISH がシェル変数 home を初期化する
		ために参照します．また，シェル変数 home が再設定
		されたとき自動的に再設定されます．


	LOGNAME

		FISH 起動時，環境変数 USER が存在していなければ，
		FISH がシェル変数 user を初期化するために参照しま
		す．


	PWD

		カレントの作業ディレクトリの完全パス名が FISH に
		よって自動的にセットされます．ディレクトリの区切
		り文字は‘\’です．環境変数 PWD のセットは，シェ
		ル変数 cwd のセットと同時に行われます．


	SYSROOT

		システムのルート・ディレクトリを示しています．例
		えばファイル /etc/passwd の位置は，

			  $%SYSROOT  ファイル /etc/passwd のパス
			----------------------------------------
			   未定義       /etc/passwd
			   空           /etc/passwd
			   /            /etc/passwd
			   /ita         /ita/etc/passwd
			   C:           C:/etc/passwd
			   C:/          C:/etc/passwd
			   C:/ita       C:/ita/etc/passwd

		のように制御されます．ファイル /etc/fishrc も同様
		に制御されます．また，シェル変数 batshell および
		shell の初期値もこの変数の制御を受けます．

		※ この変数はユーザが変更してはなりません．


	TERM

		FISH 起動時，FISH がシェル変数 term を初期化する
		ために参照します．また，シェル変数 term が再設定
		されたとき自動的に再設定されます．


	USER

		FISH 起動時，FISH がシェル変数 user を初期化する
		ために参照します．また，シェル変数 user が再設定
		されたとき自動的に再設定されます．


	path

		FISH 起動時，FISH がシェル変数 path を初期化する
		ために参照します．また，シェル変数 path が再設定
		されたとき自動的に再設定されます．この環境変数が
		再設定されたときにはシェル変数 path も自動的に再
		設定されます．


	temp

		FISH 起動時，FISH がシェル変数 temp を初期化する
		ために参照します．また，シェル変数 temp が再設定
		されたとき自動的に再設定されます．


-------------------------------------------------------------------
■ 関連ファイル


	$%SYSROOT/bin/COMMAND.X

		コマンド・ファイル．拡張子が .BAT であるスクリプ
		ト用の標準のシェル．


	$%SYSROOT/bin/fish.x

		コマンド・ファイル．#$ または #! で始まるスクリプ
		ト用の標準のシェル．


	$%SYSROOT/etc/passwd

		システム・ファイル．他ユーザのホーム・ディレクト
		リを得るために参照します．


	$%SYSROOT/etc/fishrc

		システム環境ファイル．もしあれば，FISH 起動時に最
		初に source します．ただし FISH に対してオプション
		引数 -f が指定されている場合には source しません．


	~/%fishrc

		個人環境ファイル．もしあれば，FISH 起動時に
		$%SYSROOT/etc/fishrc の後に source します．ただ
		し FISH に対してオプション引数 -f が指定されてい
		る場合には source しません．


	~/%history

		個人環境ファイル．もしあれば，FISH 起動時に
		~/%fishrc や ~/%login を source した後に
		source -h します．ただし FISH に対してオプション
		引数 -f が指定されている場合には source しません．

		FISH がログイン・シェルであるとき，シェル変数
		savehist がセットされているならば，~/%logout を
		source した後に $savehist[1] が示す行数分の最新の
		履歴イベントをセーブします．


	~/%login

		個人環境ファイル．FISH がログイン・シェルであると
		き，もしあれば FISH 起動時に ~/%fishrc の後に
		source します．


	~/%logout

		個人環境ファイル．FISH がログイン・シェルであると
		き，もしあれば FISH 終了時に source します．


-------------------------------------------------------------------
■ 行入力機構


	FISH は編集機能を持つ独自の行入力機構を持っています．FISH
	がインタラクティブ・モードであって，かつシェル変数
	usegets がセットされていなければ，独自の行入力機構が働き
	ます．

	FISH の行入力機構では，端末から入力されるすべてのコードに
	「機能」がバインドされています．各コードの機能は，組み込
	みコマンド bind で自由に変更することができます．

	まず，機能について解説します．


	abort
		行入力を中止し，^C 処理に跳びます．


	accept-line

		入力した行をシェルに渡します．


	backward-char

		カーソルを 1文字後方に移動します．


	backward-word

		カーソルを 1語後方に移動します．


	beginning-of-line

		カーソルを行の先頭に移動します．


	clear-and-redraw

		画面をクリアしてから行を書き直します．


	complete

		現在のカーソル位置までの文字列を補い，ユーザ名／
		ファイル（ディレクトリ・エントリ）名／組み込みコ
		マンド名を完成させます．

		補完とは，入力済みの文字列から特定できる残りの綴
		りを，あたかもそれをユーザがタイプしたかのように
		追加することです．

		カーソルよりも左に空白文字（スペース，復帰，改行，
		改頁，水平タブ，垂直タブ）や‘"’，‘'’，‘`’，
		‘^’，‘&’，‘(’，‘)’，‘|’，‘;’，‘<’，
		‘>’がある場合には，その次の文字からカーソル位置
		までが補完させる文字列となります．

		補完させる文字列中に文字‘\’があっても，特別な意
		味を認めず，単なる文字とします．

		補完させる文字列が‘~~/’で始まっているならば組み
		込みコマンド名を補完します．そうではなく，補完さ
		せる文字列が‘~’で始まっていて，且‘/’を含んで
		いないならばユーザ名を補完します．それ以外の場合
		はディスク上のファイル（ディレクトリ・エントリ）
		名を補完します．ただし，エントリ‘.’および‘..’
		とボリューム・ラベルは常に候補対象から除外されま
		す．

		ファイル名を補完するとき，通常はファイル名の大文
		字と小文字を区別しますが，シェル変数 cifilec が
		セットされていれば FISH は検索されたファイル名の
		再チェックを省きますので，ファイル名の大文字と小
		文字は区別されなくなります．ただし，ファイル名の
		大文字と小文字を区別する非標準の Human68k上では，
		シェル変数 cifilec をセットしてもファイル名の大文
		字と小文字は区別されてしまいます．

		パスの途中のディレクトリ名を‘\’で区切ったファイ
		ル名を補完することはできません。ファイル名補完で
		は，ディレクトリの区切りは‘/’のみが認められます．

		補完できる名前の候補が 1つもなければ，通常，ベル
		が鳴ります．入力済みの文字列にマッチする名前が 2
		つ以上ある場合には，いずれにしても特定できる綴り
		のみを補って，通常はベルを鳴らします．

		シェル変数 recexact がセットされているときには，
		完全に一致する名前が 1つあれば，さらに長い候補が
		あってもそれ以上は補完しません．この場合には通常
		はベルは鳴りません．

		補完の際にベルを鳴らす条件は，シェル変数
		matchbeep と nobeep とで制御することができます．

		無視したいサフィックスのリストをシェル変数
		fignore にセットしておくことにより、特定のサフィッ
		クスを持ったファイルを候補対象から除外することが
		できます．ただし，与えられた文字列から完成できる
		唯一の名前が fignore で除外されているものでしか特
		定できない場合には，これらのサフィックスを無視し
		ません．


	copy-region

		マークとカーソルの間の範囲をバッファにコピーしま
		す．


	delete-backward-char

		カーソルの後方の 1文字を削除します．


	delete-forward-char

		カーソル下の 1文字を削除します．


	down-history

		編集行の先頭からカーソル位置までの部分が一致する
		行を履歴リストから降順に検索します．


	downcase-char

		カーソル下の 1文字の ASCII 大文字を小文字に変換し
		ます．


	downcase-region

		マークとカーソルの間の範囲の ASCII 大文字を小文字
		に変換します．


	downcase-word

		カーソル位置から単語の終わりまでの範囲の ASCII 大
		文字を小文字に変換します．


	end-of-line

		カーソルを行末に移動します．


	eof

		EOF を入力します．


	error

		エラーとします．prefix-1，prefix-2，qouted-insert
		等はキャンセルされます．また，シェル変数 nobeep
		がセットされていない場合にはベルが鳴ります．


	exchange-point-and-mark

		マーク位置とカーソル位置を交換します．


	forward-char

		カーソルを 1文字前方に移動します．


	forward-word

		カーソルを 1語前方に移動します．


	kill-backward-word

		後方の 1語を削除してバッファにコピーします．


	kill-forward-word

		前方の 1語を削除してバッファにコピーします．


	kill-region

		マークとカーソルの間の範囲を削除してバッファにコ
		ピーします．


	kill-to-bol

		行の先頭からカーソルの直前までの範囲を削除してバッ
		ファにコピーします．


	kill-to-eol

		カーソル位置から行末までの範囲を削除してバッファ
		にコピーします．


	list

		現在の状態での，機能 complete の候補を文字コード
		順にソートして表示します．ここではシェル変数
		fignore は効きません．ディレクトリは‘/’付きで表
		示されます．

		この機能は，ユーザ，ファイル，組み込みコマンドの
		一覧を見たいときにも便利です．


	prefix-1

		prefix-1 シーケンスを導きます．たとえば

			bind ^[ prefix-1
			bind -1 ^L clear-and-redraw

		と設定すると，ESC ^L の 2ストロークで，機能
		clear-and-redraw が働くことになります．


	prefix-2

		prefix-2 シーケンスを導きます．たとえば

			bind ^X prefix-2
			bind -2 ^L downcase-region

		と設定すると，^X ^L の 2ストロークで，機能
		downcase-region が働くことになります．


	quoted-insert

		次に入力されるキャラクタをエスケープし，通常の文
		字として行に挿入します．


	redraw

		一旦改行し，行を書き直します．


	search-character

		次に入力されるキャラクタを，カーソルの次の位置か
		ら行末まで検索し，もし見つかればカーソルをそこに
		移動します．見つからなかったならば，行の先頭から
		再び検索します．


	self-insert

		自分自身を通常の文字として行に挿入します．


	set-mark

		カーソル位置をマークします．


	transpose-chars

		カーソル下の文字と後方の文字とを交換します．


	transpose-words

		カーソル下の単語と後方の単語とを交換します．


	up-history

		編集行の先頭からカーソル位置までの部分が一致する
		行を履歴リストから昇順に検索します．


	upcase-char

		カーソル下の 1文字の ASCII 小文字を大文字に変換し
		ます．


	upcase-region

		マークとカーソルの間の範囲の ASCII 小文字を大文字
		に変換します．


	upcase-word

		カーソル位置から単語の終わりまでの範囲の ASCII 小
		文字を大文字に変換します．

	yank

		バッファの内容をカーソル位置に挿入します．


	「単語」を 1単位とする機能がありますが，それらは FISH の
	行解析部と同じ字句解析を行って単語を分けます．

	FISH 起動時には，各入力コードには次の機能がバインドされて
	います．


		^C			abort
		^D			eof
		^H			del-back-char
		^M			accept-line
		その他の単一コード	self-insert
		prefix-1下の各コード	error
		prefix-2下の各コード	error

	各入力コードには，上記の機能の他，「マクロ」をバインドす
	ることができます．たとえば，

		bind ^[ prefix-1
		bind -1 . macro 。

	とすると，ESC . の 2ストロークで全角の「。」を行に挿入す
	ることができます．また，

		bind ^U upcase-char
		bind ^[ prefix-1
		bind -1 l downcase-word
		bind -1 c macro '^U^[l'
		#  ただし '' の中の ^U と ^[ は，制御コードを直接
		#  記述する．

	とすると，ESC c の 2ストロークで単語をキャピタライズする
	ことができます．


-------------------------------------------------------------------
■ マルチ・バイト文字対応


	FISH はシフトJIS文字コード（X68000独自の拡張を含む）に対応
	しています．


-------------------------------------------------------------------
